<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言 | WF的知识空间</title><meta name="author" content="WF"><meta name="copyright" content="WF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.什么是指针 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 指针指向哪里都可以（可以保存任何地址），但是若指针所指的空间不是有效空间程序会崩溃 零号空间~128m字节空间是禁止访问区 1int *p&#x3D;(int*)0  &#x2F;&#x2F;会崩溃 eg：①随机地址（野">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/index.html">
<meta property="og:site_name" content="WF的知识空间">
<meta property="og:description" content="1.什么是指针 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 指针指向哪里都可以（可以保存任何地址），但是若指针所指的空间不是有效空间程序会崩溃 零号空间~128m字节空间是禁止访问区 1int *p&#x3D;(int*)0  &#x2F;&#x2F;会崩溃 eg：①随机地址（野">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WF.png">
<meta property="article:published_time" content="2025-07-27T00:52:57.000Z">
<meta property="article:modified_time" content="2025-08-20T02:31:53.022Z">
<meta property="article:author" content="WF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C语言",
  "url": "http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/",
  "image": "http://example.com/img/WF.png",
  "datePublished": "2025-07-27T00:52:57.000Z",
  "dateModified": "2025-08-20T02:31:53.022Z",
  "author": [
    {
      "@type": "Person",
      "name": "WF",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WF的知识空间</span></a><a class="nav-page-title" href="/"><span class="site-name">C语言</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">C语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-20T02:31:53.022Z" title="更新于 2025-08-20 10:31:53">2025-08-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="1-什么是指针">1.什么是指针</h3>
<p><strong>指针</strong>也就是<strong>内存地址</strong>，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。</p>
<p>指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关</p>
<p><strong>指针指向哪里都可以（可以保存任何地址），但是若指针所指的空间不是有效空间程序会崩溃</strong></p>
<p><strong>零号空间~128m字节空间是禁止访问区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)<span class="number">0</span>  <span class="comment">//会崩溃</span></span><br></pre></td></tr></table></figure>
<p>eg：①随机地址（野指针，悬挂指针）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>②空指针:指向0号空间，对空指针解引用程序崩溃       <strong>零号空间~128m字节空间是禁止访问区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="literal">NULL</span>;</span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>其格式：*==type  *var_name;==   type取决于被指向的数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi=&amp;a;</span><br></pre></td></tr></table></figure>
<p>其中type必须是一个有效的数据类型。*p解释的是从0x1地址开始到0x1+sizeof（type）的所对应字节的内容</p>
<p>在<strong>多级指针</strong>中也一样，q保存的是a的地址，其中==<em>==是<strong>解引用</strong>的意思，对q保存的a的地址解引用就得到了10。对于w而言至右像左==</em>==对w解引用得到q的值即a的地址，再对a的地址解引用得到10。其中e也同理，属于无限套娃。</p>
<p>==多级指针从右至左匹配*解引用。==</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* q = &amp;a;</span><br><span class="line"><span class="type">int</span>** w = &amp;q;</span><br><span class="line"><span class="type">int</span>*** e = &amp;w;</span><br></pre></td></tr></table></figure>
<h3 id="2-c语言中-const-是一个类型限定符，用来修饰变量，表明该变量的值不能被修改">2.c语言中==const== 是一个<strong>类型限定符</strong>，用来修饰变量，表明该变量的值<strong>不能被修改</strong></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>指针设计与指针用途有关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>*p=*val;</span><br></pre></td></tr></table></figure>
<p>在设计指针时为了防止将预期*p修改为1其他值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p=&amp;val;</span><br></pre></td></tr></table></figure>
<p>即不可通过对p解引用修改val的值，指针指向的值不通过指针修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> P=&amp;val;</span><br></pre></td></tr></table></figure>
<p>即指针本身的值不可修改，p中只能存储val的地址</p>
<p>用法如以下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* q = &amp;p;</span><br><span class="line"><span class="type">int</span> w=<span class="number">3</span>；</span><br><span class="line">q = &amp;w；</span><br></pre></td></tr></table></figure>
<p>1.==const修饰的变量==只能由==指向const变量的指针==去指向—&gt;<strong>规定</strong></p>
<p>2.此时const的位置在==*==的左边</p>
<p>3.其中const限定修饰变量p，这使其p所对应的值1不能被修改，那么==*q==指向p所对应的值1，即也应该对==*q==加const变量限定修饰，但是==q==所保存的p的==地址==是可以修改的。</p>
<p><strong>被const修饰的指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,c;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="type">int</span>** p2 = &amp;p1;</span><br><span class="line"><span class="type">int</span>*** p3 = &amp;p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*const int* t1 = &amp;f;</span></span><br><span class="line"><span class="comment">const int** t2 = &amp;t1;</span></span><br><span class="line"><span class="comment">const int*** t3 = &amp;t2;</span></span><br><span class="line"><span class="comment">t1 = &amp;a;</span></span><br><span class="line"><span class="comment">t2 = &amp;p1;</span></span><br><span class="line"><span class="comment">t3 = &amp;p2;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* t = &amp;a;</span><br><span class="line">t = &amp;c;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*<span class="type">const</span> t1 = &amp;f;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span>* t2 = &amp;t1;</span><br><span class="line">t2 = &amp;t;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*<span class="type">const</span>*<span class="type">const</span>* t3 = &amp;t2;</span><br><span class="line">t2 = &amp;p1;</span><br><span class="line">t3 = &amp;p2;</span><br></pre></td></tr></table></figure>
<p>在此段代码中：==int b==的范围与==const*int t==的范围相同，b所对应的值0不能被改变，<strong>t所包含的b的地址不能被改变</strong>,此时变量b的值可以改变。</p>
<p>但在==const int<em>const v==中由于a被const修饰限定，那么指向a的指针t也应该被const修饰即**==const== int</em>const v**第一个const，而const int*==const== v中这个const是重新对v施加的限定，使得v只能保存a的地址。与此同时==const int const v = &amp;b;==也可以保存被const修饰的变量b</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*<span class="type">const</span> =<span class="type">const</span> <span class="type">int</span>*</span><br><span class="line">先检查权限看权限是否对等			从右向左权限可以缩小在==多级被<span class="type">const</span>所修饰的指针==中</span><br></pre></td></tr></table></figure>
<p><strong>指向const变量的指针</strong></p>
<p>我有一个const变量，我需要一个指针去指向他，那这个指针只能时一个指向const的指针，<strong>在*的左边有const</strong></p>
<p><strong>被const修饰的指针</strong></p>
<p>这个指针中，保存的地址不能改变，这个指针不能再指向别的变量。但被指向的变量本身是可以改变的，<strong>再*的右边有const</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> intconst* q = &amp;a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>** w = &amp;q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*** e = &amp;w;</span><br></pre></td></tr></table></figure>
<p>即多级指针中  const  在  *  左右的核心区别</p>
<ul>
<li>const  在  *  左侧 → 限制“指针指向的数据”：</li>
<li>无论多少级指针，只要某一层  const  在  *  左侧，就表示 “通过该指针（或其下层指针），不能修改最终指向的数据”。<br>
const  在  *  右侧 → 限制“指针变量本身”：-</li>
<li>某一层  const  在  *  右侧时，表示 “该层的指针变量地址不能变（不能指向其他地址）”。<br>
可以简单类比记忆：</li>
<li>const  在  *  左 → 给“数据房间”上锁，任你通过哪层指针开门，都改不了房间里的数据；</li>
<li>const  在  *  右 → 给“指针钥匙”焊死在锁孔，这把钥匙不能插到其他锁孔（指针不能换指向）。</li>
</ul>
<h3 id="3-数组指针（指针偏移量）">3.数组指针（指针偏移量）</h3>
<p>数组指针的本质是<strong>指向数组的==指针==</strong></p>
<p>在内存中数据的存储是连续的，而指针偏移量一般对于==数组==来说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br></pre></td></tr></table></figure>
<p>数组名为数组<strong>第一个元素</strong>的==首地址==如图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>*p=arr;</span><br><span class="line"><span class="type">int</span> *p=arr[<span class="number">0</span>];   </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">p</th>
<th style="text-align:center">arr</th>
<th style="text-align:center">arr[0]</th>
<th style="text-align:center">&amp;arr[0]</th>
<th style="text-align:center">&amp;arr</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类型</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int（*）[5]</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">变量</td>
<td style="text-align:center">常量值</td>
<td style="text-align:center">变量</td>
<td style="text-align:center">常量</td>
<td style="text-align:center">常量值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">数组首元素地址</td>
<td style="text-align:center">数组首元素地址</td>
<td style="text-align:center">首元素</td>
<td style="text-align:center">首元素地址常量</td>
<td style="text-align:center">数组首地址</td>
</tr>
</tbody>
</table>
<p>若要实现用数组表示数组中的元素==arr[i]==用指针表示==<em>（p+i）==而在数组中加==i==相当于**==当前地址=首地址+i</em>sizeof（数组类型）==**</p>
<p>这也衍生出了一个问题，如果我要使得指针+1一次跨过三个元素那么可以定义一个新的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*s)[<span class="number">3</span>] =(<span class="type">int</span>(*)[<span class="number">3</span>])arr;</span><br></pre></td></tr></table></figure>
<p>这种形式也叫做==数组指针==</p>
<p>==<em>（s+i）==s前进i位在内存上前进==3</em>sizeof（int）个B==，而等号右边的==（int（*）[3])==则是为了保证等号左右两边为同一类型。</p>
<p>数组指针常用于多维数组用来进行==行==的切换</p>
<p>二维数组在存放上是一维的形式，逻辑上是表的形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span>(*s)[<span class="number">3</span>]=arr;</span><br></pre></td></tr></table></figure>
<p><strong>二维数组在逻辑关系上是一个表格</strong>，但数组的存储在物理上是连续的为一位数组，因此使用二级指针来进行行的切换。</p>
<h3 id="4-指针数组">4.指针数组</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* s [<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>指针数组本质上是一个存放指针的数组，其==本质是数组==，其里面内容存放的是指针。</p>
<h3 id="5-为什么数组下标从0开始">5.为什么数组下标从0开始</h3>
<p>1.假设数组首地址起点为base</p>
<p>2.指针访问成员通过**==指针+偏移量解引用==*<em>即</em>（p+1）访问</p>
<p>3.根据地址计算公式</p>
<p>==<strong>现地址=首地址（base）+i*sizeof（数组类型）</strong>==</p>
<p>如果首地址为1，若要访问第一个元素就需要减去==i*sizeof（数组类型）==，很不方便，并且在早期计算机中处理预算需要时钟周期，早期算力不高，因此首地址为0即方便了运算又节省了算力。</p>
<h3 id="6-数组在存储中是由低地址向高地址存储的">6.数组在存储中是由低地址向高地址存储的</h3>
<p><strong>指针相加减</strong></p>
<p>一般在数组中指针相加没意义，指针相减高地址减低地址等于两个地址间所有的元素个数</p>
<h3 id="7-指针-p-和-p-的区别">7.指针==*p++==和==++*p==的区别</h3>
<p><strong>==“*”==与==“+”  “-”==优先级相同，结合方向至右向左</strong></p>
<h3 id="8-指针函数">8.指针函数</h3>
<p>本质是==函数==返回值是==指针==</p>
<p>int* arr(int q,inta);</p>
<h3 id="9-函数指针">9.函数指针</h3>
<p>==<strong>函数名本质是函数在内存的入口地址</strong>==</p>
<p>本质是==指针==	指向函数的指针</p>
<p>其定义方式	*<em>==函数值返回类型==（<em>p）==（函数的形式参数列表）==</em></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>)<span class="comment">//声明一个函数指针</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span><span class="comment">//声明一个指针函数</span></span><br></pre></td></tr></table></figure>
<p>函数名本身就是函数的内存地址，因此可以直接将函数名赋值给函数指针完成初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="type">int</span> (*p_func)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化：将函数名赋值给指针（函数名即地址）</span></span><br><span class="line">p_func = add;  <span class="comment">// 等价于 p_func = &amp;add;（&amp;可以省略）</span></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：使用解引用符*</span></span><br><span class="line"><span class="type">int</span> result1 = (*p_func)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 等价于调用 add(2, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：直接使用指针名（更简洁，常用）</span></span><br><span class="line"><span class="type">int</span> result2 = p_func(<span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// 同样等价于 add(2, 3)</span></span><br></pre></td></tr></table></figure>
<p>typedef关键字	类型重命名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 返回值类型 (*新类型名)(参数类型<span class="number">1</span>, 参数类型<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 用typedef定义函数指针类型别名CalcFunc</span></span><br><span class="line"><span class="comment">//   （代表&quot;返回int、接收两个int参数&quot;的函数指针类型）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CalcFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 普通函数（与CalcFunc类型匹配）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 3. 用别名CalcFunc直接声明函数指针变量（简洁！）</span></span><br><span class="line">    CalcFunc p_add = add;  <span class="comment">// 指向add函数</span></span><br><span class="line">    CalcFunc p_sub = sub;  <span class="comment">// 指向sub函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3+5=%d\n&quot;</span>, p_add(<span class="number">3</span>, <span class="number">5</span>));  <span class="comment">// 输出：8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7-2=%d\n&quot;</span>, p_sub(<span class="number">7</span>, <span class="number">2</span>));  <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用typedef定义比较函数的指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CompareFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序函数：参数直接使用类型别名CompareFunc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len, CompareFunc compare)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(arr[j], arr[j+<span class="number">1</span>])) &#123;  <span class="comment">// 调用回调函数</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的比较函数（与CompareFunc类型匹配）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">asc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;  <span class="comment">// 升序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">desc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a &lt; b; &#125; <span class="comment">// 降序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    sort(arr, len, asc);  <span class="comment">// 传入升序比较函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;升序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);  <span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">    sort(arr, len, desc); <span class="comment">// 传入降序比较函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n降序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);  <span class="comment">// 4 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-动态内存">10.动态内存</h3>
<p><strong>1.内存栈区</strong>：由系统管理：作用域结束内存被系统回收，函数内的<strong>非静态局部变量****和</strong>函数有关的局部信息**</p>
<p>内存开辟方向：==高地址==向==低地址==进行存放	eg：main：int a=1;intb=2;<strong>&amp;a高于&amp;b</strong>，<strong>windows默认大小1M</strong></p>
<p>可静态分配也可动态分配（alloca）函数但不需要free释放。栈分配效率高。</p>
<p>数组在内存中由<strong>低地址向高地址</strong>存放</p>
<p>分配后系统响应：只要栈剩余空间大于申请空间则分配成功，否则栈溢出。并且栈不会出现碎片问题</p>
<p><strong>2.内存堆区</strong>：由程序员控制，使用方便但易产生内存写漏，堆一般存储生命周期与函数调用无关的数据，具体内容由程序员决定，堆通常在头部用一个字节存放其大小。内存开辟方向：==低地址==向==高地址==存放	堆的大小取决于计算机有效的虚拟内存，32位linux系统堆内存可达2.9G，windows一般在1.5~1.9G之间。堆内存必须动态分配且需要手动释放。堆由函数库提供，机制复杂效率低。操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。大多数系统会在该内存空间首地上处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</p>
<p>需要引入头文件**&lt;stdlib.h&gt;**</p>
<p><strong>3.malloc申请	一个参数</strong>，申请内存无初始值</p>
<p><strong>功能</strong>：从堆区分配一块 <strong>连续的、大小为<code>size</code>字节</strong> 的内存块。<br>
<strong>特点</strong>：</p>
<ul>
<li>分配的内存 <strong>未初始化</strong>，内容是随机的（原内存区域的残留数据）。</li>
<li>只需要一个参数：待分配的总字节数（<code>size</code>）。</li>
</ul>
<p>4.calloc申请		两个参数，申请内存被初始化位0</p>
<p><strong>功能</strong>：为 <code>n</code> 个大小为 <code>size</code> 字节的元素分配内存（总大小：<code>n * size</code>），并将所有字节 <strong>初始化为 0</strong>。<br>
<strong>特点</strong>：</p>
<ul>
<li>内存会被自动初始化为 0（适合需要初始值为 0 的场景，如数组）。</li>
<li>需要两个参数：元素个数 <code>n</code> 和每个元素的大小 <code>size</code>（更直观地为数组分配内存）。</li>
</ul>
<p>5.realloc扩容</p>
<p>realloc函数返回的是函数扩容后新的内存起点</p>
<p><strong>功能</strong>：修改已通过<code>malloc</code>/<code>calloc</code>/<code>realloc</code>分配的内存块的大小（扩大或缩小）。<br>
<strong>特点</strong>：</p>
<ul>
<li>第一个参数<code>ptr</code>必须是之前通过<code>malloc</code>/<code>calloc</code>/<code>realloc</code>分配的指针（或<code>NULL</code>）。</li>
<li>若<code>ptr</code>为<code>NULL</code>，则<code>realloc(NULL, new_size)</code> 等价于 <code>malloc(new_size)</code>。</li>
<li>调整后会尽可能保留原内存中的数据（缩小内存时，超出部分的数据会丢失）。</li>
<li>若原内存块附近有足够空间，会直接在原位置扩展；否则会分配新内存块，复制原数据，释放旧块，并返回新指针。</li>
</ul>
<p><strong>realloc函数使用原理</strong></p>
<p><strong>①原内存空间后有足够的空间</strong></p>
<p>此时返回地址不变，原内存空间像内存高地址扩容</p>
<p><strong>②原内存空间后没有足够的空间</strong></p>
<p>此时返回<strong>新地址</strong>，在realloc函数内将原内存空间的数据拷贝到新开辟的内存空间中，相当于malloc新空间后再使用循环复制数据，后在realloc函数内自动释放原内存。</p>
<p><strong>③扩容失败</strong></p>
<p>返回NULL需根据情况看是否释放原内存，此时原地址任然存在并可用。</p>
<p><strong>注意：</strong>==在使用内存操作函数时最后必须free申请的内存防止内存泄漏。==</p>
<p>==注意==realloc函数在使用时由于不知道那种情况因此在判断扩容是否成功后<strong>使用中间变量接受新指针</strong>，避免原指针被污染，最初malloc开设的动态内存由自己决定要不要释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BankCards* q = (BankCards*)<span class="built_in">realloc</span>(BankS-&gt;pcards, <span class="number">2</span> * (cardnum * <span class="keyword">sizeof</span>(BankCards)));</span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;内存不足扩容失败\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">BankS-&gt;pcards = q;</span><br><span class="line">q = <span class="literal">NULL</span>;<span class="comment">//要在释放或使用后将其置空预防野指针</span></span><br></pre></td></tr></table></figure>
<p>在释放该空间后要将该指针赋值为空p=NULL避免</p>
<p><strong>6.free出现奔溃的原因</strong></p>
<p>①对同一份内存多次释放，因此在释放完内存后要将指针置空。</p>
<p>②释放的时是非堆区空间。</p>
<p>③free的不是堆区空间起始地址</p>
<p>④释放部分动态分配的内存</p>
<p>⑤内存访问越界</p>
<p>⑥未初始化指针，野指针不能free</p>
<p><strong>7.free如何知道释放内存大小的</strong></p>
<p>在动态申请内存后在返回你的指针地址的前几个字节会有<strong>指针头</strong>指针头内记录了该内存空间的大小（size），和校验码（magic）</p>
<p><strong>第二点堆区申请内存会在返回地址的前几个字节（指针头）存储该内存的size大小和magic校验码</strong></p>
<p><strong>动态申请的时候申请了两部分在返回指针前面为指针头后面为申请的空间</strong></p>
<h3 id="11-相同字符串常量在内存中只有一份">11.相同字符串常量在内存中只有一份</h3>
<p>字符串常量存储在内存的只读区域中</p>
<p>数据区存储字符串不可修改只可读</p>
<h3 id="12-结构体类型">12.结构体类型</h3>
<p>1.设计：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>;</span><br><span class="line">    数据类型 成员<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ... 更多成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方式1：顺序初始化（按成员定义顺序赋值）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">95.5</span>&#125;;<span class="comment">//①定义时直接赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2：指定成员初始化（不依赖顺序，更灵活）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu2</span> =</span> &#123;</span><br><span class="line">        .name = <span class="string">&quot;Bob&quot;</span>,	<span class="comment">//②通过访问结构体里的成员逐个赋值</span></span><br><span class="line">        .id = <span class="number">1002</span>,</span><br><span class="line">        .score = <span class="number">88.0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//方式3：strcpy（）函数/memcpy函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.访问通过==.==访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上面的示例</span></span><br><span class="line"><span class="comment">// 访问stu1的成员并修改</span></span><br><span class="line">stu1.score = <span class="number">96.0</span>;  <span class="comment">// 修改成绩</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号：%d，姓名：%s，成绩：%.1f\n&quot;</span>, </span><br><span class="line">       stu1.id, stu1.name, stu1.score);  <span class="comment">// 输出：1001 Alice 96.0</span></span><br></pre></td></tr></table></figure>
<p>4.结构体的嵌套</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义&quot;地址&quot;结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Address</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> city[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> street[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义&quot;学生&quot;结构体（嵌套Address）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Address</span> <span class="title">addr</span>;</span>  <span class="comment">// 嵌套结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化嵌套结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">        .id = <span class="number">1001</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .addr = &#123;.city = <span class="string">&quot;Beijing&quot;</span>, .street = <span class="string">&quot;Main St&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问嵌套结构体的成员（多级.运算符）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生地址：%s，%s\n&quot;</span>, stu.addr.city, stu.addr.street);</span><br><span class="line">    <span class="comment">// 输出：Beijing，Main St</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.typedef重命名结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuSystem</span> &#123;</span></span><br><span class="line">	student stus[studentcount];</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;stuSystem;</span><br></pre></td></tr></table></figure>
<p>6.结构体与数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> studentcount 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">address</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> province[SIZE];</span><br><span class="line">	<span class="type">char</span> city[SIZE];</span><br><span class="line">	<span class="type">char</span> county[SIZE];</span><br><span class="line">&#125;addres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> studentnum;</span><br><span class="line">	<span class="type">int</span> password;</span><br><span class="line">	address daaress1;</span><br><span class="line">&#125;student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuSystem</span> &#123;</span></span><br><span class="line">	student stus[studentcount];</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;stuSystem;</span><br><span class="line">stuSystem* <span class="title function_">InitList</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	stuSystem* syu1 = (stuSystem*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuSystem));</span><br><span class="line">	<span class="keyword">if</span> (syu1 == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	syu1-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> syu1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有一个stuSystem结构体此结构体中又包含10个student结构体，访问每个学生	**syu1-&gt;stus[i]**可以通过下标访问，也可以通过指针取地址进行指针访问</p>
<p>7.结构体与指针</p>
<p>①通过对指针解引用点访问元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（*syu1).stus[i];</span><br></pre></td></tr></table></figure>
<p>②通过结构体指针专门运算符访问		<strong>-&gt;</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syu1-&gt;stus[size].daaress1.province</span><br></pre></td></tr></table></figure>
<h3 id="13-与字符串有关的函数">13.与字符串有关的函数</h3>
<ol>
<li>
<h4 id="求字符串长度：strlen"><strong>求字符串长度：strlen</strong></h4>
</li>
</ol>
<ul>
<li>功能：计算字符串中有效字符的长度（不包含结尾的 <code>'\0'</code>）。</li>
<li>原型：<code>size_t strlen(const char *s);</code></li>
<li>参数：<code>s</code> 为字符串首地址。</li>
<li>返回值：字符串的长度（<code>size_t</code> 类型，无符号整数）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度：%zu\n&quot;</span>, <span class="built_in">strlen</span>(str)); <span class="comment">// 输出 5（&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;共5个字符）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-字符串复制：strcpy-与-strncpy"><strong>2.字符串复制：<code>strcpy</code> 与 <code>strncpy</code></strong></h4>
<ul>
<li><strong><code>strcpy</code></strong>：无长度限制的字符串复制（存在缓冲区溢出风险）。
<ul>
<li>原型：<code>char *strcpy(char *dest, const char *src);</code></li>
<li>功能：将 <code>src</code> 指向的字符串（包含 <code>'\0'</code>）复制到 <code>dest</code> 指向的内存。</li>
<li>注意：需保证 <code>dest</code> 缓冲区足够大，否则会溢出。</li>
</ul>
</li>
<li><strong><code>strncpy</code></strong>：带长度限制的字符串复制（更安全）。
<ul>
<li>原型：<code>char *strncpy(char *dest, const char *src, size_t n);</code></li>
<li>功能：最多复制 <code>n</code> 个字符从 <code>src</code> 到 <code>dest</code>。</li>
<li>注意：若 <code>src</code> 长度超过 <code>n</code>，则不会自动添加 <code>'\0'</code>；若不足 <code>n</code>，则剩余部分用 <code>'\0'</code> 填充。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(dest, src); <span class="comment">// 复制整个src到dest（需保证dest足够大）</span></span><br><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="number">5</span>); <span class="comment">// 复制前5个字符（&quot;hello&quot;），若src更长则不补&#x27;\0&#x27;</span></span><br><span class="line">dest[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动补终止符（推荐）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-strcat-与-strncat"><strong>3.<code>strcat</code> 与 <code>strncat</code></strong></h4>
<ul>
<li>
<p><strong><code>strcat</code></strong>：无长度限制的字符串拼接（风险同 <code>strcpy</code>）。</p>
<ul>
<li>原型：<code>char *strcat(char *dest, const char *src);</code></li>
<li>功能：将 <code>src</code> 字符串追加到 <code>dest</code> 字符串末尾（覆盖 <code>dest</code> 原有的 <code>'\0'</code>，并在新末尾加 <code>'\0'</code>）。</li>
</ul>
</li>
<li>
<p><strong><code>strncat</code></strong>：带长度限制的拼接。</p>
<ul>
<li>原型：<code>char *strncat(char *dest, const char *src, size_t n);</code></li>
</ul>
</li>
<li>
<p>功能：最多追加 <code>n</code> 个字符从 <code>src</code> 到 <code>dest</code>，并自动添加 <code>'\0'</code>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot; world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(dest, src); <span class="comment">// dest 变为 &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">strncat</span>(dest, src, <span class="number">3</span>); <span class="comment">// 追加前3个字符，dest 变为 &quot;hellowor&quot;（假设初始为&quot;hello&quot;）</span></span><br></pre></td></tr></table></figure>
<h4 id="4-字符串比较：strcmp-与-strncmp">4. 字符串比较：<code>strcmp</code> 与 <code>strncmp</code></h4>
<ul>
<li><strong><code>strcmp</code></strong>：比较两个字符串的全部字符。
<ul>
<li>原型：<code>int strcmp(const char *s1, const char *s2);</code></li>
<li>返回值：
<ul>
<li>若 <code>s1 &gt; s2</code>（按 ASCII 值），返回正数；</li>
<li>若 <code>s1 == s2</code>，返回 0；</li>
<li>若 <code>s1 &lt; s2</code>，返回负数。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>strncmp</code></strong>：比较前 <code>n</code> 个字符。
<ul>
<li>原型：<code>int strncmp(const char *s1, const char *s2, size_t n);</code></li>
<li>功能：仅比较前 <code>n</code> 个字符，结果规则同 <code>strcmp</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>)); <span class="comment">// 负数（&#x27;a&#x27; &lt; &#x27;b&#x27;）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strncmp</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="number">3</span>)); <span class="comment">// 0（前3个字符相同）</span></span><br></pre></td></tr></table></figure>
<h4 id="5-查找字符-子串：strchr、strrchr、strstr"><strong>5.查找字符 / 子串：<code>strchr</code>、<code>strrchr</code>、<code>strstr</code></strong></h4>
<p><strong><code>strchr</code></strong>：查找字符在字符串中第一次出现的位置。</p>
<p>原型：<code>char *strchr(const char *s, int c);</code></p>
<p>返回值：找到则返回该字符地址，否则返回 <code>NULL</code>。</p>
<p><strong><code>strrchr</code></strong>：查找字符最后一次出现的位置。</p>
<p>原型：<code>char *strrchr(const char *s, int c);</code></p>
<p><strong>strstr`</strong>：查找子串在字符串中第一次出现的位置。</p>
<p>原型：<code>char *strstr(const char *haystack, const char *needle);</code></p>
<p>返回值：找到则返回子串首地址，否则返回 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">strchr</span>(str, <span class="string">&#x27;l&#x27;</span>); <span class="comment">// 返回第3个字符（&#x27;l&#x27;）的地址（索引2）</span></span><br><span class="line"><span class="built_in">strrchr</span>(str, <span class="string">&#x27;l&#x27;</span>); <span class="comment">// 返回最后一个&#x27;l&#x27;的地址（索引9）</span></span><br><span class="line"><span class="built_in">strstr</span>(str, <span class="string">&quot;wor&quot;</span>); <span class="comment">// 返回&quot;wor&quot;首地址（索引6）</span></span><br></pre></td></tr></table></figure>
<h4 id="6-isdigit©判断该字符是不是数字字符-ctype-h头文件中">6.isdigit©	判断该字符是不是数字字符	<a target="_blank" rel="noopener" href="//ctype.xn--h-lq6a0yx14azpp">//ctype.h头文件中</a></h4>
<p>isblank©	 判断该字符是不是空格</p>
<p>isalpha©	 判断该字符是不是字母</p>
<h4 id="7-strtok函数">7.strtok函数</h4>
<p>在 C 语言中，<code>strtok</code>函数用于将字符串按照指定的分隔符分割成一系列子串（称为 “标记”），定义在头文件 <code>&lt;string.h&gt;</code> 中。它是字符串处理中常用的工具函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;apple,banana;orange grape&quot;</span>;  <span class="comment">// 注意：必须是可修改的数组（不能是常量字符串）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> delim[] = <span class="string">&quot;,; &quot;</span>;  <span class="comment">// 分隔符集合：逗号、分号、空格</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次调用：传入原始字符串</span></span><br><span class="line">    <span class="type">char</span> *token = strtok(str, delim);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环获取所有标记</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到标记：%s\n&quot;</span>, token);</span><br><span class="line">        <span class="comment">// 后续调用：传入NULL，继续分割</span></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">找到标记：apple</span><br><span class="line">找到标记：banana</span><br><span class="line">找到标记：orange</span><br><span class="line">找到标记：grape</span><br></pre></td></tr></table></figure>
<h3 id="14-内存操作函数">14.内存操作函数</h3>
<h4 id="1-内存复制：memcpy-与-memmove"><strong>1.内存复制：<code>memcpy</code> 与 <code>memmove</code></strong></h4>
<ul>
<li>
<p><strong><code>memcpy</code></strong>：复制内存块（不处理重叠内存）。</p>
<ul>
<li>原型：<code>void *memcpy(void *dest, const void *src, size_t n);</code></li>
<li>功能：从 <code>src</code> 复制 <code>n</code> 个字节到 <code>dest</code>。</li>
<li>注意：若 <code>src</code> 和 <code>dest</code> 内存重叠，结果未定义。</li>
</ul>
</li>
<li>
<p><strong><code>memmove</code></strong>：复制内存块（处理重叠内存，更安全）。</p>
<ul>
<li>原型：<code>void *memmove(void *dest, const void *src, size_t n);</code></li>
<li>功能：同 <code>memcpy</code>，但通过临时缓冲区处理重叠内存，结果可靠。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(arr2, arr1, <span class="keyword">sizeof</span>(arr1)); <span class="comment">// 复制整个arr1到arr2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理重叠内存（如将arr1[0..2]复制到arr1[1..3]）</span></span><br><span class="line">memmove(arr1 + <span class="number">1</span>, arr1, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 安全，结果为&#123;1,1,2,3,5&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-内存设置：memset">2. 内存设置：<code>memset</code></h4>
<ul>
<li>功能：将内存块的前 <code>n</code> 个字节设置为指定值。</li>
<li>原型：<code>void *memset(void *s, int c, size_t n);</code></li>
<li>参数：<code>s</code> 为内存首地址，<code>c</code> 为要设置的字节值（通常用 ASCII 码），<code>n</code> 为字节数。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>); <span class="comment">// 前5个字节设为&#x27;a&#x27;，结果：&quot;aaaaa????&quot;（?为未初始化值）</span></span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str)); <span class="comment">// 清零整个数组（常用初始化方式）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-内存比较：memcmp">3. 内存比较：<code>memcmp</code></h4>
<ul>
<li>功能：比较两个内存块的前 <code>n</code> 个字节。</li>
<li>原型：<code>int memcmp(const void *s1, const void *s2, size_t n);</code></li>
<li>返回值：同 <code>strcmp</code>（按字节 ASCII 值比较）。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">memcmp</span>(a, b, <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 比较前2个整数（4字节/个，共8字节），返回负数（2 &lt; 4）</span></span><br></pre></td></tr></table></figure>
<h3 id="15-assert">15.assert</h3>
<p><strong>此为断言函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(syu1 != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>当 <code>assert(表达式)</code> 中的<strong>表达式结果为假（0）*<em>时，程序会*<em>终止运行</em></em>，并输出包含</strong>断言失败的表达式、所在文件名、行号**的错误信息；若表达式为真，<code>assert</code> 无任何操作，程序继续执行。</p>
<p><strong>关键特性</strong></p>
<ol>
<li><strong>仅调试模式生效</strong></li>
</ol>
<p><code>assert</code> 依赖宏 <code>NDEBUG</code>（Release 模式下通常会定义 <code>NDEBUG</code>）。若 <code>NDEBUG</code> 已定义，<code>assert</code> 会被编译器<strong>完全优化掉</strong>（无任何运行时开销）。</p>
<ul>
<li>调试模式（Debug）：<code>assert</code> 生效，用于捕捉错误。</li>
<li>发布模式（Release）：<code>assert</code> 失效，需通过其他方式（如 <code>if-else</code>）处理运行时错误</li>
</ul>
<p>2.<strong>错误信息明确</strong></p>
<p>断言失败时，程序会输出类似以下的信息（格式因编译器 / 系统而异）：</p>
<p>直接定位到<strong>失败的表达式、代码文件、行号</strong>，便于快速调试。</p>
<h3 id="16-联合体">16.联合体</h3>
<p>1.联合体</p>
<p>union	联合体名{</p>
<p>}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> stu_id;	<span class="comment">//4B</span></span><br><span class="line">	<span class="type">int</span> tea_id; <span class="comment">//4B	</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.联合体和结构体的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">结构体（struct)</th>
<th style="text-align:center">联合体（union)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存分配</td>
<td style="text-align:center">各成员独立占用内存，总大小 ≥ 成员大小之和</td>
<td style="text-align:center">所有成员共享内存，总大小 = 最大成员大小</td>
</tr>
<tr>
<td style="text-align:center">成员有效性</td>
<td style="text-align:center">所有成员可同时有效</td>
<td style="text-align:center">同一时间只有一个成员有效</td>
</tr>
<tr>
<td style="text-align:center">用途</td>
<td style="text-align:center">组合关联数据（如学生信息）</td>
<td style="text-align:center">节省内存或访问同内存的不同表示</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> student_id;	<span class="comment">//4B</span></span><br><span class="line">	<span class="type">int</span> class_id;	<span class="comment">//4B</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中每个元素是单独存在的属性相互独立，student 结构体占8B。</p>
<p>而stu联合体只占4B，<strong>两个变量共享一块内存空间</strong>，使用联合体定义变量其内存空间取决于其联合体内元素<strong>最大值</strong>。</p>
<p><strong>每次只能使用其中一个变量</strong>，<strong>每次只能访问一个成员，当修改一个成员的值，其他成员的值也会被覆盖。</strong></p>
<p>联合体的初始化只能对其中第一个成员初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">stu</span> <span class="title">stu</span>=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这只能将stu_id初始化为10；</p>
<p>3.<strong>大小端问题</strong>（计算机中数据存储的两种方式，主要区别是数据的字节序-&gt;<strong>字节在内存中存储的顺序</strong>）</p>
<p>大端模式	高位字节	 数据	 位于内存<strong>低地址</strong></p>
<p>小端模式	 高位字节	 数据	位于内存<strong>高地址</strong></p>
<p>0x1234中        0x34是数据的低位字节，0x12是数据的高位字节对数据贡献最大</p>
<p><strong>验证大小端问题用联合体验证</strong> 	因为<strong>两个变量共享一块内存空间</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">	<span class="type">short</span> stu_id;	<span class="comment">//4B</span></span><br><span class="line">	<span class="type">char</span> tea_id[<span class="number">2</span>]; <span class="comment">//4B	</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">stu</span> <span class="title">my</span>;</span></span><br><span class="line">	my.stu_id = <span class="number">0x1234</span>;</span><br><span class="line">	<span class="keyword">if</span> (my.tea_id[<span class="number">0</span>] == <span class="number">0x34</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;小端模式&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;大端模式&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>windows系统中运行结果为小端模式</strong></p>
<h3 id="17-枚举（enum）">17.枚举（enum）</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名 &#123;</span></span><br><span class="line">    枚举常量<span class="number">1</span>,</span><br><span class="line">    枚举常量<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// ... 更多枚举常量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>枚举名</strong>：自定义名称（如<code>Weekday</code>、<code>Color</code>），用于标识枚举类型。</p>
<p><strong>枚举常量</strong>：枚举中的成员，本质是整数常量（默认从<code>0</code>开始递增），可手动指定值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义&quot;星期&quot;枚举，包含7个常量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> &#123;</span></span><br><span class="line">    Monday,    <span class="comment">// 默认值0</span></span><br><span class="line">    Tuesday,   <span class="comment">// 默认值1</span></span><br><span class="line">    Wednesday, <span class="comment">// 默认值2</span></span><br><span class="line">    Thursday,  <span class="comment">// 默认值3</span></span><br><span class="line">    Friday,    <span class="comment">// 默认值4</span></span><br><span class="line">    Saturday,  <span class="comment">// 默认值5</span></span><br><span class="line">    Sunday     <span class="comment">// 默认值6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举常量（如<code>Monday</code>）本质是整数，默认从<code>0</code>开始，依次递增<code>1</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义&quot;颜色&quot;枚举，手动指定部分值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">    RED = <span class="number">10</span>,   <span class="comment">// 手动指定为10</span></span><br><span class="line">    GREEN,      <span class="comment">// 自动为11（前一个+1）</span></span><br><span class="line">    BLUE = <span class="number">20</span>,  <span class="comment">// 手动指定为20</span></span><br><span class="line">    YELLOW      <span class="comment">// 自动为21（前一个+1）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以手动为枚举常量指定值，未指定的会在前一个基础上递增<code>1</code>：</p>
<p>允许值重复（如<code>RED = 5, GREEN = 5</code>是合法的，但不推荐，易混淆）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：定义枚举后单独声明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">day1</span>, <span class="title">day2</span>;</span>  <span class="comment">// day1和day2是Weekday类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：定义枚举时直接声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125; c1, c2;  <span class="comment">// c1、c2是Color类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：结合typedef定义别名（推荐，简化书写）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SUCCESS,  <span class="comment">// 0：成功</span></span><br><span class="line">    ERROR,    <span class="comment">// 1：错误</span></span><br><span class="line">    TIMEOUT   <span class="comment">// 2：超时</span></span><br><span class="line">&#125; Status;  <span class="comment">// 别名为Status</span></span><br><span class="line"></span><br><span class="line">Status s;  <span class="comment">// 直接用别名声明变量，无需写enum</span></span><br></pre></td></tr></table></figure>
<p><strong>三种定义方式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：定义枚举后单独声明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">day1</span>, <span class="title">day2</span>;</span>  <span class="comment">// day1和day2是Weekday类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：定义枚举时直接声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125; c1, c2;  <span class="comment">// c1、c2是Color类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：结合typedef定义别名（推荐，简化书写）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SUCCESS,  <span class="comment">// 0：成功</span></span><br><span class="line">    ERROR,    <span class="comment">// 1：错误</span></span><br><span class="line">    TIMEOUT   <span class="comment">// 2：超时</span></span><br><span class="line">&#125; Status;  <span class="comment">// 别名为Status</span></span><br><span class="line"></span><br><span class="line">Status s;  <span class="comment">// 直接用别名声明变量，无需写enum</span></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> &#123;</span></span><br><span class="line">    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">today</span> =</span> Monday;  <span class="comment">// 赋值：today为0（Monday的值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较操作</span></span><br><span class="line">    <span class="keyword">if</span> (today == Monday) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;今天是周一\n&quot;</span>);  <span class="comment">// 输出：今天是周一</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运算操作（本质是整数）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">tomorrow</span> =</span> today + <span class="number">1</span>;  <span class="comment">// tomorrow为1（Tuesday）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;明天是周%d\n&quot;</span>, tomorrow + <span class="number">1</span>);  <span class="comment">// 输出：明天是周2（注意+1是因为枚举从0开始）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-内存区域">18.内存区域</h3>
<p>根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分为以下4个部分:</p>
<p>①<strong>代码区</strong>:这个区域存储着被装入执行的二进制机器代码，处理器(CUP)会到这个区域取指并执行</p>
<p>②<strong>数据区</strong>:用于存储全局变量，静态全局变量，静态局部变量，字符串常量等。</p>
<p>③<strong>堆区</strong>:进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。</p>
<p>④<strong>栈区</strong>:函数被调时分配栈区，用于存放函数的参数值，局部变量等值;还要动态地存储函数之间的关系，以保证被调用函数在返回时恢复到被调用函数中继续执行。</p>
<h3 id="19-变量类型">19.变量类型</h3>
<p><strong>全局变量在函数外声明，局部变量在函数内声明</strong></p>
<p>结构体只有在定义变量赋值时才占用内存空间</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用域</th>
<th>生命周期</th>
<th>存储位置</th>
<th>初始化默认值</th>
<th>跨文件访问（链接属性）</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量</td>
<td>函数 / 复合语句内</td>
<td>函数调用期间</td>
<td>栈区</td>
<td>随机值</td>
<td>否</td>
</tr>
<tr>
<td>全局变量</td>
<td>从声明处到整个文件（可跨文件）</td>
<td>程序运行期间</td>
<td>数据区</td>
<td>0</td>
<td>可（extern）</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>从声明处到当前文件</td>
<td>程序运行期间</td>
<td>数据区</td>
<td>0</td>
<td>否</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>函数内</td>
<td>程序运行期间</td>
<td>数据区</td>
<td>0</td>
<td>否</td>
</tr>
<tr>
<td>字符串常量</td>
<td>整个程序（通过指针访问）</td>
<td>程序运行期间</td>
<td>只读数据区</td>
<td>无（固定值）</td>
<td>否（只读）</td>
</tr>
</tbody>
</table>
<h3 id="20-函数">20.函数</h3>
<p>1.调用机制</p>
<p>局部变量占用的内存空间在程序指向过程中“动态”建立和释放。这种“动态”是通过栈由系统自动管理进行。</p>
<p>当调用一个函数时</p>
<p>①建立栈帧空间</p>
<p>②主函数运行状态和返回地址入栈</p>
<p>③进行实参和形参的结合，同时形参获得存储空间，接着给局部变量分配空间</p>
<p>④执行被调函数体</p>
<p>⑤被调函数执行完成，释放被调函数中局部变量占用的栈空间		<strong>//由寄存器传递值</strong></p>
<p>⑥取主函数运行状态及返回地址，释放栈帧空间</p>
<p>⑦继续主函数后续语句</p>
<p>2.作用域</p>
<p>3.定义</p>
<p>返回值	函数名(形参列表){</p>
<p>}</p>
<p>4.使用之前需要定义或者声明函数</p>
<p>返回值类型 a=函数名（实参列表）</p>
<p>5.<strong>extern</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;		<span class="comment">//在项目其他文件中定义过a；</span></span><br><span class="line">a=<span class="number">10</span>;		<span class="comment">//相当于链接操作</span></span><br></pre></td></tr></table></figure>
<p>对于函数来说</p>
<p>a.cpp定义过fun函数</p>
<p>b.cpp要用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> fun（）；<span class="comment">//函数声明</span></span><br><span class="line">fun（）；		<span class="comment">//函数调用</span></span><br></pre></td></tr></table></figure>
<p>6.形参改变要影响实参的值（传指针，解引用）</p>
<p>例：交换函数</p>
<p>①封装 形参改变，影响实参的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap(<span class="type">int</span> *a,<span class="type">int</span>*b)&#123;</span><br><span class="line"><span class="type">int</span> temp=*a;</span><br><span class="line">*a=*b;</span><br><span class="line">*b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap(<span class="type">int</span>*arr,<span class="type">int</span> index1,<span class="type">int</span> index2)&#123;</span><br><span class="line"> <span class="type">int</span> temp=arr[index1];</span><br><span class="line"> arr[index1]=arr[index2];</span><br><span class="line"> arr[index2]=temp;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②简单交换两数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位运算异或</span></span><br><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure>
<p>7.递归函数</p>
<p>①存在自己调用自己</p>
<p>②问题规模不断缩小</p>
<p>③函数必须有退出条件</p>
<p>特点</p>
<p><strong>逐层深入，依次返回</strong></p>
<p>缺点：空间耗费大，算法效率低，同一个子问题可能被重复多次运算，调用次数太多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求5的阶乘</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> jc(n - <span class="number">1</span>)* n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归其实就是函数调用的过程</strong>   <strong>本质就是问题的分解</strong></p>
<p><strong>要写出递归算法先得分解子问题，找终止条件</strong></p>
<p>两种思维模式</p>
<p>①<strong>遍历的思维</strong>（穷举）</p>
<p>②<strong>分治策略</strong>（分解子问题的思维—–一般来说有返回值</p>
<p>分治策略:是将规模比较大的问题可分割成规模较小的相同问题，问题不变，规模变小。这自然导致递归过程的产生。分治与递归像一对李生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<p><strong>分治法所能解决的问题一般具有以下四个特征:</strong></p>
<p>①该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>②该问题可以分解为若干个规模较小的相同问题,</p>
<p>③使用小规模的解,可以合并成，该问题原规模的解。</p>
<p>④该问题所分解出的各个子规模是相互独立的。</p>
<p><strong>分治法步骤: 在分治策略中递归地求解一个问题，在每层递归中应用如下三个步骤:</strong></p>
<p>①分解:将问题划分成一些子问题，子问题的形式与原问题一样，只是规模更小。</p>
<p>②解决:递归地求解子问题，如果子问题的规模足够小，则停止递归，直接求解</p>
<p>③合井:将小规模的解组合成原规模问题的解，</p>
<p><strong>7.</strong>  <strong>二分查找</strong>（递归和非递归）前提数组有序		********</p>
<p>非递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归的二分查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">twofensearch</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> len,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">	assert(arr != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> right=len<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (target == arr[left+(right-left) / <span class="number">2</span> ])</span><br><span class="line">			<span class="keyword">return</span> left + (right-left) / <span class="number">2</span> ;					     <span class="comment">//二分查找非递归方式</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target&lt; arr[left + (right - left) / <span class="number">2</span> ]) &#123;			<span class="comment">//思路：通过左右两指针和中间值与目标值的比较																		不断缩小搜素范围</span></span><br><span class="line">			right = left + (right - left) / <span class="number">2</span><span class="number">-1</span> ;					<span class="comment">//中间值为arr[left + (right - left) / 																									2 ]</span></span><br><span class="line">		&#125;															<span class="comment">//在比较后重新更新左右边界（排除比较过的中间																									元素）</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[left + (right - left) / <span class="number">2</span>]) &#123;			<span class="comment">//到最后左右边界相等时比较的中间元素即为最后																	的元素，若不相等，left&gt;right跳出循环返回-1</span></span><br><span class="line">			left = left + (right - left) / <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">twofensearch0</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len, <span class="type">int</span> target, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (target == arr[mid]) &#123;</span><br><span class="line">		<span class="keyword">return</span> mid;						<span class="comment">//递归的解法就是函数不断被调用，通过每次不同情况下不断跟新函数左右边界不断缩小范围，最终返回值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (target &gt;= arr[mid]) &#123;</span><br><span class="line">		<span class="type">int</span> index = twofensearch0(arr, len, target, mid+<span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> index = twofensearch0(arr, len, target, left, mid+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.log2n的算法效率问题</p>
<h3 id="21-文件操作">21.文件操作</h3>
<p><strong>绝对路径：</strong> D:/temp/1.txt（全路径）,从根目录开始</p>
<p>相对路径：大纲下的体系		从该项目下路径开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* path1 = <span class="string">&quot;D:/temp/1.txt&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* path2 = <span class="string">&quot;D:\\temp\\1.txt&quot;</span>;	<span class="comment">//&quot;\&quot;在c语言中是转义字符要“\\”</span></span><br></pre></td></tr></table></figure>
<p><strong>1.什么是文件（路径，文件名，后缀）</strong></p>
<p>“文件”指存储在外部介质上数据的集合</p>
<p>一批数据是以文伴的形式存放在外部介质上的</p>
<p>操作系统是以文件为单位对数据进行管理</p>
<p>想找存放在外部介质上的数据，先按文件名找到所指定的文件，然后再从该文件读数据</p>
<p>要向外部介质上存储数据也必须先建立一个文件(以文件名作为标志)，才能向它输出数据</p>
<p><strong>2.数据流	源-&gt;目的端</strong></p>
<p>终端键盘    输入文件</p>
<p>显示屏打印机   输出文件</p>
<p>外存—–&gt;内存	输入流</p>
<p>内存——&gt;外存（文件）      输出流</p>
<p><strong>3.文件的分类</strong></p>
<p>①根据数据组织形式</p>
<p>Ⅰ.ASCII文件（文本文件）字符转化为相应ASCII码以二进制在内存中存储，每一个字节放一个字符的ASCII码，</p>
<p>如果要求在外存上以ASCII码形式存储，则需要在存储前转化。</p>
<p>Ⅱ.二进制文件（多媒体文件）	数据在内存中以二进制存储，不加转换的输出到外存就是二进制文件</p>
<p><strong>4.编码集</strong></p>
<p>GBK（中文）</p>
<p>ASCII字符集（1B)</p>
<p>unicode（2字节）（ASCII的扩展）</p>
<p><strong>5.文件缓冲区</strong>		<strong>刷新：flush	&lt;-&gt;	\n	&lt;-&gt;	程序终止         &lt;-&gt;       缓冲区已满</strong></p>
<p>磁盘—&gt;内存的（输入文件缓冲区）—-&gt;程序数据区</p>
<p>程序数据区—&gt;内存的（输出文件缓冲区）—-&gt;磁盘</p>
<p><strong>6.文件指针</strong></p>
<p>FILE（结构体）</p>
<p>定义一个FILE类型的指针指向文件，通过指针对被指向的文件进行操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* P1 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>7.打开和关闭文件</strong>（文本文件）</p>
<p><strong>一个文件唯一对应一个  文件描述符</strong>（整型值），打开文件会有资源消耗，因此打开一个文件不用要关闭</p>
<p>windows默认分配1024个文件描述符（可以修改）</p>
<p>对文件读写之前应该“打开”该文件，在使用结束之后应“关闭”该文件。</p>
<p>所谓“打开”是指为文件建立相应的信息区(用来存放有关文件的信息)和文件缓冲区(用来暂时存放输入输出的数据)</p>
<p>在编写程序时，在打开文件的同时，一般都指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的联系，这样就可以通过该指针变量对文件进行读写</p>
<p>所谓“关闭”是指撤销文件信息区和文件缓冲区</p>
<p>①打开	<strong>fopen函数</strong></p>
<p><strong>和文件权限有关系</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* P1 = <span class="literal">NULL</span>;</span><br><span class="line">P1=fopen(文件名，打开方式); 打开方式（“r”“w“”a“只读，只写，末尾只写）;</span><br></pre></td></tr></table></figure>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> char* path1 = <span class="string">&quot;1.txt&quot;</span>;   			 <span class="comment">//在这个项目路径下找1.txt   相对路径</span></span><br><span class="line"><span class="keyword">const</span> char* path2 = <span class="string">&quot;D:\\temp\\1.txt&quot;</span>;	 <span class="comment">//绝对路径</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE* P1 = <span class="literal">NULL</span>;</span><br><span class="line">FILE* P2 = <span class="literal">NULL</span>;</span><br><span class="line">P1=fopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   <span class="comment">//以可读方式打开该文件</span></span><br><span class="line">assert(P1!=<span class="literal">NULL</span>);</span><br><span class="line">P2=fopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);	  <span class="comment">//以可写方式打开该文件，看不见该文件内容</span></span><br></pre></td></tr></table></figure>
<p>如果打开失败返回的是NULL；</p>
<p><strong>一般使用相对路径，方便别人使用</strong></p>
<p>②关闭		<strong>fclose函数</strong></p>
<p><strong>关闭文件信息区及文件缓冲区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	FILE* P1 = <span class="literal">NULL</span>;</span><br><span class="line">	FILE* P2 = <span class="literal">NULL</span>;</span><br><span class="line">	P1 = fopen(<span class="string">&quot;FileName.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>);   <span class="comment">//以可读方式打开该文件</span></span><br><span class="line">	assert(P1 != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	fclose(P1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&quot;r&quot;</code></td>
<td style="text-align:center">只读</td>
<td style="text-align:center">文件必须存在，否则打开失败</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;w&quot;</code></td>
<td style="text-align:center">只写</td>
<td style="text-align:center">若文件存在，则清除原文件内容后写入；否则，创建新文件后写入</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;a&quot;</code></td>
<td style="text-align:center">末尾只写</td>
<td style="text-align:center">若文件存在，位置指针移到文件末尾并追加写入（不删除原数据）；若文件不存在，创建新文件后写入</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;r+&quot;</code></td>
<td style="text-align:center">读写</td>
<td style="text-align:center">文件必须存在，否则打开失败（在 <code>&quot;r&quot;</code> 基础上增加可写功能）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;w+&quot;</code></td>
<td style="text-align:center">读写</td>
<td style="text-align:center">创建新文件，先写入数据，后可读取（会清空已有文件内容）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;a+&quot;</code></td>
<td style="text-align:center">读写</td>
<td style="text-align:center">在 <code>&quot;a&quot;</code> 模式基础上增加可读功能（追加后可读取）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;rb&quot;</code></td>
<td style="text-align:center">二进制文件只读</td>
<td style="text-align:center">功能同 <code>&quot;r&quot;</code>，但以<strong>二进制模式</strong>打开（下同表示后续二进制模式规则类似）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;wb&quot;</code></td>
<td style="text-align:center">二进制文件只写</td>
<td style="text-align:center">功能同 <code>&quot;w&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;ab&quot;</code></td>
<td style="text-align:center">二进制文件末尾只写</td>
<td style="text-align:center">功能同 <code>&quot;a&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;rb+&quot;</code></td>
<td style="text-align:center">二进制文件读写</td>
<td style="text-align:center">功能同 <code>&quot;r+&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;wb+&quot;</code></td>
<td style="text-align:center">二进制文件读写</td>
<td style="text-align:center">功能同 <code>&quot;w+&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;ab+&quot;</code></td>
<td style="text-align:center">二进制文件读写</td>
<td style="text-align:center">功能同 <code>&quot;a+&quot;</code>，二进制模式</td>
</tr>
</tbody>
</table>
<p><strong>8.文件操作</strong>（顺序读写）</p>
<p>①文件读取	fread函数</p>
<p>返回值是成功读取的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void* ptr</code></td>
<td style="text-align:center">指向<strong>接收数据的缓冲区</strong>的指针（如数组、结构体、动态分配的内存等）。</td>
<td style="text-align:center">需确保缓冲区大小 ≥ <code>size * nmemb</code>，否则可能导致<strong>内存溢出</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t size</code></td>
<td style="text-align:center">单个数据项的<strong>字节大小</strong>（如 <code>sizeof(int)</code> 表示 1 个 <code>int</code> 的字节数）。</td>
<td style="text-align:center">常用 <code>sizeof</code> 计算，避免硬编码（增强可移植性）。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t nmemb</code></td>
<td style="text-align:center">要读取的<strong>数据项数量</strong>（如读 10 个 <code>int</code>，则 <code>nmemb=10</code>）。</td>
<td style="text-align:center">总读取字节数 = <code>size * nmemb</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的<strong>文件流指针</strong>（通过 <code>fopen</code> 获得，需以读模式打开，如 <code>&quot;rb&quot;</code>）。</td>
<td style="text-align:center">必须先成功打开文件，否则行为未定义；模式需匹配（二进制读用 <code>&quot;rb&quot;</code>）。</td>
</tr>
</tbody>
</table>
<p>②文件写入	fwrite函数</p>
<p>返回值是写入成功的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>const void* ptr</code></td>
<td style="text-align:center">指向<strong>要写入的数据</strong>的指针（如数组、结构体、字符串等）。</td>
<td style="text-align:center">数据需提前准备好（如初始化的数组、赋值后的结构体），<code>const</code> 表示不修改源数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t size</code></td>
<td style="text-align:center">单个数据项的<strong>字节大小</strong>（如 <code>sizeof(float)</code> 表示 1 个 <code>float</code> 的字节数）。</td>
<td style="text-align:center">推荐用 <code>sizeof</code> 计算（如 <code>sizeof(Student)</code>），避免硬编码，增强可移植性。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t nmemb</code></td>
<td style="text-align:center">要写入的<strong>数据项数量</strong>（如写 5 个结构体，<code>nmemb=5</code>）。</td>
<td style="text-align:center">总写入字节数 = <code>size * nmemb</code>（需确保文件有足够空间）。</td>
</tr>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的<strong>文件流指针</strong>（通过 <code>fopen</code> 获得，需以写模式打开，如 <code>&quot;wb&quot;</code>）。</td>
<td style="text-align:center">必须先成功打开文件（模式需匹配，如二进制写用 <code>&quot;wb&quot;</code>），否则行为未定义。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	FILE* P1 = <span class="literal">NULL</span>;			<span class="comment">//顺序读写数据</span></span><br><span class="line">	FILE* P2 = <span class="literal">NULL</span>;</span><br><span class="line">	P1 = fopen(<span class="string">&quot;FileName.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">//以可读方式打开该文件</span></span><br><span class="line">	P2 = fopen(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	assert(P1 != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">	<span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((num = fread(buff, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">256</span>, P1)) != <span class="number">0</span>) &#123;</span><br><span class="line">		fwrite(buff, <span class="keyword">sizeof</span>(<span class="type">char</span>), num, P2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">										<span class="comment">//关闭文件</span></span><br><span class="line">	fclose(P1);</span><br><span class="line">	fclose(P2);			<span class="comment">//文件拷贝</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>9.随机读写</strong></p>
<p>文件：文件头指针       文件尾指针</p>
<p>对文件进行顺序读写比较容易理解，也容易操作，但有时效率不高<br>
随机访问不是按数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数据进行访问</p>
<p><strong>通过fseek函数改变文件标记</strong></p>
<p>可以在任何位置读写数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">取值 / 注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的<strong>文件流指针</strong>（通过 <code>fopen</code> 获得，需支持随机访问）。</td>
<td style="text-align:center">必须是成功打开的文件（如 <code>&quot;rb&quot;</code>、<code>&quot;r+b&quot;</code> 模式，文本模式可能有兼容性问题）。</td>
</tr>
<tr>
<td style="text-align:center"><code>long offset</code></td>
<td style="text-align:center">偏移量（字节数），表示从 <code>whence</code> 位置移动的距离。</td>
<td style="text-align:center">正数：向文件末尾方向移动；负数：向文件开头方向移动。</td>
</tr>
<tr>
<td style="text-align:center"><code>int whence</code></td>
<td style="text-align:center">起始位置（基准点），即从哪里开始计算偏移量，需使用标准宏定义。</td>
<td style="text-align:center">有 3 个合法值： - <code>SEEK_SET</code>：从<strong>文件开头</strong>开始（值为 0）； - <code>SEEK_CUR</code>：从<strong>当前文件指针位置</strong>开始（值为 1）； - <code>SEEK_END</code>：从<strong>文件末尾</strong>开始（值为 2）。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">参照点</th>
<th style="text-align:center">名字</th>
<th style="text-align:center">用数字代表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件开始位置</td>
<td style="text-align:center"><code>SEEK_SET</code></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">文件当前位置</td>
<td style="text-align:center"><code>SEEK_CUR</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">文件末尾位置</td>
<td style="text-align:center"><code>SEEK_END</code></td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>用宏常量代替</p>
<p>先使用fseek函数调整写入（读取）指针位置在进行正常的读写操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 以&quot;读写二进制模式&quot;打开（允许读和写，且支持随机访问）</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;nums.bin&quot;</span>, <span class="string">&quot;r+b&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;文件打开失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到第10字节处（假设前10字节是无需修改的内容）</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(fp, <span class="number">10</span>, SEEK_SET) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fseek失败&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前位置写入新数据（覆盖原有内容）</span></span><br><span class="line">    <span class="type">int</span> new_data = <span class="number">999</span>;</span><br><span class="line">    fwrite(&amp;new_data, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;修改成功\n&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ftell函数</strong>	文件位置标记及其定位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的文件流指针</td>
<td style="text-align:center">必须是有效且已打开的文件流</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>long</code>返回值</td>
<td style="text-align:center">成功：返回当前指针的偏移字节数（≥0）； 失败：返回 <code>-1</code>（需通过 <code>ferror(stream)</code> 检查错误）。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>); <span class="comment">// 二进制模式（避免文本模式的换行符干扰）</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END); <span class="comment">// 指针移到文件末尾</span></span><br><span class="line">    <span class="type">long</span> file_size = ftell(fp); <span class="comment">// 获取偏移量（即文件大小）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小：%ld 字节\n&quot;</span>, file_size);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>10.与 <code>fseek</code> 的配合</strong></p>
<p><code>ftell</code> 常与 <code>fseek</code> 配合实现<strong>随机访问</strong>：</p>
<ol>
<li>用 <code>ftell</code> 记录当前位置；</li>
<li>用 <code>fseek</code> 跳转到其他位置读写；</li>
<li>再用 <code>fseek</code> 跳回记录的位置，继续操作。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;data.bin&quot;</span>, <span class="string">&quot;rb+&quot;</span>); <span class="comment">// 读写模式</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始位置（文件开头，偏移量为0）</span></span><br><span class="line">    <span class="type">long</span> pos = ftell(fp); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始位置：%ld\n&quot;</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟读写操作，指针移动</span></span><br><span class="line">    fseek(fp, <span class="number">10</span>, SEEK_CUR); <span class="comment">// 指针向后移动10字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前位置：%ld\n&quot;</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳回之前记录的位置</span></span><br><span class="line">    fseek(fp, pos, SEEK_SET); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;跳回后位置：%ld\n&quot;</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-整数转换函数">22.整数转换函数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">目标类型</th>
<th style="text-align:center">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>atoi</code></td>
<td style="text-align:center">字符串 → 整数</td>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">简单转换，不支持进制指定，无错误处理（失败返回 0）</td>
</tr>
<tr>
<td style="text-align:center"><code>atol</code></td>
<td style="text-align:center">字符串 → 长整数</td>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">同 <code>atoi</code>，但目标类型为 <code>long</code>（范围更大）</td>
</tr>
<tr>
<td style="text-align:center"><code>atoll</code></td>
<td style="text-align:center">字符串 → 长长整数</td>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center">同 <code>atoi</code>，目标类型为 <code>long long</code>（支持更大范围）</td>
</tr>
<tr>
<td style="text-align:center"><code>strtol</code></td>
<td style="text-align:center">字符串 → 长整数（灵活版）</td>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">支持指定进制（2-36），可检测转换结束位置，支持错误处理</td>
</tr>
<tr>
<td style="text-align:center"><code>strtoll</code></td>
<td style="text-align:center">字符串 → 长长整数（灵活版）</td>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center">同 <code>strtol</code>，目标类型为 <code>long long</code></td>
</tr>
<tr>
<td style="text-align:center"><code>strtoul</code></td>
<td style="text-align:center">字符串 → 无符号长整数</td>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center">同 <code>strtol</code>，但目标类型为无符号长整数（仅非负）</td>
</tr>
<tr>
<td style="text-align:center"><code>strtoull</code></td>
<td style="text-align:center">字符串 → 无符号长长整数</td>
<td style="text-align:center"><code>unsigned long long</code></td>
<td style="text-align:center">同 <code>strtoul</code>，目标类型为无符号长长整数函数名</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;  123\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;  123&quot;</span>));       <span class="comment">// 123（忽略前导空格）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;45abc\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;45abc&quot;</span>));     <span class="comment">// 45（遇到非数字停止）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;-67\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;-67&quot;</span>));         <span class="comment">// -67（支持负号）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;abc89\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;abc89&quot;</span>));     <span class="comment">// 0（无有效数字）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-运算符优先级问题">23.运算符优先级问题</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/">http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">WF的知识空间</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="数据结构与算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构与算法</div></div><div class="info-2"><div class="info-item-1">1.线性表（顺序表+链表） 线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都有前驱{后继）。 ①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接尾驱节点 顺序表：物理相邻，逻辑相邻。（数组 != 顺序表） 线性表：逻辑相邻，物理不一定相邻。 8.排序算法 1.冒泡排序（小的元素上浮）———本质每次将最大的元素后移到最后 123456789101112131415161718void bubble_sort(int* arr, int n) &#123;	int temp=0;    bool swapped=false;	for (int j = 0; j &lt; n-1; j++) &#123;        swapped = false;				//检测是否有交换		for (int i = 0; i &lt; n-i-1; i++) &#123;			if (arr[i] &gt; arr[i + 1]) &#123;				temp = arr[i];				arr[i] = arr[i + 1];	...</div></div></div></a><a class="pagination-related" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">linux 系统</div></div><div class="info-2"><div class="info-item-1">1.Linux系统基础文件 1./bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令. 2./sbin:系统管理命令(超级用户二进制文件) 仅存放root用户的可执行命令 3./usr:用户共享资源 是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86) 4/etc:系统配置文件 存放的是系统和应用程序的配置文件,包含网络配置，用户配置，服务配置，系统启动 'etc/network 网络配置 5./dev 设备文件目录 块设备(读写，硬盘)，字符设备(键盘鼠标)，虚拟设备: 6.proc:进程与系统信息文件目录 存放虚拟目录，不占用磁盘空间，反映内核，进程，硬件的状态: 7.home 家目录 存放普通用户下的所有文件信息 '8./root 超级用户目录 ，存放超级用户下的所有文件信息 '9./boot系统启动相关文件 启动Lin脑ux系统必备文件 :10./lib /lib64 共享库文件 /lib存放共享库 /lib/libc.so,6C标准库 /linb64 64位系统库 '11.medi...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WF</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WF-git-code"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="//github.com/WF-git-code" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18628492787@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">1.什么是指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-c%E8%AF%AD%E8%A8%80%E4%B8%AD-const-%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%8C%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%EF%BC%8C%E8%A1%A8%E6%98%8E%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="toc-number">2.</span> <span class="toc-text">2.c语言中&#x3D;&#x3D;const&#x3D;&#x3D; 是一个类型限定符，用来修饰变量，表明该变量的值不能被修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3.数组指针（指针偏移量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">4.指针数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B"><span class="toc-number">5.</span> <span class="toc-text">5.为什么数组下标从0开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%9C%A8%E5%AD%98%E5%82%A8%E4%B8%AD%E6%98%AF%E7%94%B1%E4%BD%8E%E5%9C%B0%E5%9D%80%E5%90%91%E9%AB%98%E5%9C%B0%E5%9D%80%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text">6.数组在存储中是由低地址向高地址存储的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8C%87%E9%92%88-p-%E5%92%8C-p-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">7.指针&#x3D;&#x3D;*p++&#x3D;&#x3D;和&#x3D;&#x3D;++*p&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">8.指针函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">9.函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">10.动态内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%BD"><span class="toc-number">11.</span> <span class="toc-text">11.相同字符串常量在内存中只有一份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">12.结构体类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">13.与字符串有关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%EF%BC%9Astrlen"><span class="toc-number">13.1.</span> <span class="toc-text">求字符串长度：strlen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6%EF%BC%9Astrcpy-%E4%B8%8E-strncpy"><span class="toc-number">13.2.</span> <span class="toc-text">2.字符串复制：strcpy 与 strncpy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-strcat-%E4%B8%8E-strncat"><span class="toc-number">13.3.</span> <span class="toc-text">3.strcat 与 strncat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%EF%BC%9Astrcmp-%E4%B8%8E-strncmp"><span class="toc-number">13.4.</span> <span class="toc-text">4. 字符串比较：strcmp 与 strncmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6-%E5%AD%90%E4%B8%B2%EF%BC%9Astrchr%E3%80%81strrchr%E3%80%81strstr"><span class="toc-number">13.5.</span> <span class="toc-text">5.查找字符 &#x2F; 子串：strchr、strrchr、strstr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-isdigit%C2%A9%E5%88%A4%E6%96%AD%E8%AF%A5%E5%AD%97%E7%AC%A6%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6-ctype-h%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">13.6.</span> <span class="toc-text">6.isdigit©	判断该字符是不是数字字符	&#x2F;&#x2F;ctype.h头文件中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-strtok%E5%87%BD%E6%95%B0"><span class="toc-number">13.7.</span> <span class="toc-text">7.strtok函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">14.内存操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6%EF%BC%9Amemcpy-%E4%B8%8E-memmove"><span class="toc-number">14.1.</span> <span class="toc-text">1.内存复制：memcpy 与 memmove</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%EF%BC%9Amemset"><span class="toc-number">14.2.</span> <span class="toc-text">2. 内存设置：memset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%EF%BC%9Amemcmp"><span class="toc-number">14.3.</span> <span class="toc-text">3. 内存比较：memcmp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-assert"><span class="toc-number">15.</span> <span class="toc-text">15.assert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">16.</span> <span class="toc-text">16.联合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">17.枚举（enum）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">18.</span> <span class="toc-text">18.内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">19.变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%87%BD%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">20.函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">21.</span> <span class="toc-text">21.文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">22.整数转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98"><span class="toc-number">23.</span> <span class="toc-text">23.运算符优先级问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2025-08-16T00:03:39.000Z" title="发表于 2025-08-16 08:03:39">2025-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统">linux 系统</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言">C语言</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By WF</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>