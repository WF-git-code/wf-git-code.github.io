<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言 | WF的知识空间</title><meta name="author" content="WF"><meta name="copyright" content="WF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.什么是指针 描述:由来+描述 1TB&#x3D;1024GB 1GB&#x3D;1024MB 1MB&#x3D;1024KB 1KB&#x3D;1024Byte 1Byte&#x3D;8bit  每一个Bit物理原件可以保存0或1 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 为什么？ 在计算机内">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/index.html">
<meta property="og:site_name" content="WF的知识空间">
<meta property="og:description" content="1.什么是指针 描述:由来+描述 1TB&#x3D;1024GB 1GB&#x3D;1024MB 1MB&#x3D;1024KB 1KB&#x3D;1024Byte 1Byte&#x3D;8bit  每一个Bit物理原件可以保存0或1 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 为什么？ 在计算机内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WF.png">
<meta property="article:published_time" content="2025-07-27T00:52:57.000Z">
<meta property="article:modified_time" content="2026-01-18T09:58:52.411Z">
<meta property="article:author" content="WF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C语言",
  "url": "http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/",
  "image": "http://example.com/img/WF.png",
  "datePublished": "2025-07-27T00:52:57.000Z",
  "dateModified": "2026-01-18T09:58:52.411Z",
  "author": [
    {
      "@type": "Person",
      "name": "WF",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WF的知识空间</span></a><a class="nav-page-title" href="/"><span class="site-name">C语言</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">C语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-18T09:58:52.411Z" title="更新于 2026-01-18 17:58:52">2026-01-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="1-什么是指针">1.什么是指针</h3>
<p>描述:由来+描述</p>
<p><strong>1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024Byte 1Byte=8bit  每一个Bit物理原件可以保存0或1</strong></p>
<p><strong>指针</strong>也就是<strong>内存地址</strong>，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。</p>
<p><strong>指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关</strong></p>
<p><strong>为什么？</strong></p>
<p><strong>在计算机内部存在32根地址线供计算机给每个字节（内存中的最小单元）都分配了地址和编号</strong></p>
<p>每一根电线	正电荷1	负电荷0(不固定)					  十六进制（0X）    8bit的空间</p>
<p>第一块字节编号	00000000 00000000 00000000 00000000	0X 00 00 00 00	00000000</p>
<p>第二块字节编号	00000000 00000000 00000000 00000001	0X 00 00 00 01	00000001</p>
<p>第三块字节编号	00000000 00000000 00000000 00000010	0X 00 00 00 02	00000010</p>
<p>第四块字节编号	00000000 00000000 00000000 00000011	0X 00 00 00 03	00000011</p>
<p>…………</p>
<p>第2^32-1块编号        11111111 111111111 11111111 11111111      0X FF FF FF FF	11111111</p>
<p>32根地址线一次可以给2^32Byte个字节编号	4GB（运行内存）	（64位或x64系统同理）8GB</p>
<p>运行内存就是计算机通过地址线最多一次访问的内存</p>
<p>32根地址线即32bit=4B	则其寻址能力=指针大小为4B</p>
<table>
<thead>
<tr>
<th style="text-align:center">十进制 (Decimal)</th>
<th style="text-align:center">二进制 (Binary)</th>
<th style="text-align:center">十六进制 (Hexadecimal)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0000</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0001</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0010</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0011</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0100</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0101</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0110</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">0111</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">1001</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">1010</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">1011</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">1100</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">1101</td>
<td style="text-align:center">D</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">1110</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">1111</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">10000</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//1Byte=8bit			8bit空间</span></span><br><span class="line">    <span class="comment">//(ox 00 00 00 00)		00001010</span></span><br><span class="line">    <span class="comment">//(0x 00 00 00 01)		00000000</span></span><br><span class="line">    <span class="comment">//(0x 00 00 00 02)		00000000</span></span><br><span class="line">    <span class="comment">//(0x 00 00 00 03)		00000000</span></span><br><span class="line">    <span class="comment">//由于计算机大多为小端存储（低位字节在内存低地址）寄存器先高位字节--&gt;高地址入栈 内存低地址出栈</span></span><br><span class="line">    <span class="comment">//00000000 00000000 00000000 00001010</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>任何一片空间的地址都是其第一个字节编号或地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&amp;a  表示a四个字节中第一个字节的地址或者编号      <strong>指针的格式控制符%p</strong>将地址按照16进制格式输出</p>
<p>*<strong>p</strong>  -&gt;   <strong>①找到p中保存的这个地址的字节	②然后获取sizeof（Type）个字节	③按照小端存储挨个取出</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span>*p=&amp;a;</span><br><span class="line"><span class="type">int</span>*p1=&amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*p);<span class="comment">//找到p中保存的a的第一个字节的地址，从地址开始获取sizeof（char）个字节，然后按小端模式从内存高地址取出放到高位数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*p2);<span class="comment">//找到p中保存的a的第一个字节的地址，从地址开始获取sizeof（int）个字节，然后按小端模式从内存高地址取出放到//高位数据	由于c语言保护机制不访问未申请的地址，但这种做法错误一般不使用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p1);<span class="comment">//正常  保护机制</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p2);<span class="comment">//乱码  不要随意解引用访问未申请的内存</span></span><br></pre></td></tr></table></figure>
<p><strong>不要随意解引用访问未申请的内存  会出现很多未知因素</strong></p>
<p><strong>指针指向哪里都可以（可以保存任何地址），但是若指针所指的空间不是有效空间程序会崩溃</strong></p>
<p><strong>零号空间~128m字节空间是禁止访问区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)<span class="number">0</span>  <span class="comment">//会崩溃</span></span><br></pre></td></tr></table></figure>
<p>eg：①随机地址（野指针，悬挂指针）<strong>指针未初始化，没有固定指向的指针，指针访问越界（访问未申请的内存）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>②空指针:指向0号空间，对空指针解引用程序崩溃       <strong>零号空间~128m字节空间是禁止访问区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p=<span class="literal">NULL</span>;</span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>其格式：*type  *var_name;   <strong>type取决于被指向的数据类型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi=&amp;a;</span><br></pre></td></tr></table></figure>
<p>其中type必须是一个有效的数据类型。*p解释的是从0x1地址开始到0x1+sizeof（type）的所对应字节的内容</p>
<p><strong>指针本质是一个字节的地址	但他的类型决定了它的能力</strong></p>
<p>指针*的能力访问sizeof(type)个字节的值</p>
<p>指针±的能力   <strong>当前地址=指针指向的地址(+ \ -)i*sizeof（指针类型）</strong>，然后再从当前地址访问后续sizeof(type)的值</p>
<p>在<strong>多级指针</strong>中也一样，q保存的是a的地址，其中 * 是<strong>解引用</strong>的意思，对q保存的a的地址解引用就得到了10。对于w而言至右像左*对w解引用得到q的值即a的地址，再对a的地址解引用得到10。其中e也同理，属于无限套娃。</p>
<p>多级指针从右至左匹配*解引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* q = &amp;a;</span><br><span class="line"><span class="type">int</span>** w = &amp;q;</span><br><span class="line"><span class="type">int</span>*** e = &amp;w;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* c[] = &#123; <span class="string">&quot;ENTER&quot;</span>,<span class="string">&quot;NEW&quot;</span>,<span class="string">&quot;POINT&quot;</span>,<span class="string">&quot;FIRST&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//c char*[4]  16Byte   </span></span><br><span class="line"><span class="comment">//c [0]&quot;ENTER&quot;地址 0x0001</span></span><br><span class="line"><span class="comment">//c [1]&quot;NEW&quot;       0x0005</span></span><br><span class="line"><span class="comment">//c [2]&quot;POINT&quot;     0x0009</span></span><br><span class="line"><span class="comment">//c [3]&quot;FIRST&quot;     0x000D</span></span><br><span class="line"><span class="comment">//c  char**   0x1001   +1 sizeof(char*)4Byte</span></span><br><span class="line"><span class="type">char</span>** cp[] = &#123; c + <span class="number">3</span>,c + <span class="number">2</span>,c + <span class="number">1</span>,c &#125;;</span><br><span class="line"><span class="comment">//cp char**[4]   16Byte</span></span><br><span class="line"><span class="comment">//cp [0] &amp;c[3]   0x100D</span></span><br><span class="line"><span class="comment">//cp [1] &amp;c[2]   0x1009</span></span><br><span class="line"><span class="comment">//cp [2] &amp;c[1]   0x1005</span></span><br><span class="line"><span class="comment">//cp [3] &amp;c[0]   ox1001</span></span><br><span class="line"><span class="comment">//cp char***  0x1101   +1 sizeof(char**)4Byte</span></span><br><span class="line"><span class="type">char</span>*** cpp = cp;</span><br><span class="line"><span class="comment">//cpp char***  cpp ---&gt;0x1101  +1sizeof(char**)4Byte</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line"><span class="comment">//cpp 0x1101</span></span><br><span class="line"><span class="comment">//++cpp 0x1105 &amp;cp[1]</span></span><br><span class="line"><span class="comment">//*++cpp 0x1109</span></span><br><span class="line"><span class="comment">//**++cpp 0x0009</span></span><br><span class="line"><span class="comment">//%s   &quot;POINT&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *-- * ++cpp + <span class="number">3</span>);</span><br><span class="line"><span class="comment">//cpp 0x1105</span></span><br><span class="line"><span class="comment">//++cpp 0x1109 char***</span></span><br><span class="line"><span class="comment">//*++cpp 0x1005 &amp;c[1] char**</span></span><br><span class="line"><span class="comment">//--*++cpp 0x1001 &amp;c[0] char**</span></span><br><span class="line"><span class="comment">//*--*++cpp 0x0001 char*</span></span><br><span class="line"><span class="comment">//*--*++cpp+3 &quot;ENTER&quot;E的地址</span></span><br><span class="line"><span class="comment">//%s ER</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>] + <span class="number">3</span>);</span><br><span class="line"><span class="comment">//cpp 0x1109</span></span><br><span class="line"><span class="comment">//*cpp[-2]+3    *(*(cpp-2))+3</span></span><br><span class="line"><span class="comment">//*(cpp-2) 0x100D &amp;c[3] char**</span></span><br><span class="line"><span class="comment">//*(*(cpp-2)) 0x000D char*</span></span><br><span class="line"><span class="comment">//*(*(cpp-2))+3</span></span><br><span class="line"><span class="comment">//%s ST</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//cpp  0x1105</span></span><br><span class="line"><span class="comment">//cpp[-1][-1] + 1   *(*(cpp-1))-1)+1</span></span><br><span class="line"><span class="comment">//*(cpp-1) 0x1009 char**</span></span><br><span class="line"><span class="comment">//*(*(cpp-1))-1 0x0005 char*</span></span><br><span class="line"><span class="comment">//*(*(cpp-1))-1)+1</span></span><br><span class="line"><span class="comment">//%s EW</span></span><br></pre></td></tr></table></figure>
<h3 id="2-c语言中const-是一个类型限定符，用来修饰变量，表明该变量的值不能被修改">2.c语言中const 是一个<strong>类型限定符</strong>，用来修饰变量，表明该变量的值<strong>不能被修改</strong></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>指针设计与指针用途有关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>*p=*val;</span><br></pre></td></tr></table></figure>
<p>在设计指针时为了防止将预期*p修改为1其他值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p=&amp;val;</span><br></pre></td></tr></table></figure>
<p>即不可通过对p解引用修改val的值，指针指向的值不通过指针修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> P=&amp;val;</span><br></pre></td></tr></table></figure>
<p>即指针本身的值不可修改，p中只能存储val的地址</p>
<p>用法如以下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* q = &amp;p;</span><br><span class="line"><span class="type">int</span> w=<span class="number">3</span>；</span><br><span class="line">q = &amp;w；</span><br></pre></td></tr></table></figure>
<p>1.const修饰的变量只能由指向const变量的指针去指向—&gt;<strong>规定</strong></p>
<p>2.此时const的位置在*的左边</p>
<p>3.其中const限定修饰变量p，这使其p所对应的值1不能被修改，那么 * q指向p所对应的值1，即也应该对*q加const变量限定修饰，但是q所保存的p的地址是可以修改的。</p>
<p><strong>被const修饰的指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,c;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="type">int</span>** p2 = &amp;p1;</span><br><span class="line"><span class="type">int</span>*** p3 = &amp;p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*const int* t1 = &amp;f;</span></span><br><span class="line"><span class="comment">const int** t2 = &amp;t1;</span></span><br><span class="line"><span class="comment">const int*** t3 = &amp;t2;</span></span><br><span class="line"><span class="comment">t1 = &amp;a;</span></span><br><span class="line"><span class="comment">t2 = &amp;p1;</span></span><br><span class="line"><span class="comment">t3 = &amp;p2;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* t = &amp;a;</span><br><span class="line">t = &amp;c;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*<span class="type">const</span> t1 = &amp;f;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span>* t2 = &amp;t1;</span><br><span class="line">t2 = &amp;t;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*<span class="type">const</span>*<span class="type">const</span>* t3 = &amp;t2;</span><br><span class="line">t2 = &amp;p1;</span><br><span class="line">t3 = &amp;p2;</span><br></pre></td></tr></table></figure>
<p>在此段代码中：int b的范围与const*int t的范围相同，b所对应的值0不能被改变，<strong>t所包含的b的地址不能被改变</strong>,此时变量b的值可以改变。</p>
<p>但在const int*const v中由于a被const修饰限定，那么指向a的指针t也应该被const修饰即**const 	int *const v **第一个const，而const int *const v中这个const是重新对v施加的限定，使得v只能保存a的地址。与此同时const int const v = &amp;b;也可以保存被const修饰的变量b</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*<span class="type">const</span> =<span class="type">const</span> <span class="type">int</span>*</span><br><span class="line">先检查权限看权限是否对等			从右向左权限可以缩小在==多级被<span class="type">const</span>所修饰的指针==中</span><br></pre></td></tr></table></figure>
<p><strong>指向const变量的指针</strong></p>
<p>我有一个const变量，我需要一个指针去指向他，那这个指针只能时一个指向const的指针，<strong>在*的左边有const</strong></p>
<p><strong>被const修饰的指针</strong></p>
<p>这个指针中，保存的地址不能改变，这个指针不能再指向别的变量。但被指向的变量本身是可以改变的，<strong>再*的右边有const</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> intconst* q = &amp;a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>** w = &amp;q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*** e = &amp;w;</span><br></pre></td></tr></table></figure>
<p>即多级指针中  const  在  *  左右的核心区别</p>
<ul>
<li>const  在  *  左侧 → 限制“指针指向的数据”：</li>
<li>无论多少级指针，只要某一层  const  在  *  左侧，就表示 “通过该指针（或其下层指针），不能修改最终指向的数据”。<br>
const  在  *  右侧 → 限制“指针变量本身”：-</li>
<li>某一层  const  在  *  右侧时，表示 “该层的指针变量地址不能变（不能指向其他地址）”。<br>
可以简单类比记忆：</li>
<li>const  在  *  左 → 给“数据房间”上锁，任你通过哪层指针开门，都改不了房间里的数据；</li>
<li>const  在  *  右 → 给“指针钥匙”焊死在锁孔，这把钥匙不能插到其他锁孔（指针不能换指向）。</li>
</ul>
<h3 id="3-数组指针（指针偏移量）">3.数组指针（指针偏移量）</h3>
<p>数组指针的本质是<strong>指向数组的指针</strong>。</p>
<p>在内存中数据的存储是连续的，而指针偏移量一般对于数组来说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = arr;</span><br></pre></td></tr></table></figure>
<p>数组名为数组<strong>第一个元素</strong>的首地址如图</p>
<p>计算机中没有规定有哪个格式控制符能一次访问一个数组大小</p>
<p>数组名：大多数情况代表首元素的 地址 可以让人们更好的访问这数组大小的字节 <strong>&amp;arr[0]——-&gt;int</strong>*</p>
<p><strong>int[5]—-&gt;int</strong>*	<strong>数组名类型会退化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr+<span class="number">1</span>);<span class="comment">//4Byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *arr+<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr+<span class="number">1</span>);<span class="comment">//20Byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;*arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;*arr+<span class="number">1</span>);<span class="comment">//4Byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *&amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *&amp;arr+<span class="number">1</span>);<span class="comment">//4Byte</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, **&amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, **&amp;arr+<span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *&amp;*arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *&amp;*arr + <span class="number">1</span>);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;*&amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;*&amp;arr+<span class="number">1</span>);<span class="comment">//20Byte</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>*p=arr;<span class="comment">//首元素第一个字节的地址</span></span><br><span class="line"><span class="type">int</span>*p2=&amp;arr;<span class="comment">//整个数组地址的前一个字节的地址</span></span><br><span class="line"><span class="type">int</span> *p=arr[<span class="number">0</span>];   </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">p</th>
<th style="text-align:center">arr</th>
<th style="text-align:center">arr[0]</th>
<th style="text-align:center">&amp;arr[0]</th>
<th style="text-align:center">&amp;arr</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类型</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int（*）[5]</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">变量</td>
<td style="text-align:center">常量值</td>
<td style="text-align:center">变量</td>
<td style="text-align:center">常量</td>
<td style="text-align:center">常量值</td>
</tr>
<tr>
<td style="text-align:center">保存的值</td>
<td style="text-align:center">数组首元素地址</td>
<td style="text-align:center">数组首元素地址</td>
<td style="text-align:center">首元素</td>
<td style="text-align:center">首元素地址常量</td>
<td style="text-align:center">数组首地址</td>
</tr>
<tr>
<td style="text-align:center">含义</td>
<td style="text-align:center">保存第一个元素首元素地址的变量</td>
<td style="text-align:center">第一个元素第一个字节地址</td>
<td style="text-align:center">*（arr）</td>
<td style="text-align:center">第一个元素的第一个字节的地址</td>
<td style="text-align:center"><strong>整个数组的地址</strong>第一个字节的地址</td>
</tr>
</tbody>
</table>
<p>数组名：①除了sizeof和&amp;之外都是数组首元素的地址</p>
<p>​		②sizeof数组名是整个数组的大小</p>
<p>​		③&amp;数组名是整个数组的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;*&amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;*&amp;arr+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//arr  int[10]</span></span><br><span class="line"><span class="comment">//&amp;arr  int(*)[10]</span></span><br><span class="line"><span class="comment">//*&amp;arr  int[10]</span></span><br><span class="line"><span class="comment">//&amp;*&amp;arr  int(*)[10]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,<span class="keyword">sizeof</span>(*&amp;arr));<span class="comment">//40  &amp;arr int(*)arr  *&amp;arr int[10]  40 -退化-&gt;int*  *int*==int  先&amp;再*相当于抵消</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>,<span class="keyword">sizeof</span>(&amp;*arr));<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>(<span class="number">3</span>,<span class="number">4</span>),<span class="number">5</span>&#125;;<span class="comment">//(表达式（1，2，3，4，5)属于逗号表达式依次执行1，2，3，4，5后返回5)</span></span><br><span class="line"><span class="comment">//此时这个数组大小为4&#123;1，2，4，5&#125;</span></span><br></pre></td></tr></table></figure>
<p>若要实现用数组表示数组中的元素arr[i]用指针表示* （p+i）而在数组中加i相当于<strong>当前地址=首地址+i*sizeof（数组类型）</strong></p>
<p>这也衍生出了一个问题，如果我要使得指针+1一次跨过三个元素那么可以定义一个新的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*s)[<span class="number">3</span>] =(<span class="type">int</span>(*)[<span class="number">3</span>])arr;</span><br></pre></td></tr></table></figure>
<p>这种形式也叫做数组指针</p>
<p>s前进i位在内存上前进3* sizeof（int）个B，而等号右边的（int（*）[3])则是为了保证等号左右两边为同一类型。</p>
<p>数组指针常用于多维数组用来进行行的切换</p>
<p>二维数组在存放上是一维的形式，逻辑上是表的形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*s)[<span class="number">4</span>]=arr;<span class="comment">//进行行的切换</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span> &#125;;</span><br><span class="line"><span class="comment">//48Byte</span></span><br><span class="line"><span class="comment">//3个元素(1·16)arr[0]=&#123;1,2,3,4&#125;;.........</span></span><br><span class="line"><span class="comment">//每一个元素int[4]</span></span><br><span class="line"><span class="comment">//arr除了&amp;和sizeof外arr-&gt;int [3][4]-&gt;int(*)[4]首元素的地址</span></span><br><span class="line"><span class="comment">//sizeof(arr)=48  &amp;arr-&gt;int(*)[3][4]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **arr);</span><br><span class="line"><span class="comment">//arr:首元素地址&#123;1，2，3，4&#125;的地址 int(*)[4]</span></span><br><span class="line"><span class="comment">//*arr:&#123;1,2,3,4&#125;地址解引用=&#123;1，2，3，4&#125;得 int [4]=&#123;1,2,3,4&#125; ---退化--&gt;  的首元素地址即1的地址//int*</span></span><br><span class="line"><span class="comment">//**arr:1的地址进行解引用//1//int</span></span><br></pre></td></tr></table></figure>
<p>动态申请二维数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存连续</span></span><br><span class="line"><span class="type">int</span>(*arr)[<span class="number">2</span>]=(<span class="type">int</span>(*)[<span class="number">2</span>])<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="number">2</span><span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//内存不连续</span></span><br><span class="line"><span class="type">int</span>**arr=(<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>*))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        arr[i]=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二维数组在逻辑关系上是一个表格</strong>，但数组的存储在物理上是连续的为一位数组，因此使用二级指针来进行行的切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>4个元素  int[3]	a-&gt;首元素的地址 int（*)[3]	* a -&gt; int[3] -&gt; int *</p>
<p>面试题    一维数组如何变成二维数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">12</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;<span class="comment">//连续48Byte</span></span><br><span class="line"><span class="type">int</span> brr[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">//arr(int*)---&gt;brr(int(*)[4])</span></span><br><span class="line"><span class="type">int</span>(*p)[<span class="number">4</span>]=arr;<span class="comment">//p就是二位数组 == int p[][4]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;i&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>[]优先级高于</strong>*</p>
<h3 id="4-指针数组">4.指针数组</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* s [<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>指针数组本质上是一个存放指针的数组，<strong>其本质是数组</strong>，其里面内容存放的是指针。</p>
<h3 id="5-为什么数组下标从0开始">5.为什么数组下标从0开始</h3>
<p>1.假设数组首地址起点为base</p>
<p>2.指针访问成员通过<strong>指针+偏移量解引用</strong>即*（p+1）访问</p>
<p>3.根据地址计算公式</p>
<p><strong>现地址=首地址（base）+i*sizeof（数组类型）</strong></p>
<p>如果首地址为1，若要访问第一个元素就需要减去i*sizeof（数组类型），很不方便，并且在早期计算机中处理预算需要时钟周期，早期算力不高，因此首地址为0即方便了运算又节省了算力。</p>
<h3 id="6-数组在存储中是由低地址向高地址存储的">6.数组在存储中是由低地址向高地址存储的</h3>
<p><strong>指针相加减</strong></p>
<p>一般在数组中指针相加没意义，指针相减高地址减低地址等于两个地址间所有的元素个个数**（指针相减必须是同类型指针，且再所申请的空间中）**</p>
<p><strong>（地址-地址）/sizeof(指针类型)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针相减</span></span><br><span class="line"><span class="comment">//两个指针必须是同一类型 并且处于同一块申请的空间中</span></span><br><span class="line"><span class="type">int</span> crr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p1 = &amp;arr[<span class="number">9</span>];<span class="comment">//37</span></span><br><span class="line"><span class="type">int</span>* p2 = &amp;arr[<span class="number">0</span>];<span class="comment">//1                                                                   </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p1 - p2);<span class="comment">//37-1/sizeof(int) 9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p2 - p1);<span class="comment">//1-37/sizeof(int) -9</span></span><br></pre></td></tr></table></figure>
<h3 id="7-指针-p-和-p的区别">7.指针* p++和++* p的区别</h3>
<p><strong>“*”与“+”  “-”优先级相同，结合方向至右向左</strong></p>
<h3 id="8-指针函数">8.指针函数</h3>
<p>本质是函数返回值是指针</p>
<p>int* arr(int q,inta);</p>
<h3 id="9-函数指针">9.函数指针</h3>
<p><strong>函数名本质是函数在内存的入口地址</strong></p>
<p>本质是指针	指向函数的指针</p>
<p>其定义方式	*<em>函数值返回类型（<em>p）（函数的形式参数列表）</em></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>)<span class="comment">//声明一个函数指针</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span><span class="comment">//声明一个指针函数</span></span><br></pre></td></tr></table></figure>
<p>函数名本身就是函数的内存地址，因此可以直接将函数名赋值给函数指针完成初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个普通函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数指针</span></span><br><span class="line"><span class="type">int</span> (*p_func)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化：将函数名赋值给指针（函数名即地址）</span></span><br><span class="line">p_func = add;  <span class="comment">// 等价于 p_func = &amp;add;（&amp;可以省略）</span></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：使用解引用符*</span></span><br><span class="line"><span class="type">int</span> result1 = (*p_func)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 等价于调用 add(2, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：直接使用指针名（更简洁，常用）</span></span><br><span class="line"><span class="type">int</span> result2 = p_func(<span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// 同样等价于 add(2, 3)</span></span><br></pre></td></tr></table></figure>
<p>typedef关键字	类型重命名    可以将函数名提升为此类新函数的 类型名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 返回值类型 (*函数名)(参数类型<span class="number">1</span>, 参数类型<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 用typedef定义函数指针类型别名CalcFunc</span></span><br><span class="line"><span class="comment">//   （代表&quot;返回int、接收两个int参数&quot;的函数指针类型）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CalcFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 普通函数（与CalcFunc类型匹配）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 3. 用别名CalcFunc直接声明函数指针变量（简洁！）</span></span><br><span class="line">    CalcFunc p_add = add;  <span class="comment">// 指向add函数</span></span><br><span class="line">    CalcFunc p_sub = sub;  <span class="comment">// 指向sub函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3+5=%d\n&quot;</span>, p_add(<span class="number">3</span>, <span class="number">5</span>));  <span class="comment">// 输出：8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;7-2=%d\n&quot;</span>, p_sub(<span class="number">7</span>, <span class="number">2</span>));  <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用：动态调用指定的函数</p>
<p><strong>回调函数      把函数当作参数传递</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用typedef定义比较函数的指针类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CompareFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序函数：参数直接使用类型别名CompareFunc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len, CompareFunc compare)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(arr[j], arr[j+<span class="number">1</span>])) &#123;  <span class="comment">// 调用回调函数</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的比较函数（与CompareFunc类型匹配）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">asc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;  <span class="comment">// 升序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">desc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a &lt; b; &#125; <span class="comment">// 降序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    sort(arr, len, asc);  <span class="comment">// 传入升序比较函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;升序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);  <span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">    sort(arr, len, desc); <span class="comment">// 传入降序比较函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n降序：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);  <span class="comment">// 4 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数指针数组       多项选择的时候使用   通过函数指针访问数组中的函数</p>
<p>语法1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (*函数指针的数组名[大小])(参数表)=&#123;函数名<span class="number">1</span>，函数名<span class="number">2</span>，……&#125;;</span><br></pre></td></tr></table></figure>
<p>语法2：更贴近使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 返回值类型 (*函数指针类型名)(参数表);</span><br><span class="line">函数指针类型名  数组名[大小]=&#123;函数名<span class="number">1</span>，函数名<span class="number">2</span>，……&#125;;</span><br></pre></td></tr></table></figure>
<p>函数指针数组指针的定义</p>
<p>取函数指针数组的地址</p>
<p>语法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型(**farr)(<span class="type">int</span>,<span class="type">int</span>);<span class="comment">//指向函数指针数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> 返回值类型(*FUN)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">FUN **arrp;</span><br></pre></td></tr></table></figure>
<p><strong>扩展：   void * 表示任意类型的指针，不能解引用，不能跳下一个位置（++,+,–, - 都不行）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">ishow1</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span>* element)</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d:%d &quot;</span>, index, *(<span class="type">int</span> *)element);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">ishow2</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span>* element)</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d &quot;</span>, index, *(<span class="type">int</span>*)element);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">fshow1</span><span class="params">(<span class="type">int</span> index, <span class="type">void</span>* element)</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%.2f &quot;</span>, index, *(<span class="type">float</span>*)element);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">forEach</span><span class="params">(<span class="type">void</span>* arr,<span class="type">size_t</span> typeSize, <span class="type">int</span> len, <span class="type">void</span> (*pf)(<span class="type">int</span>, <span class="type">void</span> *))</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"> pf(i, arr);</span><br><span class="line"> <span class="comment">// 下一个元素的位置</span></span><br><span class="line">arr = (<span class="type">char</span> *)arr+typeSize;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">21</span>,<span class="number">22</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">87</span>,<span class="number">89</span>,<span class="number">67</span>,<span class="number">55</span>, <span class="number">13</span>, <span class="number">75</span> &#125;;</span><br><span class="line"> forEach(arr, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">10</span>, ishow1);</span><br><span class="line"> <span class="type">float</span> arr2[<span class="number">5</span>] = &#123; <span class="number">2.5f</span>, <span class="number">4.4f</span>, <span class="number">4.6</span>, <span class="number">7.8f</span>, <span class="number">9.0f</span> &#125;;</span><br><span class="line"> forEach(arr2,<span class="keyword">sizeof</span>(<span class="type">float</span>), <span class="number">5</span>, fshow1);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-动态内存">10.动态内存</h3>
<p><strong>1.内存栈区</strong>：由系统管理：作用域结束内存被系统回收，函数内的<strong>非静态局部变量****和</strong>函数有关的局部信息**</p>
<p>内存开辟方向：<strong>高地址向低地址进行存放</strong>	eg：main：int a=1;intb=2;<strong>&amp;a高于&amp;b</strong>，<strong>windows默认大小1M</strong></p>
<p>可静态分配也可动态分配（alloca）函数但不需要free释放。栈分配效率高。</p>
<p>数组在内存中由<strong>低地址向高地址</strong>存放</p>
<p>分配后系统响应：只要栈剩余空间大于申请空间则分配成功，否则栈溢出。并且栈不会出现碎片问题</p>
<p><strong>2.内存堆区</strong>：由程序员控制，使用方便但易产生内存写漏，堆一般存储生命周期与函数调用无关的数据，具体内容由程序员决定，堆通常在头部用一个字节存放其大小。内存开辟方向：<strong>低地址向高地址存放</strong>	堆的大小取决于计算机有效的虚拟内存，32位linux系统堆内存可达2.9G，windows一般在1.5~1.9G之间。堆内存必须动态分配且需要手动释放。堆由函数库提供，机制复杂效率低。操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。大多数系统会在该内存空间首地上处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。</p>
<p>需要引入头文件**&lt;stdlib.h&gt;**</p>
<p><strong>3.malloc申请	一个参数</strong>，申请内存无初始值</p>
<p><strong>功能</strong>：从堆区分配一块 <strong>连续的、大小为<code>size</code>字节</strong> 的内存块。<br>
<strong>特点</strong>：</p>
<ul>
<li>分配的内存 <strong>未初始化</strong>，内容是随机的（原内存区域的残留数据）。</li>
<li>只需要一个参数：待分配的总字节数（<code>size</code>）。</li>
</ul>
<p>4.calloc申请		两个参数，申请内存被初始化位0</p>
<p><strong>功能</strong>：为 <code>n</code> 个大小为 <code>size</code> 字节的元素分配内存（总大小：<code>n * size</code>），并将所有字节 <strong>初始化为 0</strong>。<br>
<strong>特点</strong>：</p>
<ul>
<li>内存会被自动初始化为 0（适合需要初始值为 0 的场景，如数组）。</li>
<li>需要两个参数：元素个数 <code>n</code> 和每个元素的大小 <code>size</code>（更直观地为数组分配内存）。</li>
</ul>
<p>5.realloc扩容</p>
<p>realloc函数返回的是函数扩容后新的内存起点</p>
<p><strong>功能</strong>：修改已通过<code>malloc</code>/<code>calloc</code>/<code>realloc</code>分配的内存块的大小（扩大或缩小）。<br>
<strong>特点</strong>：</p>
<ul>
<li>第一个参数<code>ptr</code>必须是之前通过<code>malloc</code>/<code>calloc</code>/<code>realloc</code>分配的指针（或<code>NULL</code>）。</li>
<li>若<code>ptr</code>为<code>NULL</code>，则<code>realloc(NULL, new_size)</code> 等价于 <code>malloc(new_size)</code>。</li>
<li>调整后会尽可能保留原内存中的数据（缩小内存时，超出部分的数据会丢失）。</li>
<li>若原内存块附近有足够空间，会直接在原位置扩展；否则会分配新内存块，复制原数据，释放旧块，并返回新指针。</li>
</ul>
<p><strong>realloc函数使用原理</strong></p>
<p><strong>①原内存空间后有足够的空间</strong></p>
<p>此时返回地址不变，原内存空间像内存高地址扩容</p>
<p><strong>②原内存空间后没有足够的空间</strong></p>
<p>此时返回<strong>新地址</strong>，在realloc函数内将原内存空间的数据拷贝到新开辟的内存空间中，相当于malloc新空间后再使用循环复制数据，后在realloc函数内自动释放原内存。</p>
<p><strong>③扩容失败</strong></p>
<p>返回NULL需根据情况看是否释放原内存，此时原地址任然存在并可用。</p>
<p>**注意：**在使用内存操作函数时最后必须free申请的内存防止内存泄漏。</p>
<p>注意realloc函数在使用时由于不知道那种情况因此在判断扩容是否成功后<strong>使用中间变量接受新指针</strong>，避免原指针被污染，最初malloc开设的动态内存由自己决定要不要释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BankCards* q = (BankCards*)<span class="built_in">realloc</span>(BankS-&gt;pcards, <span class="number">2</span> * (cardnum * <span class="keyword">sizeof</span>(BankCards)));</span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;内存不足扩容失败\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">BankS-&gt;pcards = q;</span><br><span class="line">q = <span class="literal">NULL</span>;<span class="comment">//要在释放或使用后将其置空预防野指针</span></span><br></pre></td></tr></table></figure>
<p>在释放该空间后要将该指针赋值为空p=NULL避免</p>
<p><strong>6.free出现奔溃的原因</strong></p>
<p>①对同一份内存多次释放，因此在释放完内存后要将指针置空。</p>
<p>②释放的时是非堆区空间。</p>
<p>③free的不是堆区空间起始地址</p>
<p>④释放部分动态分配的内存</p>
<p>⑤内存访问越界</p>
<p>⑥未初始化指针，野指针不能free</p>
<p><strong>7.free如何知道释放内存大小的</strong></p>
<p>在动态申请内存后在返回你的指针地址的前几个字节会有<strong>指针头</strong>指针头内记录了该内存空间的大小（size），和校验码（magic）</p>
<p><strong>第二点堆区申请内存会在返回地址的前几个字节（指针头）存储该内存的size大小和magic校验码</strong></p>
<p><strong>动态申请的时候申请了两部分在返回指针前面为指针头后面为申请的空间</strong></p>
<h3 id="11-相同字符串常量在内存中只有一份">11.相同字符串常量在内存中只有一份</h3>
<p>字符串常量存储在内存的只读区域中</p>
<p>数据区存储字符串不可修改只可读</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\t%p\n&quot;</span>, &amp;p1,&amp;p2); <span class="comment">//p1,p2结果相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> p3[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> p4[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\t%p\n&quot;</span>, &amp;p3,&amp;p4); <span class="comment">//p3,p4结果不同</span></span><br></pre></td></tr></table></figure>
<h3 id="12-结构体类型">12.结构体类型</h3>
<p>结构体是不同数据类型的集合，使用结构体可以便于复杂对象的定义；</p>
<p>1.设计：有名结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>;</span><br><span class="line">    数据类型 成员<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ... 更多成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  &#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>;	<span class="comment">//无名结构体</span></span><br><span class="line">    数据类型 成员<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ... 更多成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方式1：顺序初始化（按成员定义顺序赋值）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">95.5</span>&#125;;<span class="comment">//①定义时直接赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2：指定成员初始化（不依赖顺序，更灵活）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu2</span> =</span> &#123;</span><br><span class="line">        .name = <span class="string">&quot;Bob&quot;</span>,	<span class="comment">//②通过访问结构体里的成员逐个赋值</span></span><br><span class="line">        .id = <span class="number">1002</span>,</span><br><span class="line">        .score = <span class="number">88.0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//方式3：strcpy（）函数/memcpy函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.访问通过  <strong>.</strong>  访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接上面的示例</span></span><br><span class="line"><span class="comment">// 访问stu1的成员并修改</span></span><br><span class="line">stu1.score = <span class="number">96.0</span>;  <span class="comment">// 修改成绩</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学号：%d，姓名：%s，成绩：%.1f\n&quot;</span>, </span><br><span class="line">       stu1.id, stu1.name, stu1.score);  <span class="comment">// 输出：1001 Alice 96.0</span></span><br></pre></td></tr></table></figure>
<p>4.结构体的嵌套</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义&quot;地址&quot;结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Address</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> city[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> street[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义&quot;学生&quot;结构体（嵌套Address）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Address</span> <span class="title">addr</span>;</span>  <span class="comment">// 嵌套结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化嵌套结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">        .id = <span class="number">1001</span>,</span><br><span class="line">        .name = <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">        .addr = &#123;.city = <span class="string">&quot;Beijing&quot;</span>, .street = <span class="string">&quot;Main St&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问嵌套结构体的成员（多级.运算符）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生地址：%s，%s\n&quot;</span>, stu.addr.city, stu.addr.street);</span><br><span class="line">    <span class="comment">// 输出：Beijing，Main St</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定义结构体时不能嵌套自身，因为此时自身时不完整的数据类型，不知道其自身大小。但可以包含自身类型的指针</strong></p>
<p>5.typedef重命名结构体	更方便使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuSystem</span> &#123;</span></span><br><span class="line">	student stus[studentcount];</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;stuSystem;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    stuSystem s;<span class="comment">//使用typedef</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stuSystem</span> <span class="title">w</span>;</span><span class="comment">//不使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.结构体与数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> studentcount 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">address</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> province[SIZE];</span><br><span class="line">	<span class="type">char</span> city[SIZE];</span><br><span class="line">	<span class="type">char</span> county[SIZE];</span><br><span class="line">&#125;addres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> studentnum;</span><br><span class="line">	<span class="type">int</span> password;</span><br><span class="line">	address daaress1;</span><br><span class="line">&#125;student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stuSystem</span> &#123;</span></span><br><span class="line">	student stus[studentcount];</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;stuSystem;</span><br><span class="line">stuSystem* <span class="title function_">InitList</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	stuSystem* syu1 = (stuSystem*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stuSystem));</span><br><span class="line">	<span class="keyword">if</span> (syu1 == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	syu1-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> syu1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中有一个stuSystem结构体此结构体中又包含10个student结构体，访问每个学生	**syu1-&gt;stus[i]**可以通过下标访问，也可以通过指针取地址进行指针访问</p>
<p>7.结构体与指针</p>
<p>①通过对指针解引用点访问元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（*syu1).stus[i];</span><br></pre></td></tr></table></figure>
<p>②通过结构体指针专门运算符访问		<strong>-&gt;</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syu1-&gt;stus[size].daaress1.province</span><br></pre></td></tr></table></figure>
<p>8.内存对齐		<strong>面试题</strong></p>
<p>①为什么要内存对齐？</p>
<p>内存对齐是数据起始地址在计算机按照一定规则进行排列</p>
<p>优势：提高cpu效率</p>
<p>内存划分的基本单位是字节，cpu读取内存时并不是按照逐字节读取，一般会以2B，4B，8B的倍数来读取内存块。</p>
<p>数据存储遵循内存读取方式，一次cpu读取周期可完整获取数据；若存储不遵循，则多次cpu读取周期读取字节快拼凑完整数据，读取效率不高。</p>
<p><strong>windows默认对齐方式8B，LInux默认对其方式4B</strong></p>
<p><strong>#pragma pack() 指定对齐方式起始结构体设计此处</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)<span class="comment">//指定对齐方式起始结构体设计此处</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">//上述对齐方式结束位置以下结构体设计恢复默认对齐方式</span></span></span><br></pre></td></tr></table></figure>
<p>9.结构体求大小</p>
<p>当前成员变量的起始位置的偏移量，必须是MIN{当前成员变量类型，对齐方式}的整数倍<br>
计算出上述偏移量总字节数，必须是MIN{当前成员最大基本数据类型，对齐方式}的整数倍</p>
<p>解决结构体嵌套：结构体变量的首地址，必须是MIN{该结构体变量中最大基本数据类型，对齐方式}的整数倍</p>
<p>10.位段（位域）</p>
<p>位段通过在结构体成员后添加 <code>: 位数</code> 来指定该成员占用的二进制位数，语法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    类型 成员名<span class="number">1</span>: 位数<span class="number">1</span>;</span><br><span class="line">    类型 成员名<span class="number">2</span>: 位数<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过限制成员的位数，减少内存占用。</p>
<p>示例；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个位段结构体，存储用户状态信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserStatus</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> is_vip: <span class="number">1</span>;    <span class="comment">// 是否VIP（0/1），占1位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> level: <span class="number">3</span>;     <span class="comment">// 等级（0-7），占3位（2³=8足够）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> login: <span class="number">1</span>;     <span class="comment">// 是否登录（0/1），占1位</span></span><br><span class="line">    <span class="comment">// 总位数：1+3+1=5位，可存储在1个字节（8位）中</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UserStatus</span> <span class="title">user</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值（不能超过位数限制，否则会截断）</span></span><br><span class="line">    user.is_vip = <span class="number">1</span>;    <span class="comment">// 合法（1位最大为1）</span></span><br><span class="line">    user.level = <span class="number">5</span>;     <span class="comment">// 合法（3位最大为7）</span></span><br><span class="line">    user.login = <span class="number">1</span>;     <span class="comment">// 合法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结构体大小（通常为1字节，因5位 ≤8位）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UserStatus大小：%zu 字节\n&quot;</span>, <span class="keyword">sizeof</span>(user));  <span class="comment">// 输出：1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出成员值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VIP: %d, 等级: %d, 登录状态: %d\n&quot;</span>, </span><br><span class="line">           user.is_vip, user.level, user.login);  <span class="comment">// 输出：1,5,1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存分配规则：</p>
<ol>
<li><strong>同类型成员打包</strong>：同一类型的位段成员通常从同一个字节开始存储，若当前字节剩余位数足够，就紧凑存储；若不足，则使用下一个新字节。<br>
例：<code>unsigned int a:4; unsigned int b:4;</code> 通常共占 1 字节（4+4=8 位）。</li>
<li><strong>不同类型成员</strong>：不同类型的位段成员可能从新的字节开始存储（编译器差异较大）。</li>
<li><strong>总大小对齐</strong>：整个位段结构体的总大小需满足其最大成员类型的对齐要求（例如，若成员类型为 <code>int</code>，则总大小是 <code>int</code> 大小的整数倍）。</li>
<li><strong>零长度位段</strong>：可以用 <code>unsigned int :0;</code> 强制下一个位段从新的字节开始存储，用于手动分隔字节。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> :<span class="number">0</span>;  <span class="comment">// 强制下一个成员从新字节开始</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b:<span class="number">4</span>;  <span class="comment">// 存储在新字节中</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小通常为2字节（a占前4位，b占后4位，中间因0长度位段分隔）</span></span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li><strong>不能取地址</strong>：位段成员可能没有对齐到字节边界，因此不能使用 <code>&amp;</code> 运算符获取其地址（编译报错）。</li>
<li><strong>位数限制</strong>：赋值时若超过位段的最大范围，会自动截断（只保留低位）。例如 <code>unsigned int a:2; a=5;</code> 实际存储 <code>5 &amp; 0b11 = 1</code>。</li>
<li><strong>符号问题</strong>：若位段类型为 <code>signed int</code>，最高位会被视为符号位，实际表示范围会缩小。例如 <code>signed int a:3;</code> 范围是 <code>-4 ~ 3</code>（而非 <code>0~7</code>）。</li>
<li><strong>编译器差异</strong>：位段的内存布局（如是否跨字节存储、不同类型成员的分配方式）在不同编译器中可能不同，导致移植性较差。</li>
</ul>
<h3 id="13-与字符串有关的函数">13.与字符串有关的函数</h3>
<ol>
<li>
<h4 id="求字符串长度：strlen"><strong>求字符串长度：strlen</strong></h4>
</li>
</ol>
<ul>
<li>功能：计算字符串中有效字符的长度（不包含结尾的 <code>'\0'</code>）。</li>
<li>原型：<code>size_t strlen(const char *s);</code></li>
<li>参数：<code>s</code> 为字符串首地址。</li>
<li>返回值：字符串的长度（<code>size_t</code> 类型，无符号整数）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度：%zu\n&quot;</span>, <span class="built_in">strlen</span>(str)); <span class="comment">// 输出 5（&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;共5个字符）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-字符串复制：strcpy-与-strncpy"><strong>2.字符串复制：<code>strcpy</code> 与 <code>strncpy</code></strong></h4>
<ul>
<li><strong><code>strcpy</code></strong>：无长度限制的字符串复制（存在缓冲区溢出风险）。
<ul>
<li>原型：<code>char *strcpy(char *dest, const char *src);</code></li>
<li>功能：将 <code>src</code> 指向的字符串（包含 <code>'\0'</code>）复制到 <code>dest</code> 指向的内存。</li>
<li>注意：需保证 <code>dest</code> 缓冲区足够大，否则会溢出。</li>
<li>
<pre><code class="language-c">char* my_strcpy(char* dest, const char* src) &#123;
    // 保存目标字符串的起始地址，用于返回
    char* result = dest;

    // 逐个复制字符，直到遇到源字符串的终止符'\0'
    while ((*dest++ = *src++) != '\0');

    // 返回目标字符串的起始地址
    return result;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- **`strncpy`**：带长度限制的字符串复制（更安全）。</span><br><span class="line">  </span><br><span class="line">  - 原型：`char *strncpy(char *dest, const char *src, size_t n);`</span><br><span class="line">  - 功能：最多复制 `n` 个字符从 `src` 到 `dest`。</span><br><span class="line">  - 注意：若 `src` 长度超过 `n`，则不会自动添加 `&#x27;\0&#x27;`；若不足 `n`，则剩余部分用 `&#x27;\0&#x27;` 填充。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">char dest[20];</span><br><span class="line">char src[] = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">strcpy(dest, src); // 复制整个src到dest（需保证dest足够大）</span><br><span class="line">strncpy(dest, src, 5); // 复制前5个字符（&quot;hello&quot;），若src更长则不补&#x27;\0&#x27;</span><br><span class="line">dest[5] = &#x27;\0&#x27;; // 手动补终止符（推荐）</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-strcat-与-strncat"><strong>3.<code>strcat</code> 与 <code>strncat</code></strong></h4>
<ul>
<li>
<p><strong><code>strcat</code></strong>：无长度限制的字符串拼接（风险同 <code>strcpy</code>）。</p>
<ul>
<li>原型：<code>char *strcat(char *dest, const char *src);</code></li>
<li>功能：将 <code>src</code> 字符串追加到 <code>dest</code> 字符串末尾（覆盖 <code>dest</code> 原有的 <code>'\0'</code>，并在新末尾加 <code>'\0'</code>）。</li>
</ul>
</li>
<li>
<p><strong><code>strncat</code></strong>：带长度限制的拼接。</p>
<ul>
<li>原型：<code>char *strncat(char *dest, const char *src, size_t n);</code></li>
</ul>
</li>
<li>
<p>功能：最多追加 <code>n</code> 个字符从 <code>src</code> 到 <code>dest</code>，并自动添加 <code>'\0'</code>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> src[] = <span class="string">&quot; world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(dest, src); <span class="comment">// dest 变为 &quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">strncat</span>(dest, src, <span class="number">3</span>); <span class="comment">// 追加前3个字符，dest 变为 &quot;hellowor&quot;（假设初始为&quot;hello&quot;）</span></span><br></pre></td></tr></table></figure>
<p>当目标字符数组内存容量不够时存在缓冲区溢出（强行写入目标数组之外的内存）导致覆盖其他数据</p>
<h4 id="4-字符串比较：strcmp-与-strncmp">4. 字符串比较：<code>strcmp</code> 与 <code>strncmp</code></h4>
<ul>
<li><strong><code>strcmp</code></strong>：比较两个字符串的全部字符。
<ul>
<li>原型：<code>int strcmp(const char *s1, const char *s2);</code></li>
<li>返回值：
<ul>
<li>若 <code>s1 &gt; s2</code>（按 ASCII 值），返回正数；</li>
<li>若 <code>s1 == s2</code>，返回 0；</li>
<li>若 <code>s1 &lt; s2</code>，返回负数。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>strncmp</code></strong>：比较前 <code>n</code> 个字符。
<ul>
<li>原型：<code>int strncmp(const char *s1, const char *s2, size_t n);</code></li>
<li>功能：仅比较前 <code>n</code> 个字符，结果规则同 <code>strcmp</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strcmp</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>)); <span class="comment">// 负数（&#x27;a&#x27; &lt; &#x27;b&#x27;）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strncmp</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="number">3</span>)); <span class="comment">// 0（前3个字符相同）</span></span><br></pre></td></tr></table></figure>
<h4 id="5-查找字符-子串：strchr、strrchr、strstr"><strong>5.查找字符 / 子串：<code>strchr</code>、<code>strrchr</code>、<code>strstr</code></strong></h4>
<p><strong><code>strchr</code></strong>：查找字符在字符串中第一次出现的位置。</p>
<p>原型：<code>char *strchr(const char *s, int c);</code></p>
<p>返回值：找到则返回该字符地址，否则返回 <code>NULL</code>。</p>
<p><strong><code>strrchr</code></strong>：查找字符最后一次出现的位置。</p>
<p>原型：<code>char *strrchr(const char *s, int c);</code></p>
<p><strong>strstr`</strong>：查找子串在字符串中第一次出现的位置。</p>
<p>原型：<code>char *strstr(const char *haystack, const char *needle);</code></p>
<p>返回值：找到则返回子串首地址，否则返回 <code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">strchr</span>(str, <span class="string">&#x27;l&#x27;</span>); <span class="comment">// 返回第3个字符（&#x27;l&#x27;）的地址（索引2）</span></span><br><span class="line"><span class="built_in">strrchr</span>(str, <span class="string">&#x27;l&#x27;</span>); <span class="comment">// 返回最后一个&#x27;l&#x27;的地址（索引9）</span></span><br><span class="line"><span class="built_in">strstr</span>(str, <span class="string">&quot;wor&quot;</span>); <span class="comment">// 返回&quot;wor&quot;首地址（索引6）</span></span><br></pre></td></tr></table></figure>
<h4 id="6-isdigit（c）判断该字符是不是数字字符-ctype-h头文件中">6.isdigit（c）	判断该字符是不是数字字符	<a target="_blank" rel="noopener" href="//ctype.xn--h-lq6a0yx14azpp">//ctype.h头文件中</a></h4>
<p>isblank（c）	 判断该字符是不是空格</p>
<p>isalpha（c）	 判断该字符是不是字母</p>
<h4 id="7-strtok函数">7.strtok函数</h4>
<p>在 C 语言中，<code>strtok</code>函数用于将字符串按照指定的分隔符分割成一系列子串（称为 “标记”），定义在头文件 <code>&lt;string.h&gt;</code> 中。它是字符串处理中常用的工具函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;apple,banana;orange grape&quot;</span>;  <span class="comment">// 注意：必须是可修改的数组（不能是常量字符串）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> delim[] = <span class="string">&quot;,; &quot;</span>;  <span class="comment">// 分隔符集合：逗号、分号、空格</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次调用：传入原始字符串</span></span><br><span class="line">    <span class="type">char</span> *token = strtok(str, delim);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环获取所有标记</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到标记：%s\n&quot;</span>, token);</span><br><span class="line">        <span class="comment">// 后续调用：传入NULL，继续分割</span></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);<span class="comment">//strtok里有一个全局变量存储上一次分割位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">找到标记：apple</span><br><span class="line">找到标记：banana</span><br><span class="line">找到标记：orange</span><br><span class="line">找到标记：grape</span><br></pre></td></tr></table></figure>
<h4 id="8-字符串查找算法BF算法"><strong>8.字符串查找算法BF算法</strong></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* sub, <span class="type">const</span> <span class="type">char</span>* son)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sub == <span class="literal">NULL</span> || son == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (sub[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; son[j] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (sub[i] == son[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			j = <span class="number">0</span>;</span><br><span class="line">			i = i - j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sub[i] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,atoi(<span class="string">&quot;00001234&quot;</span>));</span><br><span class="line">	<span class="comment">//printf(&quot;%d\n&quot;, BF(&quot;&quot;,&quot;&quot;));</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-内存操作函数">14.内存操作函数</h3>
<h4 id="1-内存复制：memcpy-与-memmove"><strong>1.内存复制：<code>memcpy</code> 与 <code>memmove</code></strong></h4>
<ul>
<li>
<p><strong><code>memcpy</code></strong>：复制内存块（不处理重叠内存）。</p>
<ul>
<li>原型：<code>void *memcpy(void *dest, const void *src, size_t n);</code></li>
<li>功能：从 <code>src</code> 复制 <code>n</code> 个字节到 <code>dest</code>。</li>
<li>注意：若 <code>src</code> 和 <code>dest</code> 内存重叠，结果未定义。</li>
</ul>
</li>
<li>
<p><strong><code>memmove</code></strong>：复制内存块（处理重叠内存，更安全）。</p>
<ul>
<li>原型：<code>void *memmove(void *dest, const void *src, size_t n);</code>参数传的是指针或地址</li>
<li>功能：同 <code>memcpy</code>，但通过临时缓冲区处理重叠内存，结果可靠。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(arr2, arr1, <span class="keyword">sizeof</span>(arr1)); <span class="comment">// 复制整个arr1到arr2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理重叠内存（如将arr1[0..2]复制到arr1[1..3]）</span></span><br><span class="line">memmove(arr1 + <span class="number">1</span>, arr1, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 安全，结果为&#123;1,1,2,3,5&#125;</span></span><br></pre></td></tr></table></figure>
<p>memcpy和memmove都能实现内存拷贝</p>
<p>1.原地址和目标地址不存在内存相互独立时，两者都可以选择</p>
<p>2.若原地址和目标地址存在内存重叠</p>
<p>①目标地址低于原地址	两个函数都可以选择  优先mommove<br>
实现 逐字节由源地址向目标地址 逐字节拷贝</p>
<p>②目标地址高于高于原地址 	禁止使用memcpy</p>
<p>实现 逐字节由源地址向目标地址 逐字节拷贝</p>
<p>memcpy的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="comment">//保存目标地址，用于返回</span></span><br><span class="line">	<span class="type">char</span>* d = (<span class="type">char</span>*)dest;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* s = (<span class="type">const</span> <span class="type">char</span>*)src;</span><br><span class="line">	<span class="comment">//逐字节复制</span></span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		*d++ = *s++;<span class="comment">//先复制当前字节，在移动指针</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>memmove内添加了原地址 和 目标地址是低地址和高地址的判断 对应不同的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">my_memmove</span><span class="params">(<span class="type">void</span>* aim, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">	<span class="type">char</span>* a = (<span class="type">char</span>*)aim;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* s = (<span class="type">const</span> <span class="type">char</span>*)src;</span><br><span class="line">	<span class="keyword">if</span> (s == a)<span class="comment">//如果s=a则直接返回</span></span><br><span class="line">		<span class="keyword">return</span> aim;</span><br><span class="line">	<span class="keyword">if</span> (s &gt; a) &#123;     <span class="comment">//如果原地址在目标地址之前（无重叠情况）从前往后复制</span></span><br><span class="line">		<span class="keyword">while</span> (n--)</span><br><span class="line">			*a++ = *s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;			<span class="comment">//原地址在目标地址之后（有重叠情况） 从后往前复制</span></span><br><span class="line">		s += n - <span class="number">1</span>; <span class="comment">//更改指针位置</span></span><br><span class="line">		a += n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">			*a-- = *s--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> aim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>memcpy在vs中也可处理内存重叠的原因？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;arr[<span class="number">3</span>],&amp;arr[<span class="number">2</span>],<span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在VS2019memcpy做了超出C标准的扩展实现,而非memcpy本身的标准行为,这一现象并非“内存重叠错误不存在”，而是编译器的特定实现掩盖了标准中 “未定义行为” 的风险。</strong></p>
<h4 id="2-内存设置：memset">2. 内存设置：<code>memset</code></h4>
<ul>
<li>功能：将内存块的前 <code>n</code> 个字节设置为指定值。</li>
<li>原型：<code>void *memset(void *s, int c, size_t n);</code></li>
<li>参数：<code>s</code> 为内存首地址，<code>c</code> 为要设置的字节值（通常用 ASCII 码），<code>n</code> 为字节数。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="string">&#x27;a&#x27;</span>, <span class="number">5</span>); <span class="comment">// 前5个字节设为&#x27;a&#x27;，结果：&quot;aaaaa????&quot;（?为未初始化值）</span></span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str)); <span class="comment">// 清零整个数组（常用初始化方式）</span></span><br></pre></td></tr></table></figure>
<h4 id="3-内存比较：memcmp">3. 内存比较：<code>memcmp</code></h4>
<ul>
<li>功能：比较两个内存块的前 <code>n</code> 个字节。</li>
<li>原型：<code>int memcmp(const void *s1, const void *s2, size_t n);</code></li>
<li>返回值：同 <code>strcmp</code>（按字节 ASCII 值比较）。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">memcmp</span>(a, b, <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 比较前2个整数（4字节/个，共8字节），返回负数（2 &lt; 4）</span></span><br></pre></td></tr></table></figure>
<h3 id="15-assert">15.assert</h3>
<p><strong>此为断言函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(syu1 != <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>当 <code>assert(表达式)</code> 中的<strong>表达式结果为假（0）*<em>时，程序会*<em>终止运行</em></em>，并输出包含</strong>断言失败的表达式、所在文件名、行号**的错误信息；若表达式为真，<code>assert</code> 无任何操作，程序继续执行。</p>
<p><strong>关键特性</strong></p>
<ol>
<li><strong>仅调试模式生效</strong></li>
</ol>
<p><code>assert</code> 依赖宏 <code>NDEBUG</code>（Release 模式下通常会定义 <code>NDEBUG</code>）。若 <code>NDEBUG</code> 已定义，<code>assert</code> 会被编译器<strong>完全优化掉</strong>（无任何运行时开销）。</p>
<ul>
<li>调试模式（Debug）：<code>assert</code> 生效，用于捕捉错误。</li>
<li>发布模式（Release）：<code>assert</code> 失效，需通过其他方式（如 <code>if-else</code>）处理运行时错误</li>
</ul>
<p>2.<strong>错误信息明确</strong></p>
<p>断言失败时，程序会输出类似以下的信息（格式因编译器 / 系统而异）：</p>
<p>直接定位到<strong>失败的表达式、代码文件、行号</strong>，便于快速调试。</p>
<h3 id="16-联合体">16.联合体</h3>
<p>1.联合体</p>
<p>union	联合体名{</p>
<p>}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> stu_id;	<span class="comment">//4B</span></span><br><span class="line">	<span class="type">int</span> tea_id; <span class="comment">//4B	</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.联合体和结构体的区别</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">结构体（struct)</th>
<th style="text-align:center">联合体（union)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">内存分配</td>
<td style="text-align:center">各成员独立占用内存，总大小 ≥ 成员大小之和</td>
<td style="text-align:center">所有成员共享内存，总大小 = 最大成员大小</td>
</tr>
<tr>
<td style="text-align:center">成员有效性</td>
<td style="text-align:center">所有成员可同时有效</td>
<td style="text-align:center">同一时间只有一个成员有效</td>
</tr>
<tr>
<td style="text-align:center">用途</td>
<td style="text-align:center">组合关联数据（如学生信息）</td>
<td style="text-align:center">节省内存或访问同内存的不同表示</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> student_id;	<span class="comment">//4B</span></span><br><span class="line">	<span class="type">int</span> class_id;	<span class="comment">//4B</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中每个元素是单独存在的属性相互独立，student 结构体占8B。</p>
<p>而stu联合体只占4B，<strong>两个变量共享一块内存空间</strong>，使用联合体定义变量其内存空间取决于其联合体内元素<strong>最大值</strong>。</p>
<p><strong>每次只能使用其中一个变量</strong>，<strong>每次只能访问一个成员，当修改一个成员的值，其他成员的值也会被覆盖。</strong></p>
<p>联合体的初始化只能对其中第一个成员初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">stu</span> <span class="title">stu</span>=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这只能将stu_id初始化为10；</p>
<p>3.<strong>大小端问题</strong>（计算机中数据存储的两种方式，主要区别是数据的字节序-&gt;<strong>字节在内存中存储的顺序</strong>）</p>
<p>大端模式	高位字节	 数据	 位于内存<strong>低地址</strong></p>
<p>小端模式	 高位字节	 数据	位于内存<strong>高地址</strong></p>
<p>0x1234中        0x34是数据的低位字节，0x12是数据的高位字节对数据贡献最大</p>
<p><strong>验证大小端问题用联合体验证</strong> 	因为<strong>两个变量共享一块内存空间</strong>		第一种联合体验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">	<span class="type">short</span> stu_id;	<span class="comment">//4B</span></span><br><span class="line">	<span class="type">char</span> tea_id[<span class="number">2</span>]; <span class="comment">//4B	</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">stu</span> <span class="title">my</span>;</span></span><br><span class="line">	my.stu_id = <span class="number">0x1234</span>;</span><br><span class="line">	<span class="keyword">if</span> (my.tea_id[<span class="number">0</span>] == <span class="number">0x34</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;小端模式&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;大端模式&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种指针验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">char</span>*p=(<span class="type">char</span>*)&amp;num;	<span class="comment">//P+1能力</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);<span class="comment">//若输出0x34则小端模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>windows系统中运行结果为小端模式</strong></p>
<p>4.解决ip地址问题 1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>  <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b[<span class="number">4</span>];	<span class="comment">//注意符号位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">s</span> <span class="title">st</span>;</span>		<span class="comment">//小端存储</span></span><br><span class="line">    st.a=<span class="number">0b10000000000010110000001100011111</span>;</span><br><span class="line">    <span class="built_in">printf</span>( %d.%d.%d.%d<span class="string">&quot;, s.b[3], s.b[2], s.b[1], s.b[0]);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>2将处理好的ip地址保存数组中进行比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> ip=<span class="number">100000000000101100000011</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="number">0</span>)&#123;</span><br><span class="line">        arr[i++]=ip&amp;<span class="number">0xff</span>;	<span class="comment">//按位与运算</span></span><br><span class="line">        iP&gt;&gt;<span class="number">8</span>;				<span class="comment">//右移操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(buff,<span class="string">&quot;%d.%d.%d.%d&quot;</span>,arr[<span class="number">3</span>],arr[<span class="number">2</span>],arr[<span class="number">1</span>],arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-枚举（enum）本质是整型值">17.枚举（enum）	本质是整型值</h3>
<p><strong>宏定义不能进行值检查，因此在有限数据可以使用枚举类型</strong></p>
<p>枚举优势：在编译阶段进行类型检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名 &#123;</span></span><br><span class="line">    枚举常量<span class="number">1</span>,</span><br><span class="line">    枚举常量<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// ... 更多枚举常量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>枚举名</strong>：自定义名称（如<code>Weekday</code>、<code>Color</code>），用于标识枚举类型。</p>
<p><strong>枚举常量</strong>：枚举中的成员，本质是整数常量（默认从<code>0</code>开始递增），可手动指定值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义&quot;星期&quot;枚举，包含7个常量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> &#123;</span></span><br><span class="line">    Monday,    <span class="comment">// 默认值0</span></span><br><span class="line">    Tuesday,   <span class="comment">// 默认值1</span></span><br><span class="line">    Wednesday, <span class="comment">// 默认值2</span></span><br><span class="line">    Thursday,  <span class="comment">// 默认值3</span></span><br><span class="line">    Friday,    <span class="comment">// 默认值4</span></span><br><span class="line">    Saturday,  <span class="comment">// 默认值5</span></span><br><span class="line">    Sunday     <span class="comment">// 默认值6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举常量（如<code>Monday</code>）本质是整数，默认从<code>0</code>开始，依次递增<code>1</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义&quot;颜色&quot;枚举，手动指定部分值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">    RED = <span class="number">10</span>,   <span class="comment">// 手动指定为10</span></span><br><span class="line">    GREEN,      <span class="comment">// 自动为11（前一个+1）</span></span><br><span class="line">    BLUE = <span class="number">20</span>,  <span class="comment">// 手动指定为20</span></span><br><span class="line">    YELLOW      <span class="comment">// 自动为21（前一个+1）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以手动为枚举常量指定值，未指定的会在前一个基础上递增<code>1</code>：</p>
<p>允许值重复（如<code>RED = 5, GREEN = 5</code>是合法的，但不推荐，易混淆）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：定义枚举后单独声明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">day1</span>, <span class="title">day2</span>;</span>  <span class="comment">// day1和day2是Weekday类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：定义枚举时直接声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125; c1, c2;  <span class="comment">// c1、c2是Color类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：结合typedef定义别名（推荐，简化书写）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SUCCESS,  <span class="comment">// 0：成功</span></span><br><span class="line">    ERROR,    <span class="comment">// 1：错误</span></span><br><span class="line">    TIMEOUT   <span class="comment">// 2：超时</span></span><br><span class="line">&#125; Status;  <span class="comment">// 别名为Status</span></span><br><span class="line"></span><br><span class="line">Status s;  <span class="comment">// 直接用别名声明变量，无需写enum</span></span><br></pre></td></tr></table></figure>
<p><strong>三种定义方式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：定义枚举后单独声明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">day1</span>, <span class="title">day2</span>;</span>  <span class="comment">// day1和day2是Weekday类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：定义枚举时直接声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125; c1, c2;  <span class="comment">// c1、c2是Color类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：结合typedef定义别名（推荐，简化书写）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SUCCESS,  <span class="comment">// 0：成功</span></span><br><span class="line">    ERROR,    <span class="comment">// 1：错误</span></span><br><span class="line">    TIMEOUT   <span class="comment">// 2：超时</span></span><br><span class="line">&#125; Status;  <span class="comment">// 别名为Status</span></span><br><span class="line"></span><br><span class="line">Status s;  <span class="comment">// 直接用别名声明变量，无需写enum</span></span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> &#123;</span></span><br><span class="line">    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">today</span> =</span> Monday;  <span class="comment">// 赋值：today为0（Monday的值）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较操作</span></span><br><span class="line">    <span class="keyword">if</span> (today == Monday) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;今天是周一\n&quot;</span>);  <span class="comment">// 输出：今天是周一</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运算操作（本质是整数）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">tomorrow</span> =</span> today + <span class="number">1</span>;  <span class="comment">// tomorrow为1（Tuesday）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;明天是周%d\n&quot;</span>, tomorrow + <span class="number">1</span>);  <span class="comment">// 输出：明天是周2（注意+1是因为枚举从0开始）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-内存区域">18.内存区域</h3>
<p>根据不同的操作系统，一个进程可能被分配到不同的内存区域去执行。但是不管什么样的操作系统、什么样的计算机架构，进程使用的内存都可以按照功能大致分为以下4个部分:</p>
<p>x86系统/32位windows内存4g（32跟地址总线（寻址能力））</p>
<p><strong>windows内核空间2g用户态2g	linux系统内核空间1g用户态3g</strong></p>
<p><strong>0~128M禁止访问区间（指针可以指但不能解引用）</strong>  0x0804 8000</p>
<p>①<strong>代码区 .text</strong>:这个区域存储着被装入执行的二进制机器代码，处理器(CUP)会到这个区域取指并执行</p>
<p>②<strong>数据区 .data</strong>:用于存储全局变量，静态全局变量，静态局部变量，字符串常量等。</p>
<p>③<strong>堆区 .heap</strong>:进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。<strong>低地址——&gt;高地址</strong>	windows 1.5g~1.9g之间（和硬件有关）</p>
<p>④<strong>栈区.stack</strong>:函数被调时分配栈区，用于存放函数的参数值，局部变量等值;还要动态地存储函数之间的关系，以保证被调用函数在返回时恢复到被调用函数中继续执行。	<strong>高地址——&gt;低地址</strong></p>
<p><strong>内核空间(windows 2g/linux 1g)</strong></p>
<h3 id="19-变量类型">19.变量类型</h3>
<p><strong>常量分为：	普通常量	宏常量	const修饰的常变量（c语言中是变量的属性，c++中可以用直接赋予其常量的属性）</strong></p>
<p><strong>全局变量在函数外声明，局部变量在函数内声明</strong></p>
<p>结构体只有在定义变量赋值时才占用内存空间</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用域</th>
<th>生命周期</th>
<th>存储位置</th>
<th>初始化默认值</th>
<th>跨文件访问（链接属性）</th>
</tr>
</thead>
<tbody>
<tr>
<td>局部变量</td>
<td>函数 / 复合语句内</td>
<td>函数调用期间</td>
<td>栈区</td>
<td>随机值</td>
<td>否</td>
</tr>
<tr>
<td>全局变量</td>
<td>从声明处到整个文件（可跨文件）</td>
<td>程序运行期间</td>
<td>数据区</td>
<td>0</td>
<td>可（extern）</td>
</tr>
<tr>
<td>静态全局变量</td>
<td>从声明处到当前文件</td>
<td>程序运行期间</td>
<td>数据区</td>
<td>0</td>
<td>否</td>
</tr>
<tr>
<td>静态局部变量</td>
<td>函数内</td>
<td>程序运行期间</td>
<td>数据区</td>
<td>0</td>
<td>否</td>
</tr>
<tr>
<td>字符串常量</td>
<td>整个程序（通过指针访问）</td>
<td>程序运行期间</td>
<td>只读数据区</td>
<td>无（固定值）</td>
<td>否（只读）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">类型名称</th>
<th style="text-align:center">位数（典型）</th>
<th style="text-align:center">有符号（signed）范围</th>
<th style="text-align:center">无符号（unsigned）范围</th>
<th style="text-align:center">范围说明（数学表达式）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>字符型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code>（符号性依赖编译器）</td>
<td style="text-align:center">8</td>
<td style="text-align:center">通常同<code>signed char</code></td>
<td style="text-align:center">若为无符号则同<code>unsigned char</code></td>
<td style="text-align:center">取决于编译器（多数为 - 2⁷～2⁷-1 或 0～2⁸-1）</td>
</tr>
<tr>
<td style="text-align:center"><code>signed char</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">-128 ～ 127</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-2⁷ ～ 2⁷-1（补码表示）</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned char</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0 ～ 255</td>
<td style="text-align:center">0 ～ 2⁸-1</td>
</tr>
<tr>
<td style="text-align:center"><strong>短整型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>short</code> / <code>signed short</code></td>
<td style="text-align:center">16</td>
<td style="text-align:center">-32768 ～ 32767</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-2¹⁵ ～ 2¹⁵-1</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned short</code></td>
<td style="text-align:center">16</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0 ～ 65535</td>
<td style="text-align:center">0 ～ 2¹⁶-1</td>
</tr>
<tr>
<td style="text-align:center"><strong>基本整型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code> / <code>signed int</code></td>
<td style="text-align:center">32</td>
<td style="text-align:center">-2147483648 ～ 2147483647</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-2³¹ ～ 2³¹-1</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned int</code></td>
<td style="text-align:center">32</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0 ～ 4294967295</td>
<td style="text-align:center">0 ～ 2³²-1</td>
</tr>
<tr>
<td style="text-align:center"><strong>长整型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>long</code> / <code>signed long</code></td>
<td style="text-align:center">32（32 位系统）/ 64（64 位系统）</td>
<td style="text-align:center">-2147483648 ～ 2147483647（32 位） -9223372036854775808 ～ 9223372036854775807（64 位）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">32 位：-2³¹ ～ 2³¹-1 64 位：-2⁶³ ～ 2⁶³-1</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center">32（32 位系统）/ 64（64 位系统）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0 ～ 4294967295（32 位） 0 ～ 18446744073709551615（64 位）</td>
<td style="text-align:center">32 位：0 ～ 2³²-1 64 位：0 ～ 2⁶⁴-1</td>
</tr>
<tr>
<td style="text-align:center"><strong>长长整型</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>long long</code> / <code>signed long long</code></td>
<td style="text-align:center">64</td>
<td style="text-align:center">-9223372036854775808 ～ 9223372036854775807</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-2⁶³ ～ 2⁶³-1</td>
</tr>
<tr>
<td style="text-align:center"><code>unsigned long long</code></td>
<td style="text-align:center">64</td>
<td style="text-align:center">-</td>
<td style="text-align:center">0 ～ 18446744073709551615</td>
<td style="text-align:center">0 ～ 2⁶⁴-1</td>
</tr>
</tbody>
</table>
<h3 id="20-函数">20.函数</h3>
<p>1.调用机制</p>
<p>局部变量占用的内存空间在程序指向过程中“动态”建立和释放。这种“动态”是通过栈由系统自动管理进行。</p>
<p>当调用一个函数时</p>
<p>①建立栈帧空间</p>
<p>②主函数运行状态和返回地址入栈</p>
<p>③进行实参和形参的结合，同时形参获得存储空间，接着给局部变量分配空间</p>
<p>④执行被调函数体</p>
<p>⑤被调函数执行完成，释放被调函数中局部变量占用的栈空间		<strong>//由寄存器传递值</strong></p>
<p>⑥取主函数运行状态及返回地址，释放栈帧空间</p>
<p>⑦继续主函数后续语句</p>
<p>2.作用域</p>
<p>3.定义</p>
<p>返回值	函数名(形参列表){</p>
<p>}</p>
<p>4.使用之前需要定义或者声明函数</p>
<p>返回值类型 a=函数名（实参列表）</p>
<p>5.<strong>extern</strong>	<strong>关键字</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;		<span class="comment">//在项目其他文件中定义过a；</span></span><br><span class="line">a=<span class="number">10</span>;		<span class="comment">//相当于链接操作</span></span><br></pre></td></tr></table></figure>
<p>对于函数来说</p>
<p>a.cpp定义过fun函数</p>
<p>b.cpp要用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> fun（）；<span class="comment">//函数声明</span></span><br><span class="line">fun（）；		<span class="comment">//函数调用</span></span><br></pre></td></tr></table></figure>
<p>6.形参改变要影响实参的值（传指针，解引用）</p>
<p>例：交换函数</p>
<p>①封装 形参改变，影响实参的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap(<span class="type">int</span> *a,<span class="type">int</span>*b)&#123;</span><br><span class="line"><span class="type">int</span> temp=*a;</span><br><span class="line">*a=*b;</span><br><span class="line">*b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap(<span class="type">int</span>*arr,<span class="type">int</span> index1,<span class="type">int</span> index2)&#123;</span><br><span class="line"> <span class="type">int</span> temp=arr[index1];</span><br><span class="line"> arr[index1]=arr[index2];</span><br><span class="line"> arr[index2]=temp;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②简单交换两数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位运算异或</span></span><br><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure>
<p>7.传递参数</p>
<p>指针传递：指针只占4B，形参占空间小且需要判空（如果函数功能只便利则加const限定）</p>
<p>值传递：形参复制实参</p>
<p>8.递归函数</p>
<p>①存在自己调用自己</p>
<p>②问题规模不断缩小</p>
<p>③函数必须有退出条件</p>
<p>特点</p>
<p><strong>逐层深入，依次返回</strong></p>
<p>缺点：空间耗费大，算法效率低，同一个子问题可能被重复多次运算，调用次数太多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求5的阶乘</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">jc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> jc(n - <span class="number">1</span>)* n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归其实就是函数调用的过程</strong>   <strong>本质就是问题的分解</strong></p>
<p><strong>要写出递归算法先得分解子问题，找终止条件</strong></p>
<p>两种思维模式</p>
<p>①<strong>遍历的思维</strong>（穷举）</p>
<p>②<strong>分治策略</strong>（分解子问题的思维—–一般来说有返回值</p>
<p>分治策略:是将规模比较大的问题可分割成规模较小的相同问题，问题不变，规模变小。这自然导致递归过程的产生。分治与递归像一对李生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<p><strong>分治法所能解决的问题一般具有以下四个特征:</strong></p>
<p>①该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>②该问题可以分解为若干个规模较小的相同问题,</p>
<p>③使用小规模的解,可以合并成，该问题原规模的解。</p>
<p>④该问题所分解出的各个子规模是相互独立的。</p>
<p><strong>分治法步骤: 在分治策略中递归地求解一个问题，在每层递归中应用如下三个步骤:</strong></p>
<p>①分解:将问题划分成一些子问题，子问题的形式与原问题一样，只是规模更小。</p>
<p>②解决:递归地求解子问题，如果子问题的规模足够小，则停止递归，直接求解</p>
<p>③合井:将小规模的解组合成原规模问题的解，</p>
<p><strong>7.</strong>  <strong>二分查找</strong>（递归和非递归）前提数组有序		********</p>
<p>非递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归的二分查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">twofensearch</span><span class="params">(<span class="type">int</span>* arr,<span class="type">int</span> len,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">	assert(arr != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> right=len<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span> (target == arr[left+(right-left) / <span class="number">2</span> ])</span><br><span class="line">			<span class="keyword">return</span> left + (right-left) / <span class="number">2</span> ;					     <span class="comment">//二分查找非递归方式</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target&lt; arr[left + (right - left) / <span class="number">2</span> ]) &#123;			<span class="comment">//思路：通过左右两指针和中间值与目标值的比较																		不断缩小搜素范围</span></span><br><span class="line">			right = left + (right - left) / <span class="number">2</span><span class="number">-1</span> ;					<span class="comment">//中间值为arr[left + (right - left) / 																									2 ]</span></span><br><span class="line">		&#125;															<span class="comment">//在比较后重新更新左右边界（排除比较过的中间																									元素）</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[left + (right - left) / <span class="number">2</span>]) &#123;			<span class="comment">//到最后左右边界相等时比较的中间元素即为最后																	的元素，若不相等，left&gt;right跳出循环返回-1</span></span><br><span class="line">			left = left + (right - left) / <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">twofensearch0</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len, <span class="type">int</span> target, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (target == arr[mid]) &#123;</span><br><span class="line">		<span class="keyword">return</span> mid;						<span class="comment">//递归的解法就是函数不断被调用，通过每次不同情况下不断跟新函数左右边界不断缩小范围，最终返回值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (target &gt;= arr[mid]) &#123;</span><br><span class="line">		<span class="type">int</span> index = twofensearch0(arr, len, target, mid+<span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> index = twofensearch0(arr, len, target, left, mid+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.log2n的算法效率问题</p>
<p>9.<strong>函数名</strong></p>
<p>两个含义：函数的功能       函数的地址      本质上都是一样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add;  <span class="comment">// 函数功能</span></span><br><span class="line"></span><br><span class="line">&amp;add; <span class="comment">//函数地址</span></span><br></pre></td></tr></table></figure>
<h3 id="21-文件操作">21.文件操作</h3>
<p><strong>绝对路径：</strong> D:/temp/1.txt（全路径）,从根目录开始</p>
<p>相对路径：大纲下的体系		从该项目下路径开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* path1 = <span class="string">&quot;D:/temp/1.txt&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* path2 = <span class="string">&quot;D:\\temp\\1.txt&quot;</span>;	<span class="comment">//&quot;\&quot;在c语言中是转义字符要“\\”</span></span><br></pre></td></tr></table></figure>
<p><strong>1.什么是文件（路径，文件名，后缀）</strong></p>
<p>“文件”指存储在外部介质上数据的集合</p>
<p>一批数据是以文伴的形式存放在外部介质上的</p>
<p>操作系统是以文件为单位对数据进行管理</p>
<p>想找存放在外部介质上的数据，先按文件名找到所指定的文件，然后再从该文件读数据</p>
<p>要向外部介质上存储数据也必须先建立一个文件(以文件名作为标志)，才能向它输出数据</p>
<p><strong>2.数据流	源-&gt;目的端</strong></p>
<p>终端键盘    输入文件</p>
<p>显示屏打印机   输出文件</p>
<p>外存—–&gt;内存	输入流</p>
<p>内存——&gt;外存（文件）      输出流</p>
<p><strong>3.文件的分类</strong></p>
<p>①根据数据组织形式</p>
<p>Ⅰ.ASCII文件（文本文件）字符转化为相应ASCII码以二进制在内存中存储，每一个字节放一个字符的ASCII码，</p>
<p>如果要求在外存上以ASCII码形式存储，则需要在存储前转化。</p>
<p>Ⅱ.二进制文件（多媒体文件）	数据在内存中以二进制存储，不加转换的输出到外存就是二进制文件</p>
<p><strong>4.编码集</strong></p>
<p>GBK（中文）</p>
<p>ASCII字符集（1B)</p>
<p>unicode（2字节）（ASCII的扩展）</p>
<p><strong>5.文件缓冲区</strong>		<strong>刷新：flush	&lt;-&gt;	\n	&lt;-&gt;	程序终止         &lt;-&gt;       缓冲区已满</strong></p>
<p>磁盘—&gt;内存的（输入文件缓冲区）—-&gt;程序数据区</p>
<p>程序数据区—&gt;内存的（输出文件缓冲区）—-&gt;磁盘</p>
<p><strong>6.文件指针</strong></p>
<p>FILE（结构体）</p>
<p>定义一个FILE类型的指针指向文件，通过指针对被指向的文件进行操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE* P1 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>7.打开和关闭文件</strong>（文本文件）</p>
<p><strong>一个文件唯一对应一个  文件描述符</strong>（整型值），打开文件会有资源消耗，因此打开一个文件不用要关闭</p>
<p>windows默认分配1024个文件描述符（可以修改）</p>
<p>对文件读写之前应该“打开”该文件，在使用结束之后应“关闭”该文件。</p>
<p>所谓“打开”是指为文件建立相应的信息区(用来存放有关文件的信息)和文件缓冲区(用来暂时存放输入输出的数据)</p>
<p>在编写程序时，在打开文件的同时，一般都指定一个指针变量指向该文件，也就是建立起指针变量与文件之间的联系，这样就可以通过该指针变量对文件进行读写</p>
<p>所谓“关闭”是指撤销文件信息区和文件缓冲区</p>
<p>①打开	<strong>fopen函数</strong></p>
<p><strong>和文件权限有关系</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE* P1 = <span class="literal">NULL</span>;</span><br><span class="line">P1=fopen(文件名，打开方式); 打开方式（“r”“w“”a“只读，只写，末尾只写）;</span><br></pre></td></tr></table></figure>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> char* path1 = <span class="string">&quot;1.txt&quot;</span>;   			 <span class="comment">//在这个项目路径下找1.txt   相对路径</span></span><br><span class="line"><span class="keyword">const</span> char* path2 = <span class="string">&quot;D:\\temp\\1.txt&quot;</span>;	 <span class="comment">//绝对路径</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE* P1 = <span class="literal">NULL</span>;</span><br><span class="line">FILE* P2 = <span class="literal">NULL</span>;</span><br><span class="line">P1=fopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);   <span class="comment">//以可读方式打开该文件</span></span><br><span class="line">assert(P1!=<span class="literal">NULL</span>);</span><br><span class="line">P2=fopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);	  <span class="comment">//以可写方式打开该文件，看不见该文件内容</span></span><br></pre></td></tr></table></figure>
<p>如果打开失败返回的是NULL；</p>
<p><strong>一般使用相对路径，方便别人使用</strong></p>
<p>②关闭		<strong>fclose函数</strong></p>
<p><strong>关闭文件信息区及文件缓冲区</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	FILE* P1 = <span class="literal">NULL</span>;</span><br><span class="line">	FILE* P2 = <span class="literal">NULL</span>;</span><br><span class="line">	P1 = fopen(<span class="string">&quot;FileName.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>);   <span class="comment">//以可读方式打开该文件</span></span><br><span class="line">	assert(P1 != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//关闭文件</span></span><br><span class="line">	fclose(P1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&quot;r&quot;</code></td>
<td style="text-align:center">只读</td>
<td style="text-align:center">文件必须存在，否则打开失败</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;w&quot;</code></td>
<td style="text-align:center">只写</td>
<td style="text-align:center">若文件存在，则清除原文件内容后写入；否则，创建新文件后写入</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;a&quot;</code></td>
<td style="text-align:center">末尾只写</td>
<td style="text-align:center">若文件存在，位置指针移到文件末尾并追加写入（不删除原数据）；若文件不存在，创建新文件后写入</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;r+&quot;</code></td>
<td style="text-align:center">读写</td>
<td style="text-align:center">文件必须存在，否则打开失败（在 <code>&quot;r&quot;</code> 基础上增加可写功能）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;w+&quot;</code></td>
<td style="text-align:center">读写</td>
<td style="text-align:center">创建新文件，先写入数据，后可读取（会清空已有文件内容）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;a+&quot;</code></td>
<td style="text-align:center">读写</td>
<td style="text-align:center">在 <code>&quot;a&quot;</code> 模式基础上增加可读功能（追加后可读取）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;rb&quot;</code></td>
<td style="text-align:center">二进制文件只读</td>
<td style="text-align:center">功能同 <code>&quot;r&quot;</code>，但以<strong>二进制模式</strong>打开（下同表示后续二进制模式规则类似）</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;wb&quot;</code></td>
<td style="text-align:center">二进制文件只写</td>
<td style="text-align:center">功能同 <code>&quot;w&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;ab&quot;</code></td>
<td style="text-align:center">二进制文件末尾只写</td>
<td style="text-align:center">功能同 <code>&quot;a&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;rb+&quot;</code></td>
<td style="text-align:center">二进制文件读写</td>
<td style="text-align:center">功能同 <code>&quot;r+&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;wb+&quot;</code></td>
<td style="text-align:center">二进制文件读写</td>
<td style="text-align:center">功能同 <code>&quot;w+&quot;</code>，二进制模式</td>
</tr>
<tr>
<td style="text-align:center"><code>&quot;ab+&quot;</code></td>
<td style="text-align:center">二进制文件读写</td>
<td style="text-align:center">功能同 <code>&quot;a+&quot;</code>，二进制模式</td>
</tr>
</tbody>
</table>
<p><strong>其中在使用a/a+模式写入时光标始终在文件末尾，使用r+模式时只能做到替换不能插入</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE* fp = fopen(<span class="string">&quot;文件.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入内容\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buff, <span class="string">&quot;end&quot;</span>) == <span class="number">0</span>) &#123;			<span class="comment">//a/a+模式只能实现文件末尾插入，r+模式搭配fseek函数会覆盖原有内容</span></span><br><span class="line">			<span class="keyword">break</span>;								<span class="comment">//文件操作无法实现直接插入并使后续元素后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		k = <span class="built_in">strlen</span>(buff);</span><br><span class="line">		n = fwrite(buff, <span class="keyword">sizeof</span>(<span class="type">char</span>), k, fp);</span><br><span class="line">		<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>8.文件操作</strong>（顺序读写）</p>
<p>1.fopen 打开文件 --&gt;光标默认在文件开头<br>
2.fread 读文件操作 —&gt;按照字节数读取操作<br>
3.fwrite 写文件—&gt; 字节数<br>
4.fscanf 读文件操作 --&gt;给定读取格式<br>
5.fprintf 写文件操作 --&gt;给定写入格式<br>
6.ftell 统计文件大小<br>
7.fseek 设置光标位置–&gt;（SEEKSET头SEEKCUR当前 SEEK END 尾）</p>
<p>①文件读取	fread函数</p>
<p>返回值是成功读取的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void* ptr</code></td>
<td style="text-align:center">指向<strong>接收数据的缓冲区</strong>的指针（如数组、结构体、动态分配的内存等）。</td>
<td style="text-align:center">需确保缓冲区大小 ≥ <code>size * nmemb</code>，否则可能导致<strong>内存溢出</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t size</code></td>
<td style="text-align:center">单个数据项的<strong>字节大小</strong>（如 <code>sizeof(int)</code> 表示 1 个 <code>int</code> 的字节数）。</td>
<td style="text-align:center">常用 <code>sizeof</code> 计算，避免硬编码（增强可移植性）。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t nmemb</code></td>
<td style="text-align:center">要读取的<strong>数据项数量</strong>（如读 10 个 <code>int</code>，则 <code>nmemb=10</code>）。</td>
<td style="text-align:center">总读取字节数 = <code>size * nmemb</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的<strong>文件流指针</strong>（通过 <code>fopen</code> 获得，需以读模式打开，如 <code>&quot;rb&quot;</code>）。</td>
<td style="text-align:center">必须先成功打开文件，否则行为未定义；模式需匹配（二进制读用 <code>&quot;rb&quot;</code>）。</td>
</tr>
</tbody>
</table>
<p>②文件写入	fwrite函数</p>
<p>返回值是写入成功的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>const void* ptr</code></td>
<td style="text-align:center">指向<strong>要写入的数据</strong>的指针（如数组、结构体、字符串等）。</td>
<td style="text-align:center">数据需提前准备好（如初始化的数组、赋值后的结构体），<code>const</code> 表示不修改源数据。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t size</code></td>
<td style="text-align:center">单个数据项的<strong>字节大小</strong>（如 <code>sizeof(float)</code> 表示 1 个 <code>float</code> 的字节数）。</td>
<td style="text-align:center">推荐用 <code>sizeof</code> 计算（如 <code>sizeof(Student)</code>），避免硬编码，增强可移植性。</td>
</tr>
<tr>
<td style="text-align:center"><code>size_t nmemb</code></td>
<td style="text-align:center">要写入的<strong>数据项数量</strong>（如写 5 个结构体，<code>nmemb=5</code>）。</td>
<td style="text-align:center">总写入字节数 = <code>size * nmemb</code>（需确保文件有足够空间）。</td>
</tr>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的<strong>文件流指针</strong>（通过 <code>fopen</code> 获得，需以写模式打开，如 <code>&quot;wb&quot;</code>）。</td>
<td style="text-align:center">必须先成功打开文件（模式需匹配，如二进制写用 <code>&quot;wb&quot;</code>），否则行为未定义。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	FILE* P1 = <span class="literal">NULL</span>;			<span class="comment">//顺序读写数据</span></span><br><span class="line">	FILE* P2 = <span class="literal">NULL</span>;</span><br><span class="line">	P1 = fopen(<span class="string">&quot;FileName.cpp&quot;</span>, <span class="string">&quot;r&quot;</span>);  <span class="comment">//以可读方式打开该文件</span></span><br><span class="line">	P2 = fopen(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	assert(P1 != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">	<span class="type">size_t</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((num = fread(buff, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">256</span>, P1)) != <span class="number">0</span>) &#123;</span><br><span class="line">		fwrite(buff, <span class="keyword">sizeof</span>(<span class="type">char</span>), num, P2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line">										<span class="comment">//关闭文件</span></span><br><span class="line">	fclose(P1);</span><br><span class="line">	fclose(P2);			<span class="comment">//文件拷贝</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>fscanf    fprintf  针对固定格式用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(文件指针，<span class="string">&quot;%d&quot;</span>,num);</span><br></pre></td></tr></table></figure>
<p>sprintf	重定向函数与文件操作无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buff[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buff,<span class="string">&quot;%d&quot;</span>,num);</span><br></pre></td></tr></table></figure>
<p><strong>9.随机读写</strong></p>
<p>文件：文件头指针       文件尾指针</p>
<p>对文件进行顺序读写比较容易理解，也容易操作，但有时效率不高<br>
随机访问不是按数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数据进行访问</p>
<p><strong>通过fseek函数改变文件标记</strong></p>
<p>可以在任何位置读写数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">取值 / 注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的<strong>文件流指针</strong>（通过 <code>fopen</code> 获得，需支持随机访问）。</td>
<td style="text-align:center">必须是成功打开的文件（如 <code>&quot;rb&quot;</code>、<code>&quot;r+b&quot;</code> 模式，文本模式可能有兼容性问题）。</td>
</tr>
<tr>
<td style="text-align:center"><code>long offset</code></td>
<td style="text-align:center">偏移量（字节数），表示从 <code>whence</code> 位置移动的距离。</td>
<td style="text-align:center">正数：向文件末尾方向移动；负数：向文件开头方向移动。</td>
</tr>
<tr>
<td style="text-align:center"><code>int whence</code></td>
<td style="text-align:center">起始位置（基准点），即从哪里开始计算偏移量，需使用标准宏定义。</td>
<td style="text-align:center">有 3 个合法值： - <code>SEEK_SET</code>：从<strong>文件开头</strong>开始（值为 0）； - <code>SEEK_CUR</code>：从<strong>当前文件指针位置</strong>开始（值为 1）； - <code>SEEK_END</code>：从<strong>文件末尾</strong>开始（值为 2）。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">参照点</th>
<th style="text-align:center">名字</th>
<th style="text-align:center">用数字代表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">文件开始位置</td>
<td style="text-align:center"><code>SEEK_SET</code></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">文件当前位置</td>
<td style="text-align:center"><code>SEEK_CUR</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">文件末尾位置</td>
<td style="text-align:center"><code>SEEK_END</code></td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>用宏常量代替</p>
<p>先使用fseek函数调整写入（读取）指针位置在进行正常的读写操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 以&quot;读写二进制模式&quot;打开（允许读和写，且支持随机访问）</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;nums.bin&quot;</span>, <span class="string">&quot;r+b&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;文件打开失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到第10字节处（假设前10字节是无需修改的内容）</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(fp, <span class="number">10</span>, SEEK_SET) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fseek失败&quot;</span>);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在当前位置写入新数据（覆盖原有内容）</span></span><br><span class="line">    <span class="type">int</span> new_data = <span class="number">999</span>;</span><br><span class="line">    fwrite(&amp;new_data, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;修改成功\n&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ftell函数</strong>	文件位置标记及其定位		<strong>ftell无法操作a模式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>FILE* stream</code></td>
<td style="text-align:center">已打开的文件流指针</td>
<td style="text-align:center">必须是有效且已打开的文件流</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>long</code>返回值</td>
<td style="text-align:center">成功：返回当前指针的偏移字节数（≥0）； 失败：返回 <code>-1</code>（需通过 <code>ferror(stream)</code> 检查错误）。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>); <span class="comment">// 二进制模式（避免文本模式的换行符干扰）</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END); <span class="comment">// 指针移到文件末尾</span></span><br><span class="line">    <span class="type">long</span> file_size = ftell(fp); <span class="comment">// 获取偏移量（即文件大小）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件大小：%ld 字节\n&quot;</span>, file_size);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;大小：%dKB\n&quot;</span>,(<span class="type">int</span>)<span class="built_in">ceil</span>(file_size/<span class="number">1024</span>+<span class="number">1</span>))<span class="comment">//文件大小需要向上取整</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>10.与 <code>fseek</code> 的配合</strong></p>
<p><code>ftell</code> 常与 <code>fseek</code> 配合实现<strong>随机访问</strong>：</p>
<ol>
<li>用 <code>ftell</code> 记录当前位置；</li>
<li>用 <code>fseek</code> 跳转到其他位置读写；</li>
<li>再用 <code>fseek</code> 跳回记录的位置，继续操作。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;data.bin&quot;</span>, <span class="string">&quot;rb+&quot;</span>); <span class="comment">// 读写模式</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录初始位置（文件开头，偏移量为0）</span></span><br><span class="line">    <span class="type">long</span> pos = ftell(fp); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始位置：%ld\n&quot;</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟读写操作，指针移动</span></span><br><span class="line">    fseek(fp, <span class="number">10</span>, SEEK_CUR); <span class="comment">// 指针向后移动10字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前位置：%ld\n&quot;</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳回之前记录的位置</span></span><br><span class="line">    fseek(fp, pos, SEEK_SET); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;跳回后位置：%ld\n&quot;</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-整数转换函数">22.整数转换函数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">函数名称</th>
<th style="text-align:center">参数列表</th>
<th style="text-align:center">参数类型说明</th>
<th style="text-align:center">功能说明</th>
<th style="text-align:center">特点说明</th>
<th style="text-align:center">返回类型</th>
<th style="text-align:center">用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>atoi</code></td>
<td style="text-align:center"><code>const char *str</code></td>
<td style="text-align:center">待转换的字符串（仅支持十进制，忽略前导空白，可带正负号）</td>
<td style="text-align:center">将字符串转换为十进制<code>int</code>类型整数</td>
<td style="text-align:center">简单易用但功能有限；无错误处理（溢出或无效输入时返回 0，无法区分合法 0 和错误）；仅支持十进制</td>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">适用于简单场景，如已知字符串为合法十进制整数时：<code>int num = atoi(&quot;123&quot;);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>atol</code></td>
<td style="text-align:center"><code>const char *str</code></td>
<td style="text-align:center">待转换的字符串（功能同<code>atoi</code>，但支持更大范围）</td>
<td style="text-align:center">将字符串转换为<code>long</code>类型整数</td>
<td style="text-align:center">与<code>atoi</code>功能类似，但支持范围更大（<code>long</code>类型）；同样无错误处理；仅支持十进制</td>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">适用于数值可能超出<code>int</code>范围的场景：<code>long num = atol(&quot;1234567890&quot;);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>strtol</code></td>
<td style="text-align:center"><code>const char *str, char **endptr, int base</code></td>
<td style="text-align:center">1. 待转换字符串 2. 存储未转换部分地址的指针（可设为 NULL） 3. 进制（2-36，0 表示自动检测）</td>
<td style="text-align:center">将字符串转换为<code>long</code>类型整数，支持多进制</td>
<td style="text-align:center">功能强大；支持 2-36 进制（base=0 时自动识别 0x 前缀为 16 进制、0 前缀为 8 进制）；可通过<code>endptr</code>获取未转换部分；溢出时返回<code>LONG_MAX</code>/<code>LONG_MIN</code>并设置<code>errno</code></td>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center">需精确控制转换或处理多进制时使用： <code>char *end;</code> <code>long num = strtol(&quot;0x1A&quot;, &amp;end, 0);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>strtoul</code></td>
<td style="text-align:center"><code>const char *str, char **endptr, int base</code></td>
<td style="text-align:center">同<code>strtol</code></td>
<td style="text-align:center">将字符串转换为<code>unsigned long</code>类型整数，支持多进制</td>
<td style="text-align:center">与<code>strtol</code>功能类似，但返回无符号类型；溢出时返回<code>ULONG_MAX</code>并设置<code>errno</code>；适用于无符号数值</td>
<td style="text-align:center"><code>unsigned long</code></td>
<td style="text-align:center">处理无符号大整数时使用： <code>unsigned long num = strtoul(&quot;123456&quot;, NULL, 10);</code></td>
</tr>
<tr>
<td style="text-align:center"><code>itoa</code>*</td>
<td style="text-align:center"><code>int value, char *str, int base</code></td>
<td style="text-align:center">1. 待转换的整数 2. 存储结果的字符串缓冲区 3. 目标进制（2-36）</td>
<td style="text-align:center">将整数转换为指定进制的字符串</td>
<td style="text-align:center">非标准库函数（依赖编译器，如 VC 支持）；使用简单；直接指定进制即可转换；移植性差</td>
<td style="text-align:center"><code>char*</code></td>
<td style="text-align:center">编译器支持时可快速转换： <code>char buf[20];</code> <code>itoa(255, buf, 16); // 结果为&quot;ff&quot;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>sprintf</code></td>
<td style="text-align:center"><code>char *str, const char *format, ...</code></td>
<td style="text-align:center">1. 存储结果的字符串缓冲区 2. 格式控制字符串（如<code>&quot;%d&quot;</code>十进制、<code>&quot;%x&quot;</code>十六进制）</td>
<td style="text-align:center">通过格式符将整数转换为指定格式的字符串（支持多进制）</td>
<td style="text-align:center">标准库函数，移植性好；支持丰富格式（如<code>%d</code>十进制、<code>%o</code>八进制、<code>%x</code>十六进制）；需手动管理缓冲区大小，存在溢出风险</td>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">需格式化输出时使用： <code>char buf[20];</code> <code>sprintf(buf, &quot;0x%x&quot;, 255); // 结果为&quot;0xff&quot;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>str_to_int</code>**</td>
<td style="text-align:center"><code>const char *str, int base, int *result</code></td>
<td style="text-align:center">1. 待转换字符串 2. 进制（2-36，0 表示自动检测） 3. 存储结果的指针</td>
<td style="text-align:center">将字符串转换为指定进制的<code>int</code>，并返回转换状态</td>
<td style="text-align:center">自定义安全转换函数；明确返回转换状态（成功 / 溢出 / 无效）；支持错误处理；功能介于<code>atoi</code>和<code>strtol</code>之间</td>
<td style="text-align:center"><code>ConvStatus</code></td>
<td style="text-align:center">需要错误处理的场景： <code>int num;</code> <code>if (str_to_int(&quot;123&quot;, 10, &amp;num) == CONV_SUCCESS) &#123; ... &#125;</code></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;  123\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;  123&quot;</span>));       <span class="comment">// 123（忽略前导空格）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;45abc\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;45abc&quot;</span>));     <span class="comment">// 45（遇到非数字停止）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;-67\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;-67&quot;</span>));         <span class="comment">// -67（支持负号）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atoi(\&quot;abc89\&quot;) = %d\n&quot;</span>, atoi(<span class="string">&quot;abc89&quot;</span>));     <span class="comment">// 0（无有效数字）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>atoi的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转整数：处理空白、正负号、非数字字符和溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 空指针处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>; <span class="comment">// 用long long避免计算过程中溢出</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;         <span class="comment">// 符号标记，1为正，-1为负</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 跳过空白字符（空格、制表符、换行符等）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isspace</span>(str[i])) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理正负号</span></span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        sign = (str[i] == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 转换数字字符</span></span><br><span class="line">    <span class="keyword">while</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算当前结果：之前的结果*10 + 新数字</span></span><br><span class="line">        result = result * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 检查溢出（超过int范围）</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; result &gt; INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">-1</span> &amp;&amp; -result &lt; INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(sign * result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>itoa的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数转字符串：处理正负号、0和缓冲区</span></span><br><span class="line"><span class="comment">// 注意：buffer需要足够大（至少12字节，应对INT_MIN和终止符）</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">my_itoa</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> *buffer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空指针处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> is_negative = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n; <span class="comment">// 用unsigned处理INT_MIN的绝对值溢出问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 处理0的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        buffer[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        buffer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理负数</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        is_negative = <span class="number">1</span>;</span><br><span class="line">        n = (<span class="type">unsigned</span> <span class="type">int</span>)(-num); <span class="comment">// 转为无符号避免溢出（INT_MIN的绝对值更大）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = (<span class="type">unsigned</span> <span class="type">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提取数字（逆序存储）</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">        buffer[i++] = digit + <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 数字转字符</span></span><br><span class="line">        n = n / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加负号</span></span><br><span class="line">    <span class="keyword">if</span> (is_negative) &#123;</span><br><span class="line">        buffer[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 添加字符串终止符</span></span><br><span class="line">    buffer[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 反转字符串（因为提取时是逆序）</span></span><br><span class="line">    <span class="type">int</span> len = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len / <span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="type">char</span> temp = buffer[j];</span><br><span class="line">        buffer[j] = buffer[len - <span class="number">1</span> - j];</span><br><span class="line">        buffer[len - <span class="number">1</span> - j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="23-运算符优先级问题">23.运算符优先级问题</h3>
<table>
<thead>
<tr>
<th style="text-align:center">优先级层级</th>
<th style="text-align:center">运算符类别</th>
<th style="text-align:center">具体运算符</th>
<th style="text-align:center">结合性</th>
<th style="text-align:center">核心特点 / 示例</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1（最高）</td>
<td style="text-align:center">括号与成员访问</td>
<td style="text-align:center"><code>()</code>（括号）、<code>[]</code>（数组下标）、<code>-&gt;</code>（结构体指针成员）、<code>.</code>（结构体成员）、<code>++</code>（后缀自增）、<code>--</code>（后缀自减）</td>
<td style="text-align:center">无</td>
<td style="text-align:center">括号强制改变运算顺序；后缀自增 / 自减仅作用于变量本身，如 <code>a++</code>（先使用 a 再自增）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">单目运算符</td>
<td style="text-align:center"><code>!</code>（逻辑非）、<code>~</code>（按位取反）、<code>++</code>（前缀自增）、<code>--</code>（前缀自减）、<code>+</code>（正号）、<code>-</code>（负号）、<code>*</code>（指针解引用）、<code>&amp;</code>（取地址）、<code>sizeof</code>（求大小）、<code>(类型)</code>（强制类型转换）</td>
<td style="text-align:center">右结合</td>
<td style="text-align:center">仅作用于 1 个操作数，如 <code>-a++</code> 等价于 <code>-(a++)</code>；<code>(int)3.14</code>（强制转换为整型）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">算术运算符（高）</td>
<td style="text-align:center"><code>*</code>（乘法）、<code>/</code>（除法）、<code>%</code>（取余）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">先乘除后加减，如 <code>a / b * c</code> 等价于 <code>(a / b) * c</code>；<code>5 % 2</code> 结果为 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">算术运算符（低）</td>
<td style="text-align:center"><code>+</code>（加法）、<code>-</code>（减法）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">如 <code>a + b - c</code> 等价于 <code>(a + b) - c</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">移位运算符</td>
<td style="text-align:center"><code>&lt;&lt;</code>（左移）、<code>&gt;&gt;</code>（右移）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">操作数为二进制位，如 <code>8 &lt;&lt; 1</code> 结果为 16（二进制 <code>1000</code> 左移 1 位为 <code>10000</code>）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">关系运算符（比较）</td>
<td style="text-align:center"><code>&lt;</code>（小于）、<code>&lt;=</code>（小于等于）、<code>&gt;</code>（大于）、<code>&gt;=</code>（大于等于）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">优先级高于 “判断相等”，如 <code>a &gt; b == c</code> 等价于 <code>(a &gt; b) == c</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">关系运算符（相等）</td>
<td style="text-align:center"><code>==</code>（等于）、<code>!=</code>（不等于）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">用于判断值是否相等，如 <code>3 == 5</code> 结果为 0（假）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">位运算符（与）</td>
<td style="text-align:center"><code>&amp;</code>（按位与）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">优先级高于 “异或” 和 “或”，如 `a</td>
<td style="text-align:center">b &amp; c<code>等价于</code>a</td>
<td style="text-align:center">(b &amp; c)`</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">位运算符（异或）</td>
<td style="text-align:center"><code>^</code>（按位异或）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">优先级高于 “按位或”，如 <code>3 ^ 5</code> 结果为 6（二进制 <code>011 ^ 101 = 110</code>）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">位运算符（或）</td>
<td style="text-align:center">`</td>
<td style="text-align:center">`（按位或）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">如 `3</td>
<td style="text-align:center">5<code>结果为7（二进制</code>011</td>
<td style="text-align:center">101 = 111`）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">逻辑运算符（与）</td>
<td style="text-align:center"><code>&amp;&amp;</code>（逻辑与）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">短路求值（左为假则右不执行），如 <code>(a=0) &amp;&amp; (b=1)</code> 中 <code>b</code> 仍为初始值</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">逻辑运算符（或）</td>
<td style="text-align:center">`</td>
<td style="text-align:center"></td>
<td style="text-align:center">`（逻辑或）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">短路求值（左为真则右不执行），如 `(a=1)</td>
<td style="text-align:center"></td>
<td style="text-align:center">(b=0)<code>中</code>b` 仍为初始值</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">条件运算符（三目）</td>
<td style="text-align:center"><code>?:</code>（格式：<code>表达式1 ? 表达式2 : 表达式3</code>）</td>
<td style="text-align:center">右结合</td>
<td style="text-align:center">仅高于赋值和逗号运算符，如 <code>a ? b : c ? d : e</code> 等价于 <code>a ? b : (c ? d : e)</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">赋值运算符</td>
<td style="text-align:center"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、`</td>
<td style="text-align:center">=`</td>
<td style="text-align:center">右结合</td>
<td style="text-align:center">如 <code>a = b += c</code> 等价于 <code>a = (b += c)</code>（先更新 <code>b</code>，再赋值给 <code>a</code>）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">15（最低）</td>
<td style="text-align:center">逗号运算符</td>
<td style="text-align:center"><code>,</code>（表达式分隔符）</td>
<td style="text-align:center">左结合</td>
<td style="text-align:center">取最后一个表达式的值，如 <code>a=1, b=2, c=a+b</code> 结果为 3（<code>c</code> 的值）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="24-c编译链接原理">24.c编译链接原理</h3>
<p><strong>1.预编译：</strong></p>
<p>①宏替换</p>
<p>②头文件展开</p>
<p>③注释删除</p>
<p>④预处理指令解析（assert（舍弃一些代码：release版本注释掉）;#开头的一些指令等等（eg：#if 0 #endif  #pragma pack()等等））</p>
<p>⑤经过预编译阶段	<strong>.c——&gt;.i</strong></p>
<p>**2.编译：**语法  语义解析		经过编译阶段	<strong>.i-----&gt;.s(高级语言——&gt;汇编语言）</strong></p>
<p><strong>3.汇编:</strong></p>
<p>①汇编指令 翻译  二进制指令</p>
<p>②全局变量初始值设定</p>
<p>③符号表的生成（函数名/变量名与函数/变量的存储地址对应关系表）		<strong>.i——&gt;.o(机器码windows（.obj)/linux(.o))</strong>	机器码与cpu架构（硬件架	        构（x86/x64））有关</p>
<p><strong>4.链接</strong>：生成windows(.exe)/linux(无后缀名)	可执行文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如项目中有三个.c文件</span></span><br><span class="line">test1.c--&gt;test1.i--&gt;test1.s--&gt;test1.o---&gt;</span><br><span class="line">test2.c--&gt;test2.i--&gt;test2.s--&gt;test2.o------&gt;text(可执行文件此时在磁盘上)————&gt;需要映射加载到内存上运行</span><br><span class="line">test3.c--&gt;test3.i--&gt;test3.s--&gt;test3.o---&gt;</span><br><span class="line">     预编译 ----&gt; 编译 -----&gt;汇编 -----&gt;链接</span><br></pre></td></tr></table></figure>
<h3 id="25-include引用的区别">25.include引用的区别</h3>
<p>#include &lt;&gt;<br>
#include ” ”</p>
<p>区别:<br>
1)&lt;&gt; 引入的是库的头文件默认查找路径 系统配置路径里</p>
<p>2)&quot;&quot;引入 既可以是库头文件 也可以是 自定义头文件”查询头文件时，先在当前项目路径下寻找.h文件不存在，再到系统配置路径下查找</p>
<p>头文件防止重复包含</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once <span class="comment">//预处理指令</span></span></span><br><span class="line"><span class="comment">//防止头文件被重复引用 -- 绝大部分编译器都支持该指令</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INC_TRAIN  <span class="comment">//此处支持任意编译器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INC_TRAIN</span></span><br><span class="line"><span class="comment">//头文件中内容:函数声明/结构体设计</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !INC_TRAIN解释一下</span></span></span><br></pre></td></tr></table></figure>
<h3 id="26-位操作符">26.位操作符</h3>
<p>1.按位与（&amp;）</p>
<p>有 0 则 0，全 1 才 1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> &amp; <span class="number">3</span>；</span><br><span class="line">    </span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>  （<span class="number">6</span>）</span><br><span class="line">&amp; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>  （<span class="number">3</span>）</span><br><span class="line">-----------</span><br><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>  （<span class="number">2</span>）    </span><br></pre></td></tr></table></figure>
<p>2.按位或（|）</p>
<p>有 1 则 1，全 0 才 0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>  （<span class="number">6</span>）</span><br><span class="line">| <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>  （<span class="number">3</span>）</span><br><span class="line">-----------</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>  （<span class="number">7</span>）</span><br></pre></td></tr></table></figure>
<p>3.按位异或（^)</p>
<p>相同为 0，不同为 1   满足结合律和交换律</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> ^ <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>  （<span class="number">5</span>）</span><br><span class="line">^ <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>  （<span class="number">3</span>）</span><br><span class="line">-----------</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>  （<span class="number">6</span>）  </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个数交换    前提：a和b不在同一块内存，如果在同一块内存则会洗为0</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">a=a^b; <span class="comment">//10^20</span></span><br><span class="line">b=a^b; <span class="comment">//10^20^20 ==10^0=10;</span></span><br><span class="line">a=a^b; <span class="comment">//10^20^10 ==20^0=20;</span></span><br><span class="line"><span class="comment">//a==20   b==10  此时</span></span><br></pre></td></tr></table></figure>
<p>一个数组中有不同的数怎么知道这个数出现了奇数次</p>
<p>[1,2,2,1,1,1,2,2,3,3,3]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> ero=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">	ero^=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,ero);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;  <span class="comment">// 修正数组初始化</span></span><br><span class="line">    <span class="type">int</span> ero = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">// 动态获取数组长度，更灵活</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：计算所有元素的异或结果（即两个目标数的异或）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ero ^= a[i];</span><br><span class="line">    &#125;  <span class="comment">// 此时 ero = 3 ^ 5 = 6（二进制 110）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：提取最右侧的 1（用于区分两个目标数）  ero 的二进制中所有为 1 的位，本质上都是 x 和 y 二进制位不同的位置。</span></span><br><span class="line">    <span class="type">int</span> ero1 = ero &amp; (~ero + <span class="number">1</span>);  <span class="comment">// 结果为 2（二进制 010）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：区分出其中一个目标数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i] &amp; ero1) != <span class="number">0</span>) &#123;  <span class="comment">// 用与运算判断该位是否为 1，更直观</span></span><br><span class="line">            x = a[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 此时 x 为 3 或 5（此处会找到第一个符合条件的 3）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：计算另一个目标数</span></span><br><span class="line">    <span class="type">int</span> y = ero ^ x;  <span class="comment">// 6 ^ 3 = 5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d   %d&quot;</span>, x, y);  <span class="comment">// 输出：3   5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.按位取反（~）</p>
<p>单目运算符，对一个整数的<strong>每一位</strong>进行取反操作：</p>
<ul>
<li><code>0</code> 变 <code>1</code>，<code>1</code> 变 <code>0</code>。</li>
</ul>
<h4 id="示例">示例</h4>
<p>计算 <code>~5</code>（假设 <code>int</code> 为 32 位，补码表示）：</p>
<ol>
<li><code>5</code> 的二进制（补码）：<code>00000000 00000000 00000000 00000101</code></li>
<li>按位取反后：<code>11111111 11111111 11111111 11111010</code></li>
<li>补码转原码（负数）：符号位不变，其余位取反加 1，结果为 <code>-6</code>，即 <code>~5 = -6</code>。</li>
</ol>
<h4 id="注意">注意</h4>
<ul>
<li>取反会改变符号位（正数变负数，负数变正数）。</li>
<li>对于无符号整数（<code>unsigned</code>），取反结果为 <code>2^n - 1 - 原值</code>（<code>n</code> 为位数）。例如 <code>unsigned int a = 5</code>，<code>~a</code> 为 <code>4294967290</code>（32 位无符号数）。</li>
</ul>
<p>5.左移运算符（<code>&lt;&lt;</code>）</p>
<p>将整数的二进制位<strong>向左（向右）移动指定的位数</strong>，右边空出的位用 <code>0</code> 填充。<br>
语法：<code>a &lt;&lt; n</code>（将 <code>a</code> 的二进制位左移 <code>n</code> 位）。</p>
<p>6.右移（<code>&gt;&gt;</code>）</p>
<p>将整数的二进制位<strong>向右移动指定的位数</strong>，分为两种情况：</p>
<ul>
<li><strong>逻辑右移</strong>：左边空出的位用 <code>0</code> 填充（适用于无符号数 <code>unsigned</code>）。</li>
<li><strong>算术右移</strong>：左边空出的位用<strong>符号位</strong>填充（正数补 0，负数补 1，适用于有符号数）。</li>
</ul>
<p>C 语言规定：无符号数必须逻辑右移；有符号数通常算术右移（依赖编译器）。</p>
<h3 id="27-数组">27.数组</h3>
<p>数组：一组相同类型元素的集合</p>
<p>相同基本类型	int arr[10]</p>
<p>相同数组类型	char arr [3] [4]	float brr[5] [7] [10]</p>
<p>相同指针类型	int*arr[10]</p>
<p>数组初始化：三种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义后赋值</span></span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	arr1[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//直接定义并赋值</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span> &#125;;<span class="comment">//底层arr[0]=1,arr[1]=2;…………</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, arr2[i]);</span><br><span class="line">&#125;	</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//先定义后从键盘获取赋值</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请从键盘输入10个数\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr3[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, arr3[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;<span class="comment">//错误原因是访问了未申请的空间arr[10];最大arr[9];</span></span><br></pre></td></tr></table></figure>
<p><strong>c99之前数组[]内只能是常量，c99之后会有变长数组可以使用const修饰的长变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对数组初始化为0</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//底层一个个给</span></span><br></pre></td></tr></table></figure>
<p>除了字符数组之外的所有数组	字符数组	链表	三者在使用上有区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len=<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);<span class="comment">//求数组大小</span></span><br></pre></td></tr></table></figure>
<p>二维数组（本质还是数组）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> brr[<span class="number">10</span>];<span class="comment">//10个int</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//3个int[4]	一组相同的 一维数组 构成的数组</span></span><br><span class="line"><span class="type">int</span> arr_len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);<span class="comment">//48/16=3</span></span><br><span class="line"><span class="comment">//获取每一位成员</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr_len; i++) &#123;</span><br><span class="line">	<span class="type">int</span> arr_len1 = <span class="keyword">sizeof</span>(arr[i]) / <span class="keyword">sizeof</span>(arr[i][<span class="number">0</span>]);<span class="comment">//在每遍历到一行时重新计算每一行的长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr_len1; j++) &#123;</span><br><span class="line">		arr[i][j] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="柔性数组">柔性数组</h4>
<p>柔性数组是<strong>放在结构体最后一个位置</strong>、<strong>长度定义为 0（或空）</strong> 的数组，它的特点是：</p>
<ul>
<li>
<p>不占用结构体本身的内存空间；</p>
</li>
<li>
<p>可以在分配结构体内存时，额外为这个数组分配任意大小的空间；</p>
</li>
<li>
<p>结构体和数组的内存是<strong>连续的</strong>，方便管理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 正确定义（柔性数组必须在结构体最后）</span><br><span class="line">typedef struct Node &#123;</span><br><span class="line">    int id;                // 普通成员</span><br><span class="line">    char data[0];          // 柔性数组（C99前常用0，C99后也可以写char data[]）</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 错误定义（柔性数组不能在中间/开头）</span><br><span class="line">typedef struct ErrorNode &#123;</span><br><span class="line">    char data[0];          // ❌ 不在最后</span><br><span class="line">    int id;</span><br><span class="line">&#125; ErrorNode;</span><br></pre></td></tr></table></figure>
<p>我们的通用栈需要存储<strong>任意类型的数据</strong>（int、float、自定义结构体、字符串等），且每种数据的大小都不一样（比如 int 占 4 字节，结构体可能占 20 字节）。</p>
<p>如果不用柔性数组，有两种糟糕的方案：</p>
<ol>
<li>固定大小数组：比如<code>char data[1024]</code>，小数据浪费空间，大数据不够用；</li>
<li>指针 + 单独分配：比如<code>char *data</code>，需要先分配结构体，再分配 data 指向的内存，内存不连续，容易泄漏，管理麻烦。</li>
</ol>
<p>而柔性数组刚好解决这些问题：</p>
<ul>
<li>按需分配：存储 int 就分配 “结构体大小 + 4 字节”，存储结构体就分配 “结构体大小 + 结构体大小”；</li>
<li>内存连续：结构体和数据区在同一块内存里，free 一次就能释放所有内存，不用单独管理；</li>
<li>通用适配：不管存储什么类型，都能用<code>memcpy</code>往柔性数组里拷贝数据，完美适配 “通用栈” 的需求。</li>
</ul>
<p><img src="https://gitee.com/WFWFWFWFG/image-bed/raw/master/img/20260118175800421.png" alt="image-20260118175800246"></p>
</li>
</ul>
<p><strong>使用柔性数组的注意事项</strong></p>
<ol>
<li>必须放在<strong>结构体最后一个成员</strong>的位置，且结构体至少有一个其他成员；</li>
<li>不能直接定义柔性数组变量（比如<code>char arr[0];</code>是错误的），只能作为结构体成员；</li>
<li>分配内存时必须手动计算总大小（结构体大小 + 柔性数组所需大小）；</li>
<li>C99 标准中，柔性数组可以写为<code>char data[]</code>（省略 0），效果和<code>char data[0]</code>一致（后者是编译器扩展，兼容性更好）。</li>
</ol>
<h3 id="28-高级内存">28.高级内存</h3>
<h4 id="整数在内存中的存储">整数在内存中的存储</h4>
<p>1.char	short	int	long	long long都是有符号的整数类型，都可以为负数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>			<span class="comment">//有符号字符类型（可以表示小数）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>	<span class="comment">//无符号的字符类型（不可以表示小数）</span></span><br></pre></td></tr></table></figure>
<p><strong>char	1个Byte  8bit	但是对于char来说实际空间为7bit</strong>		<strong>(注意特殊值)</strong></p>
<p><strong>1bit(符号位)（0+    1-）	+	7bit(数值位)</strong>			 <strong>1+0000000(特殊值)	-127-1=-128表示-128</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a=<span class="number">10</span>; <span class="comment">//0+0001010 	正数范围0 ~ 0+1111111(127)	负数范围1+0000001(-1) ~ 1+1111111(-127)</span></span><br><span class="line"><span class="type">char</span> b=<span class="number">-10</span>;<span class="comment">//1+0001010							   1+0000000(特殊值)	-127-1=-128表示-128</span></span><br><span class="line">											<span class="comment">//	   1+1111111 + 1=0000001 = 1+(1)0000000 = 1+0000000</span></span><br><span class="line">											<span class="comment">//	   10000000 无符号(-128) 有符号(128)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c;<span class="comment">//8bit的数值位	//00000000(0) ~ 11111111(255)</span></span><br></pre></td></tr></table></figure>
<p>2.计算机不会进行减法等运算只会加法</p>
<p>10–4=6   10+(–4)=6      00001010+11111100=1   00000110 （-6）  <strong>char类型只取8位因此为6</strong>   <strong>补码相加</strong></p>
<p>计算机对复数进行特殊处理——&gt;<strong>原码，反码，补码（–10）</strong></p>
<p><strong>原码    直接翻译为二进制</strong>	（1  0001010）			<strong>10     原，反，补（1  0001010）</strong></p>
<p><strong>反码    除过符号位按位取反</strong>    （1  1110101）</p>
<p><strong>补码   除过符号位按位取反+1</strong> （1  1110110）</p>
<p>计算机对数字的处理   任何数字在计算机中以补码的方式存储</p>
<p><strong>正数    原码——补码——反码   都相等</strong></p>
<p>负数    原，反，补各不相同</p>
<p><strong>任何数在计算机中以补码存储，打印的时候转化为原码打印</strong>    <strong>补转原      取反+1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">signed</span> 					<span class="type">unsigned</span> </span><br><span class="line"></span><br><span class="line"><span class="type">char</span> %c(%hhd) <span class="number">1B</span>yte    		<span class="type">unsigned</span> <span class="type">char</span> %hhu <span class="number">1B</span>yte </span><br><span class="line"></span><br><span class="line"><span class="type">short</span> %hd <span class="number">2B</span>yte    			<span class="type">unsigned</span> <span class="type">short</span> %hu <span class="number">2B</span>yte </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> %d <span class="number">4B</span>yte    			<span class="type">unsigned</span> <span class="type">int</span> %u <span class="number">4B</span>yte </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> %lld <span class="number">8B</span>yte    	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> %llu <span class="number">8B</span>yte </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//char 有符号的字符类型（可以表示小数 1+7）-128~127 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//unsigned char 无符号的字符类型（不可以表示小数8）0~255 </span></span><br><span class="line">_</span><br><span class="line"> <span class="comment">//short 有符号的short类型（可以表示小数 1+15）-32768~32767 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//unsigned short 无符号的short类型（不可以表示小数16）0~65535 </span></span><br><span class="line">_</span><br><span class="line"> <span class="comment">//int 有符号的int类型（可以表示小数 1+31）-2^31~2^31 - 1 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//unsigned int 无符号的int类型（不可以表示小数32）0~2^32 - 1 </span></span><br><span class="line">_</span><br><span class="line"> <span class="comment">//long long 有符号的int类型（可以表示小数 1+63）-2^63~2^63 - 1 </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//unsigned long long 无符号的int类型（不可以表示小数64）0~2^64 - 1 </span></span><br></pre></td></tr></table></figure>
<p><strong>二进制的取反+1==这个二进制的–1取反</strong></p>
<p><strong>原转补   取反+1     补转原   取反+1</strong></p>
<p><strong>任何数字存储都是以补码形式存储，存储前将数字转化为补码（负数的二进制要转，正数不转），只要存入内存中就是以补码形式存储，打印要转化为原码，看以什么形式打印，如果是有符号打印，符号位是1的话看作负数要自己转原码，打印原码所表示的值，符号位是0则原反补相同直接输出其值，若为无符号打印则直接输出其值</strong></p>
<p><strong>当格式控制符需要的Byte数小于空间中所占用的字节数，则依次从第一个字节开始往后获取格式控制符个Byte，将获取到的数字按照格式控制符生成</strong></p>
<p><strong>当格式控制符需要的Byte大于原空间时，在写入寄存器时需要补够位数</strong></p>
<p><strong>小字节数——大字节数——需要符号位填充</strong></p>
<p><strong>大字节数——小字节数——需要依次强行截取</strong></p>
<p><strong>由于补码的特殊性所以在补充位置时正数用0补充负数用1补充，这样补充之后的数字和原数字基本相同</strong></p>
<h4 id="浮点数在内存中的存储">浮点数在内存中的存储</h4>
<p>浮点数都是有符号的，小数的储存规则和原反补无关</p>
<p>浮点数储存核心也是将小数按照一定规则转化为二进制存储进4Byte或8Byte</p>
<p>浮点数在保存和提取时规则和整数大不相同，所以在转换时容易出现不可控因素</p>
<p><strong>浮点数规则</strong>—-科学计数法</p>
<p>首先将十进制小数转化为二进制小数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1	  1	   1	1	 1	  1	   1    1.	 1	   1	 1	   1	 1	   1     1	   1</span></span><br><span class="line"><span class="comment">//2^7 2^6  2^5  2^4  2^3  2^2  2^1  2^0  2^-1  2^-2  2^-3  2^-4  2^-5  2^-6  2^-7  2^-8</span></span><br><span class="line"><span class="comment">//128 64   32   16   8    4    2    1    0.5   0.25  0.125 0.0625........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//18.75   10010.11    科学计数法1.001011*2^4</span></span><br></pre></td></tr></table></figure>
<p>根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：<br>
(-1)^S * M * 2^E<br>
(-1)^S表示符号位，当S=0，V为正数；当S=1，V为负数。<br>
M表示有效数字，大于等于1，小于2。///1.几  科学计数法 表示时 小数点前肯定有一位1<br>
2^E表示指数位。</p>
<p><strong>对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，到下的23位为有效数字M</strong>			1+8+23</p>
<p><strong>对于64位的浮点数，最高的1位是符号位s，接着的11位是指数E，到下的52位为有效数字M</strong>		      1+11+52</p>
<p>double表示的范围远远大于float</p>
<p>float<br>
最小值 s(1)E(255)M(11111111 11111111 1111111)<br>
最小值：-1.1111111 11111111 11111111<em>2^128<br>
最大值：+1.1111111 11111111 11111111</em>2^128</p>
<p>double<br>
double// 最小值 s (1) E (2047) M (11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111)<br>
最小值：-1.1111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111* 2^1024<br>
最大值：+1.1111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111*2^1024</p>
<p>1.float在给浮点数分配内存时其八位的指数类型为unsigned 无符号类型  可以（不可以表示负数），计算机是如何处理符号位不能保存负数的问题？</p>
<p>E在保存的时候会将中间数加127，可以将一些负数转化为正数，则可以使用无符号的类型进行保存</p>
<p>E在保存的时候会将中间数加1023，可以将一些负数转化为正数，则可以使用无符号的类型进行保存</p>
<p>float中E的取值范围：-127~128   -127+127=0~128+127=255</p>
<p>2.M这个数字第一位一定是1，所以给M分配内存时为了储存更多的值  23位   第一位保存了1其他位只能保存22位，所以计算机默认只保存1.几后面的值，可以是1后面的值使用23位，保存跟多的数据，因此在提取小数时只需要给M+1即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a=<span class="number">9.0</span>;</span><br><span class="line">    <span class="comment">//9.0=====(-1)^s*M*2^E=======(-1)^0*1.001*2^3</span></span><br><span class="line">    <span class="comment">//s:真实值0	1Byte</span></span><br><span class="line">    <span class="comment">//E:真是值3   保存3+127=130  8Byte</span></span><br><span class="line">    <span class="comment">//M:真实值1.001保存时舍弃第一位保存001	23Byte</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-不同输入输出的区别">29.不同输入输出的区别</h3>
<h3 id="一、输入缓冲区的工作原理"><strong>一、输入缓冲区的工作原理</strong></h3>
<ol>
<li><strong>数据暂存</strong>：当用户通过键盘输入时，字符不会立即被程序读取，而是先存入输入缓冲区。例如：输入 <code>abc\n</code>（<code>\n</code> 是回车），缓冲区会先存储 <code>a、b、c、\n</code>。</li>
<li><strong>程序读取</strong>：当程序调用输入函数（如 <code>scanf</code>、<code>fgets</code>、<code>getchar</code>）时，函数会从缓冲区中读取数据：
<ul>
<li>如果缓冲区有数据，直接读取；</li>
<li>如果缓冲区为空，函数会阻塞（等待用户输入），直到缓冲区有数据或用户按下回车。</li>
</ul>
</li>
<li><strong>缓冲区清空</strong>：数据被读取后，会从缓冲区中移除（但未被读取的残留数据会保留）。</li>
</ol>
<h3 id="二、常见输入函数对缓冲区的处理"><strong>二、常见输入函数对缓冲区的处理</strong></h3>
<p>不同输入函数对缓冲区的读取规则不同，这是导致 “输入异常” 的核心原因：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>读取规则（从缓冲区取数据）</th>
<th>对 <code>\n</code>（回车）的处理</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scanf</code></td>
<td>跳过空白符（空格、<code>\n</code>、<code>\t</code>），读取匹配格式的数据，遇到非匹配字符或空白符停止。</td>
<td><code>\n</code> 被视为空白符，会被跳过（但可能残留）。例如用 <code>%d</code> 读整数时，<code>\n</code> 会留在缓冲区。</td>
</tr>
<tr>
<td><code>getchar</code></td>
<td>读取单个字符（包括 <code>\n</code>、空格等），不跳过任何字符。</td>
<td>会将 <code>\n</code> 当作普通字符读取。</td>
</tr>
<tr>
<td><code>fgets</code></td>
<td>读取到 <code>\n</code> 或达到最大长度为止，<strong>会将 <code>\n</code> 存入缓冲区</strong>。</td>
<td><code>\n</code> 会被包含在读取的字符串中。</td>
</tr>
<tr>
<td><code>gets</code>（弃用）</td>
<td>读取到 <code>\n</code> 为止，<strong>会丢弃 <code>\n</code></strong>（不存入字符串）。</td>
<td><code>\n</code> 被移除，不保留在结果中。</td>
</tr>
</tbody>
</table>
<p>输入：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>原型</th>
<th>操作对象（流）</th>
<th>数据格式</th>
<th>核心特点</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>printf</code></td>
<td><code>int printf(const char *format, ...)</code></td>
<td>固定为标准输出 <code>stdout</code>（控制台）</td>
<td>支持格式化（<code>%d</code>、<code>%s</code> 等）</td>
<td>直接输出到屏幕，自动处理缓冲区刷新（如遇到 <code>\n</code>）。</td>
<td>控制台打印变量、提示信息</td>
</tr>
<tr>
<td><code>fprintf</code></td>
<td><code>int fprintf(FILE *stream, const char *format, ...)</code></td>
<td>任意流（文件、<code>stdout</code>、<code>stderr</code> 等）</td>
<td>支持格式化</td>
<td>比 <code>printf</code> 多一个 <code>stream</code> 参数，可指定输出目标（如日志文件、错误流）。</td>
<td>写入文件、输出错误信息（<code>stderr</code>）</td>
</tr>
<tr>
<td><code>putchar</code></td>
<td><code>int putchar(int c)</code></td>
<td>固定为 <code>stdout</code></td>
<td>单个字符（ASCII 码）</td>
<td>仅输出单个字符，效率高，无格式化。</td>
<td>输出单个字符（如菜单选项）</td>
</tr>
<tr>
<td><code>fputc</code></td>
<td><code>int fputc(int c, FILE *stream)</code></td>
<td>任意流</td>
<td>单个字符</td>
<td>可输出单个字符到指定流，<code>putchar(c)</code> 等价于 <code>fputc(c, stdout)</code>。</td>
<td>向文件写入单个字符</td>
</tr>
<tr>
<td><code>puts</code></td>
<td><code>int puts(const char *str)</code></td>
<td>固定为 <code>stdout</code></td>
<td>字符串</td>
<td>输出字符串后自动追加 <code>\n</code>，不支持格式化，遇到 <code>\0</code> 停止。</td>
<td>快速输出一行字符串（带换行）</td>
</tr>
<tr>
<td><code>fputs</code></td>
<td><code>int fputs(const char *str, FILE *stream)</code></td>
<td>任意流</td>
<td>字符串</td>
<td>输出字符串但不追加 <code>\n</code>，<code>puts(str)</code> 等价于 <code>fputs(str, stdout); putchar('\n')</code>。</td>
<td>向文件写入字符串（无换行）</td>
</tr>
</tbody>
</table>
<p>输出：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>原型</th>
<th>操作对象（流）</th>
<th>数据格式</th>
<th>核心特点</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scanf</code></td>
<td><code>int scanf(const char *format, ...)</code></td>
<td>固定为标准输入 <code>stdin</code>（键盘）</td>
<td>支持格式化</td>
<td>按格式解析输入，以空白符（空格、换行、制表符）为分隔符，不检查缓冲区大小（有溢出风险）。</td>
<td>从键盘读整数、字符串等</td>
</tr>
<tr>
<td><code>fscanf</code></td>
<td><code>int fscanf(FILE *stream, const char *format, ...)</code></td>
<td>任意流（文件、<code>stdin</code> 等）</td>
<td>支持格式化</td>
<td>从指定流按格式读取，<code>scanf(...)</code> 等价于 <code>fscanf(stdin, ...)</code>。</td>
<td>从文件读结构化数据（如配置）</td>
</tr>
<tr>
<td><code>getchar</code></td>
<td><code>int getchar(void)</code></td>
<td>固定为 <code>stdin</code></td>
<td>单个字符</td>
<td>每次读一个字符（包括空格、换行），返回 ASCII 码（<code>EOF</code> 表示结束）。</td>
<td>处理单个字符输入（如确认键）</td>
</tr>
<tr>
<td><code>fgetc</code></td>
<td><code>int fgetc(FILE *stream)</code></td>
<td>任意流</td>
<td>单个字符</td>
<td>从指定流读单个字符，<code>getchar()</code> 等价于 <code>fgetc(stdin)</code>。</td>
<td>逐字符读取文件内容</td>
</tr>
<tr>
<td><code>gets</code>（弃用）</td>
<td><code>char *gets(char *str)</code></td>
<td>固定为 <code>stdin</code></td>
<td>一行字符串</td>
<td>读取到换行符为止（换行符被丢弃），<strong>无缓冲区大小限制</strong>，必然导致溢出，C11 已移除。</td>
<td>禁止使用</td>
</tr>
<tr>
<td><code>fgets</code></td>
<td><code>char *fgets(char *str, int size, FILE *stream)</code></td>
<td>任意流</td>
<td>一行字符串</td>
<td>最多读 <code>size-1</code> 个字符（保留换行符），自动加 <code>\0</code>，支持文件 / 键盘输入，安全。</td>
<td>读取一行字符串（文件或键盘）</td>
</tr>
<tr>
<td><code>sscanf</code></td>
<td><code>int sscanf(const char *str, const char *format, ...)</code></td>
<td>字符串（内存）</td>
<td>支持格式化</td>
<td>从字符串中按格式提取数据（输入源是内存字符串，非流）。</td>
<td>解析字符串中的数据（如日志）</td>
</tr>
</tbody>
</table>
<p>常见示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);  <span class="comment">// 假设输入 &quot;123\n&quot;，scanf 读取 123，缓冲区残留 &#x27;\n&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个字符：&quot;</span>);</span><br><span class="line">    c = getchar();      <span class="comment">// 直接读取缓冲区残留的 &#x27;\n&#x27;，无需用户输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的字符是：%d（ASCII码）\n&quot;</span>, c);  <span class="comment">// 输出 10（&#x27;\n&#x27; 的 ASCII 码）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//scanf(&quot;%d&quot;) 只读取数字，回车 \n 被留在缓冲区，后续 getchar 直接读取了 \n。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">10</span>], str2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符串1：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str1);  <span class="comment">// 输入 &quot;hello world\n&quot;，%s 读到空格停止，str1 = &quot;hello&quot;，缓冲区残留 &quot; world\n&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符串2：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str2);  <span class="comment">// 直接读取残留的 &quot;world&quot;，无需用户输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1: %s, str2: %s\n&quot;</span>, str1, str2);  <span class="comment">// 输出 str1: hello, str2: world</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//scanf(&quot;%s&quot;) 以空白符为分隔，空格后的 world 残留缓冲区，被下一次 scanf 直接读取。</span></span><br></pre></td></tr></table></figure>
<p>printf函数有缓冲区，在打印屏幕过程中要等缓冲区满或者刷新缓冲区才会打印</p>
<p>①缓冲区满打印</p>
<p>②遇到\n   或强制刷新  fflush(stdout)</p>
<h3 id="一、自动刷新规则（无需手动干预）">一、自动刷新规则（无需手动干预）</h3>
<ul>
<li>缓冲区满时自动刷新，这是最基础的触发条件，避免数据溢出。</li>
<li>行缓冲（如终端输入输出）遇到换行符<code>\n</code>时刷新，比如<code>printf(&quot;hello\n&quot;)</code>会立即输出。</li>
<li>程序正常结束时，所有已打开的 I/O 流缓冲区会自动刷新。</li>
<li>特定操作触发，比如调用<code>scanf</code>读取输入时，会先刷新标准输出缓冲区。</li>
</ul>
<h3 id="二、手动刷新规则（需主动调用函数）">二、手动刷新规则（需主动调用函数）</h3>
<ul>
<li>调用<code>fflush</code>函数，指定要刷新的流（如<code>fflush(stdout)</code>刷新标准输出缓冲区）。</li>
<li>关闭流时（调用<code>fclose</code>函数），会先刷新对应缓冲区再关闭。</li>
</ul>
<h3 id="30-设计随机数">30.设计随机数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">randArr</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="comment">// 设置随机种</span></span><br><span class="line">	srand(time(<span class="literal">NULL</span>)); <span class="comment">// 相对于1970 0  时0分0秒开始的时间戳</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="comment">// [min, max]  == &gt;   rand() % (max-min+1) + min</span></span><br><span class="line">		arr[i] = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">forEach</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len, <span class="type">void</span> (*fun)(<span class="type">int</span>, <span class="type">int</span>))</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		fun(i, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>公式：<code>[min, max]</code> 范围内的随机数 = <code>rand() % (max - min + 1) + min</code></strong></p>
<h3 id="31-可变参数">31.可变参数</h3>
<ol>
<li>核心定义</li>
</ol>
<p>可变参数指函数的参数数量、类型不固定（如<code>printf(const char* format, ...)</code>），<code>...</code>是 C 语言中表示 “可变参数列表” 的语法符号。</p>
<ol start="2">
<li>必备头文件</li>
</ol>
<p>必须包含 <code>&lt;stdarg.h&gt;</code>，该头文件定义了操作可变参数的核心宏和类型。</p>
<ol start="3">
<li>核心工具（4 个关键宏 / 类型）</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">工具</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>va_list</code></td>
<td style="text-align:center">类型：用于保存可变参数列表的 “指针容器”（可理解为指向参数栈的指针）</td>
</tr>
<tr>
<td style="text-align:center"><code>va_start</code></td>
<td style="text-align:center">宏：初始化<code>va_list</code>，让其指向第一个可变参数</td>
</tr>
<tr>
<td style="text-align:center"><code>va_arg</code></td>
<td style="text-align:center">宏：从<code>va_list</code>中按指定类型取出下一个参数，同时移动指针到下一个参数</td>
</tr>
<tr>
<td style="text-align:center"><code>va_end</code></td>
<td style="text-align:center">宏：清理<code>va_list</code>，释放相关资源（必须调用，否则可能内存泄漏）</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>核心规则</li>
</ol>
<ul>
<li>可变参数必须放在函数参数列表的<strong>最后</strong>（如<code>func(int a, char b, ...)</code>）；</li>
<li>必须有<strong>至少一个固定参数</strong>：<code>va_start</code>需要通过最后一个固定参数定位可变参数的起始位置，且可变参数无 “结束标记”，需通过固定参数（数量 / 结束符）控制遍历边界。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>  <span class="comment">// 必须包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求和函数</span></span><br><span class="line"><span class="comment"> * @param count 固定参数：指定可变参数的数量（必须）</span></span><br><span class="line"><span class="comment"> * @param ... 可变参数：待求和的整数</span></span><br><span class="line"><span class="comment"> * @return 所有整数的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    va_list args;  <span class="comment">// 1. 声明va_list变量，保存参数列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化：绑定到最后一个固定参数count，定位到第一个可变参数</span></span><br><span class="line">    va_start(args, count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历可变参数：按count指定的数量取参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 每次取一个int类型的参数，va_arg会自动移动指针到下一个参数</span></span><br><span class="line">        total += va_arg(args, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 清理va_list，必须调用</span></span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 测试：3个参数求和（1+2+3）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum(3, 1,2,3) = %d\n&quot;</span>, sum(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 输出：6</span></span><br><span class="line">    <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>C 函数调用时，参数是<strong>从右到左压入栈</strong>的（栈地址从高到低增长），以<code>sum(3,1,2,3)</code>为例：</p>
<table>
<thead>
<tr>
<th style="text-align:center">栈地址（高→低）</th>
<th style="text-align:center">存储的参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x1008</td>
<td style="text-align:center">3</td>
<td style="text-align:center">第三个可变参数</td>
</tr>
<tr>
<td style="text-align:center">0x1004</td>
<td style="text-align:center">2</td>
<td style="text-align:center">第二个可变参数</td>
</tr>
<tr>
<td style="text-align:center">0x1000</td>
<td style="text-align:center">1</td>
<td style="text-align:center">第一个可变参数</td>
</tr>
<tr>
<td style="text-align:center">0x0FFC</td>
<td style="text-align:center">3</td>
<td style="text-align:center">固定参数 count</td>
</tr>
</tbody>
</table>
<ul>
<li><code>va_start(args, count)</code>：找到<code>count</code>的地址（0x0FFC），然后 + 4 字节（int 占 4 字节），得到第一个可变参数的地址（0x1000），赋值给<code>args</code>；</li>
<li><code>va_arg(args, int)</code>：第一次取 0x1000 的 1，然后<code>args</code>指向 0x1004；第二次取 0x1004 的 2，<code>args</code>指向 0x1008；第三次取 0x1008 的 3；</li>
<li>栈的这种存储规则，决定了可变参数必须靠 “固定参数标记数量”+“从右到左取参数” 的逻辑。</li>
</ul>
<p>C 语言可变参数的核心是<code>&lt;stdarg.h&gt;</code>中的 4 个工具：<code>va_list</code>（存指针）、<code>va_start</code>（初始化）、<code>va_arg</code>（取参数）、<code>va_end</code>（清理）；</p>
<p>必须满足两个规则：① 可变参数在参数列表最后；② 有至少一个固定参数（用来标记数量 / 定位）；</p>
<p>核心风险点：类型不匹配、越界取参数、漏调用 va_end，这些都会导致程序错误。</p>
<p><strong>注意：</strong></p>
<ol>
<li><strong>必须有固定参数</strong>：不能写<code>sum(...)</code>（无固定参数），<code>va_start</code>无法定位可变参数，编译 / 运行都会报错；</li>
<li><strong>类型必须匹配</strong>：比如<code>va_arg(args, double)</code>但传入的是 int，会取到乱码（比如 int=1，取成 double 可能是一个极小的数）；</li>
<li><strong>可变参数必须在最后</strong>：比如<code>sum(..., int count)</code>是语法错误，编译器直接报错；</li>
<li><strong>va_end 必须调用</strong>：即使函数提前 return，也要先调用 va_end（比如加判断<code>if (count&lt;=0) &#123;va_end(args); return 0;&#125;</code>）；</li>
<li><strong>不要越界取参数</strong>：比如 count=3 却传了 2 个可变参数，<code>va_arg</code>会取到栈里的随机垃圾数据，导致结果错误甚至程序崩溃。</li>
</ol>
<h3 id="32-易错小点">32.易错小点</h3>
<p>1.if	else语句 	<strong>if总是和最近的else对其</strong>	<strong>(循环分支语句异地更要加{})</strong></p>
<p>2.每个Bit位都是个物理原件只能保存0或1</p>
<p>3.在进行条件判断时	常量在左，变量在右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(o==flag)	<span class="comment">//常量在左，变量在右（任何判断的时候）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;真&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在判断条件中出现一条赋值语句	 <strong>先执行语句操作，再判断这个变量是否为真假</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, k = <span class="number">0</span>; k = <span class="number">0</span>; i++, k++)  <span class="comment">//此代码不执行，k=0此处为假直接跳出循环不会执行（相当于一个判断条件）</span></span><br><span class="line">		k++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算机强制规定<strong>0为假  非0为真</strong></p>
<p>4.break；在循环中碰见执行到break这句话时则直接跳出本次<strong>整体</strong>的循环</p>
<p>continue；在循环中碰见执行到continue这句话时则跳过此次循环continue后的代码，<strong>直接进行判断，并执行下一次循环</strong></p>
<p>5.逻辑&amp;&amp; 	全真为真</p>
<p>​    逻辑||	  全假为假</p>
<p><strong>（&amp;&amp;优先级）&gt;（||优先级）</strong></p>
<p>表达式1&amp;&amp;表达式2&amp;&amp;表达式3	———&gt;	<strong>（表达式1&amp;&amp;表达式2）的结果&amp;&amp;表达式3</strong></p>
<p>表达式1||表达式2||表达式3	   ———&gt;	<strong>（表达式1||表达式2）的结果||表达式3</strong></p>
<p>再多级结合中遵循<strong>左结合</strong>原则，即从左到右依次计算。</p>
<p>6.循环逻辑问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hah&quot;</span>);<span class="comment">//打印11此=次hah</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>循环执行规则</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span>初始部分;<span class="number">2.</span>判断部分;<span class="number">3.</span>调整部分)&#123;</span><br><span class="line">    <span class="number">4</span>表达式</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.1</span>初始部分</span><br><span class="line"><span class="number">2.2</span>判断部分</span><br><span class="line"><span class="number">3.4</span>表达式</span><br><span class="line"><span class="number">4.3</span>调整部分</span><br><span class="line"><span class="number">5.2</span>判断部分</span><br><span class="line"><span class="number">6.3</span>表达部分</span><br><span class="line"><span class="number">7.3</span>调整部分</span><br><span class="line">......</span><br><span class="line">n.<span class="number">2</span>判断为假则跳出循环（<span class="keyword">break</span>）;</span><br></pre></td></tr></table></figure>
<p>7.地址</p>
<p>对任何空间取地址都是任何一片空间的地址都是起第一个字节编号或地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&amp;a  表示a四个字节中第一个字节的地址或者编号</p>
<p>8.指针</p>
<p>Type*p	   *p从p保存的这个地址中向后获取sizeof（Type）个字节中的值（数组名类型除外）</p>
<p>9.变量名放左边  代表他的空间  它里面放的值没有任何关系</p>
<p>变量名在右边  代表他空间中的值  跟空间无关</p>
<p>10.计算机中是数字都是int类型  小数都是double类型</p>
<p>11.arr[1]的地址本质是*（arr+1）</p>
<p>12.任何一片空间都要初始化</p>
<p>13.形参改实参要传地址</p>
<p>14.传参是指针的时候要判断指针是否为空</p>
<p>15.不要随意解引用访问未申请的内存  会出现很多未知因素</p>
<p>16.arr[ ]方便新手学习  计算机中 本质没有 [ ]     *<strong>(arr+i)==arr[i]</strong>	<strong>i[arr]==(i+arr)</strong>	<strong>i[p]==p[i]</strong></p>
<p>17.格式控制符只是将后面的值按照格式打印</p>
<p>18.<strong>隐式强转</strong>  c语言特性</p>
<p>不传数组长度，打印所有元素</p>
<p><strong>数组名在传参后会退化位数组首元素地址</strong></p>
<p>在传参之前是数组类型，在传参后是数组首元素地址类型       <strong>可以在函数定义中改变参数类型来赋予传进来的指针的不同能力</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">10</span>])</span> &#123;<span class="comment">//只是用到了类型实际传参还是数组首元素第一个字节的地址</span></span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(*arr) / <span class="keyword">sizeof</span>(*(arr)[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*arr)[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print3</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">10</span>])</span> &#123;</span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(*arr) / <span class="keyword">sizeof</span>(*(*arr));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *((*arr)+i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> crr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    print3(crr);<span class="comment">//可以不加&amp;，c++中必须加&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19.高级指针：一个指针  一个地址  我让他具有什么类型则它具有什么权限</p>
<p>20.字符数组初始化时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s2[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,s2[i]=<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s3[]=<span class="string">&quot;abcde&quot;</span>;<span class="comment">//这种赋值方式会自动放入\0，只有直接定义并初始化的数组或字符串会先默认将所有内存置0，再赋值</span></span><br></pre></td></tr></table></figure>
<p>计算机对字符串进行特殊处理，字符串为了更方便进行操作，将最后一位空间设置为标志位  ’\0‘</p>
<p>字符串提供了一种独有的格式控制符%s</p>
<p>21.<strong>只有直接定义并初始化的数组或字符串会先默认将所有内存置0，再赋值</strong></p>
<p>22.\后带数字都是8进制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> frr[]=<span class="string">&quot;\23abc\0\123&quot;</span><span class="comment">//\23算一个字符，\123也算一个字符</span></span><br></pre></td></tr></table></figure>
<p>23.<strong>[]优先级高于</strong>*</p>
<p>24.<strong>一个汉字占两个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;王锋&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>* p = (<span class="type">unsigned</span> <span class="type">short</span>*)s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(p+<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>25.<strong>getchar () 的基本特性</strong></p>
<ul>
<li><strong>函数原型</strong>：<code>int getchar(void);</code></li>
<li><strong>功能</strong>：从标准输入缓冲区读取一个字符（包括空格、回车、制表符等）。</li>
<li>返回值：
<ul>
<li>成功时，返回读取字符的 ASCII 码值（类型为 <code>int</code>）。</li>
<li>失败或遇到文件结束（EOF，End of File）时，返回 <code>EOF</code>（通常定义为 <code>-1</code>）。</li>
</ul>
</li>
<li><strong>注意</strong>：<code>getchar()</code> 会等待用户输入，直到按下回车键才会从缓冲区读取字符，且每次调用只读取一个字符（包括回车符 <code>'\n'</code>）。</li>
</ul>
<p><strong>如果从键盘输入a\n b\n c\n则输入缓冲区排列为a\n b\n c\n  getchar每次从缓冲区获取一个字符用来清理\n</strong></p>
<p>25.switch 语句中 default 可以在任意位置</p>
<p>26.while循环中，先判断是否为真再进入循环。</p>
<p>27.二维数组中，可以无行必须有列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> brr[<span class="number">1</span>][]<span class="comment">//错误不知道每个元素的类型</span></span><br></pre></td></tr></table></figure>
<p>28.计算机不会进行减法</p>
<p>29.vs中1  2   4Byte转8Byte错误———Bug    x86随机值      x64会在之前补0</p>
<p>printf函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printf</span><span class="params">(<span class="type">char</span>*s,...)</span>;<span class="comment">//...  可变模板参</span></span><br></pre></td></tr></table></figure>
<p>如果传参为char   int   short  会默认将这三种类型强转为int类型</p>
<p>如果传参参数为longlong  则默认使用long long类型的参数</p>
<p>如果参数为float   double则都会默认将这两种类型强转为double类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>格式控制都的意义不会让变量强转，获取变量几个字节空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> a=<span class="number">0X98</span>;<span class="comment">//10011000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%hhd&#x27;n&quot;</span>, a);<span class="comment">//10011000-&gt;11101000    </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%hd&#x27;n”,a);//11111111 10011000-&gt;10000000 01101000   </span></span><br><span class="line"><span class="string">printf(&quot;</span>%d nn”，);/<span class="number">10000000000000000000000000000000000000</span> <span class="number">01101000</span>    </span><br><span class="line"><span class="built_in">printf</span>(“%lld\nn<span class="string">&quot;,a);//11111111 11111111 11111111 10011000 将其转化为int类型但需要8Byte不够因此随机值</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>30.在c语言在中strlen返回值为unsigned int类型在编译器内核中为int类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span><span class="comment">//strlen unsigned int</span></span></span><br><span class="line"><span class="comment">//C语言编译器在内核提供了一个解决方案的函数int 用户无规限访问</span></span><br><span class="line"><span class="comment">//任何一个整数都是int类型任何一个小数都是double</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="built_in">strlen</span>(<span class="string">&quot;abe&quot;</span>)- <span class="built_in">strlen</span>(<span class="string">&quot;abcder&quot;</span>))&gt;<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;大于”);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">	printf(&quot;</span>小于<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    return 0；</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">                                                   </span></span><br></pre></td></tr></table></figure>
<p>31.++i性能高于i++;</p>
<p><strong>它不依赖临时数据的存储与拷贝，仅通过直接修改原对象即可完成操作</strong>，在寄存器 / 内存操作层面减少了指令数和数据移动。这种差异在底层越明显（如无优化、复杂类型），性能差距就越大。</p>
<ol>
<li>
<p>++i（前置自增）</p>
<p>：直接对变量本身自增，然后返回变量的引用（或自身）。</p>
<ul>
<li>逻辑：i = i + 1 → 返回 i，无额外拷贝开销。</li>
</ul>
</li>
<li>
<p>i++（后置自增）</p>
<p>：先保存变量的原始值到临时对象，再对变量自增，最后返回临时对象。</p>
<ul>
<li>逻辑：temp = i → i = i + 1 → 返回 temp，多了 “创建临时对象 + 拷贝原始值” 两步。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/">http://example.com/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">WF的知识空间</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">linux 系统</div></div><div class="info-2"><div class="info-item-1">1.Linux系统基础文件 倒状的树 1./bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令. 2./sbin:系统管理命令(超级用户二进制文件) 仅存放root用户的可执行命令 3./usr:用户共享资源 是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86) 4/etc:系统配置文件 存放的是系统和应用程序的配置文件,包含网络配置，用户配置，服务配置，系统启动 'etc/network 网络配置 5./dev 设备文件目录 块设备(读写，硬盘)，字符设备(键盘鼠标)，虚拟设备: 6.proc:进程与系统信息文件目录 存放虚拟目录，不占用磁盘空间，反映内核，进程，硬件的状态: 7.home 家目录 存放普通用户下的所有文件信息 '8./root 超级用户目录 ，存放超级用户下的所有文件信息 '9./boot系统启动相关文件 启动Lin脑ux系统必备文件 :10./lib /lib64 共享库文件 /lib存放共享库 /lib/libc.so,6C标准库 /linb64 64位系统库 '11...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WF</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WF-git-code"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="//github.com/WF-git-code" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18628492787@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text">1.什么是指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-c%E8%AF%AD%E8%A8%80%E4%B8%ADconst-%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%8C%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%EF%BC%8C%E8%A1%A8%E6%98%8E%E8%AF%A5%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="toc-number">2.</span> <span class="toc-text">2.c语言中const 是一个类型限定符，用来修饰变量，表明该变量的值不能被修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3.数组指针（指针偏移量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">4.指针数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B"><span class="toc-number">5.</span> <span class="toc-text">5.为什么数组下标从0开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%9C%A8%E5%AD%98%E5%82%A8%E4%B8%AD%E6%98%AF%E7%94%B1%E4%BD%8E%E5%9C%B0%E5%9D%80%E5%90%91%E9%AB%98%E5%9C%B0%E5%9D%80%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text">6.数组在存储中是由低地址向高地址存储的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8C%87%E9%92%88-p-%E5%92%8C-p%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">7.指针* p++和++* p的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">8.指针函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">9.函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">10.动态内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%BB%BD"><span class="toc-number">11.</span> <span class="toc-text">11.相同字符串常量在内存中只有一份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">12.结构体类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">13.与字符串有关的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%EF%BC%9Astrlen"><span class="toc-number">13.1.</span> <span class="toc-text">求字符串长度：strlen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%8D%E5%88%B6%EF%BC%9Astrcpy-%E4%B8%8E-strncpy"><span class="toc-number">13.2.</span> <span class="toc-text">2.字符串复制：strcpy 与 strncpy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-strcat-%E4%B8%8E-strncat"><span class="toc-number">13.3.</span> <span class="toc-text">3.strcat 与 strncat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%EF%BC%9Astrcmp-%E4%B8%8E-strncmp"><span class="toc-number">13.4.</span> <span class="toc-text">4. 字符串比较：strcmp 与 strncmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6-%E5%AD%90%E4%B8%B2%EF%BC%9Astrchr%E3%80%81strrchr%E3%80%81strstr"><span class="toc-number">13.5.</span> <span class="toc-text">5.查找字符 &#x2F; 子串：strchr、strrchr、strstr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-isdigit%EF%BC%88c%EF%BC%89%E5%88%A4%E6%96%AD%E8%AF%A5%E5%AD%97%E7%AC%A6%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6-ctype-h%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">13.6.</span> <span class="toc-text">6.isdigit（c）	判断该字符是不是数字字符	&#x2F;&#x2F;ctype.h头文件中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-strtok%E5%87%BD%E6%95%B0"><span class="toc-number">13.7.</span> <span class="toc-text">7.strtok函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95BF%E7%AE%97%E6%B3%95"><span class="toc-number">13.8.</span> <span class="toc-text">8.字符串查找算法BF算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">14.内存操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%A4%8D%E5%88%B6%EF%BC%9Amemcpy-%E4%B8%8E-memmove"><span class="toc-number">14.1.</span> <span class="toc-text">1.内存复制：memcpy 与 memmove</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE%EF%BC%9Amemset"><span class="toc-number">14.2.</span> <span class="toc-text">2. 内存设置：memset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E6%AF%94%E8%BE%83%EF%BC%9Amemcmp"><span class="toc-number">14.3.</span> <span class="toc-text">3. 内存比较：memcmp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-assert"><span class="toc-number">15.</span> <span class="toc-text">15.assert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-number">16.</span> <span class="toc-text">16.联合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89%E6%9C%AC%E8%B4%A8%E6%98%AF%E6%95%B4%E5%9E%8B%E5%80%BC"><span class="toc-number">17.</span> <span class="toc-text">17.枚举（enum）	本质是整型值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">18.</span> <span class="toc-text">18.内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">19.变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%87%BD%E6%95%B0"><span class="toc-number">20.</span> <span class="toc-text">20.函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">21.</span> <span class="toc-text">21.文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">22.整数转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98"><span class="toc-number">23.</span> <span class="toc-text">23.运算符优先级问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-c%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="toc-number">24.</span> <span class="toc-text">24.c编译链接原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-include%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">25.include引用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">26.</span> <span class="toc-text">26.位操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">26.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">26.2.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E6%95%B0%E7%BB%84"><span class="toc-number">27.</span> <span class="toc-text">27.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span class="toc-number">27.1.</span> <span class="toc-text">柔性数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E9%AB%98%E7%BA%A7%E5%86%85%E5%AD%98"><span class="toc-number">28.</span> <span class="toc-text">28.高级内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">28.1.</span> <span class="toc-text">整数在内存中的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">28.2.</span> <span class="toc-text">浮点数在内存中的存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%B8%8D%E5%90%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">29.</span> <span class="toc-text">29.不同输入输出的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">30.</span> <span class="toc-text">一、输入缓冲区的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%E5%AF%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">31.</span> <span class="toc-text">二、常见输入函数对缓冲区的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E8%A7%84%E5%88%99%EF%BC%88%E6%97%A0%E9%9C%80%E6%89%8B%E5%8A%A8%E5%B9%B2%E9%A2%84%EF%BC%89"><span class="toc-number">32.</span> <span class="toc-text">一、自动刷新规则（无需手动干预）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%89%8B%E5%8A%A8%E5%88%B7%E6%96%B0%E8%A7%84%E5%88%99%EF%BC%88%E9%9C%80%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">33.</span> <span class="toc-text">二、手动刷新规则（需主动调用函数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E8%AE%BE%E8%AE%A1%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">34.</span> <span class="toc-text">30.设计随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">31.可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%98%93%E9%94%99%E5%B0%8F%E7%82%B9"><span class="toc-number">36.</span> <span class="toc-text">32.易错小点</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/14/c++/" title="C++">C++</a><time datetime="2025-12-14T00:52:50.000Z" title="发表于 2025-12-14 08:52:50">2025-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言">C语言</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统">linux 系统</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By WF</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>