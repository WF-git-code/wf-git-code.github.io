<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>linux 系统 | WF的知识空间</title><meta name="author" content="WF"><meta name="copyright" content="WF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.Linux系统基础文件 倒状的树 1.&#x2F;bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令. 2.&#x2F;sbin:系统管理命令(超级用户二进制文件) 仅存放root用户的可执行命令 3.&#x2F;usr:用户共享资源 是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86) 4&#x2F;etc:系统配置文件 存放的是系统和应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="linux 系统">
<meta property="og:url" content="http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="WF的知识空间">
<meta property="og:description" content="1.Linux系统基础文件 倒状的树 1.&#x2F;bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令. 2.&#x2F;sbin:系统管理命令(超级用户二进制文件) 仅存放root用户的可执行命令 3.&#x2F;usr:用户共享资源 是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86) 4&#x2F;etc:系统配置文件 存放的是系统和应用程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WF.png">
<meta property="article:published_time" content="2025-07-27T00:52:57.000Z">
<meta property="article:modified_time" content="2025-12-04T13:28:25.203Z">
<meta property="article:author" content="WF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "linux 系统",
  "url": "http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/",
  "image": "http://example.com/img/WF.png",
  "datePublished": "2025-07-27T00:52:57.000Z",
  "dateModified": "2025-12-04T13:28:25.203Z",
  "author": [
    {
      "@type": "Person",
      "name": "WF",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux 系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WF的知识空间</span></a><a class="nav-page-title" href="/"><span class="site-name">linux 系统</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">linux 系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-04T13:28:25.203Z" title="更新于 2025-12-04 21:28:25">2025-12-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-Linux系统基础文件">1.Linux系统基础文件</h2>
<p><strong>倒状的树</strong></p>
<p><strong>1./bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令.</strong></p>
<p><strong>2./sbin:系统管理命令(超级用户二进制文件)</strong><br>
<strong>仅存放root用户的可执行命令</strong><br>
<strong>3./usr:用户共享资源</strong><br>
<strong>是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86)</strong></p>
<p><strong>4/etc:系统配置文件</strong><br>
<strong>存放的是系统和应用程序的配置文件,包含网络配置，用户配置，服务配置，系统启动</strong><br>
<strong>'etc/network 网络配置</strong><br>
<strong>5./dev 设备文件目录</strong><br>
<strong>块设备(读写，硬盘)，字符设备(键盘鼠标)，虚拟设备:</strong></p>
<p><strong>6.proc:进程与系统信息文件目录</strong><br>
<strong>存放虚拟目录，不占用磁盘空间，反映内核，进程，硬件的状态:</strong></p>
<p><strong>7.home 家目录</strong><br>
<strong>存放普通用户下的所有文件信息</strong><br>
<strong>'8./root 超级用户目录</strong><br>
<strong>，存放超级用户下的所有文件信息</strong><br>
<strong>'9./boot系统启动相关文件</strong><br>
<strong>启动Lin脑ux系统必备文件</strong><br>
<strong>:10./lib /lib64 共享库文件</strong><br>
<strong>/lib存放共享库 /lib/libc.so,6C标准库</strong><br>
<strong>/linb64 64位系统库</strong><br>
<strong>'11.media 可移动设备挂载</strong><br>
<strong>用于临时挂载移动设备，例如U盘，光盘，硬盘’</strong></p>
<p><strong>12./tmp 临时数据文件</strong><br>
<strong>运行系统或者程序的时候会产生临时文件，存放于该目录下</strong></p>
<h2 id="2-Linux系统基础命令">2.Linux系统基础命令</h2>
<p>$(…….)      命令替换 <code>$(...)</code> 会先执行括号内的命令，再将其输出作为字符串替换到当前命令中。</p>
<p>eg:编译所有.c后缀的文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -o main $(ls | grep .c)   等价于     gcc -o main *.c</span></span><br></pre></td></tr></table></figure>
<h4 id="1。放大界面：ctrl-shift-“-”缩小界面：ctrl-”-“">1。放大界面：ctrl+shift+“+”			缩小界面：ctrl+”-“</h4>
<p><strong>ctrl+c	结束前台正在运行的程序</strong>  		  <strong>~相当于家目录</strong>		<strong>…   上一级目录</strong>       <strong>/   根目录</strong></p>
<p>CTRL+alt+t打开终端</p>
<p>PID：进程的唯一标识符，用来区分唯一的进程        UID：用户唯一标识符</p>
<h4 id="2-第一个字符：">2.第一个字符：</h4>
<p>d开头：代表目录 	-开头：代表文件	l开头：代表链接文件相当于windows下的快捷方式</p>
<h4 id="3-分为三组：创建者权限组员权限其他人权限rwx可读可写可执行-777">3.分为三组：创建者权限	组员权限	其他人权限	rwx可读可写可执行   777</h4>
<p><strong>r 4 读	w 2 写	x 1 执行	– 0 没有权限</strong></p>
<p><strong>绝对路径：从根目录开始到跳转的地方</strong></p>
<p><strong>相对路径：从当前位置开始到跳转的地方</strong></p>
<h4 id="4-修改文件权限chmod">4,修改文件权限	chmod</h4>
<p><strong>①文字设定法</strong>  u创建者	g组员权限	o其他人	a所有人</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x file.txt<span class="comment">//创建者+可执行权限</span></span><br><span class="line"></span><br><span class="line">chmod g-w file.txt<span class="comment">//同组人-可写权限</span></span><br></pre></td></tr></table></figure>
<p><strong>②数字设定法</strong></p>
<p>chmod+权限的8进制+文件名（目录名）</p>
<p><strong>③递归修改（-R 选项）</strong></p>
<p>对目录及其子目录、文件批量修改权限，需加 -R 选项：<br>
chmod -R 权限 目录名</p>
<p><strong>示例</strong>：<br>
递归修改 project 目录下所有内容的权限为 755：chmod -R 755 project/</p>
<p><strong>④ 参考其他文件权限（–reference 选项）</strong></p>
<p>以另一个文件的权限为模板，复制权限到目标文件：<br>
chmod --reference=参考文件 目标文件</p>
<p><strong>示例</strong>：<br>
让 file2.txt 拥有与 file1.txt 相同的权限：chmod --reference=file1.txt file2.txt</p>
<p><strong>⑤ 特殊权限（SUID、SGID、粘滞位）</strong></p>
<p>在三位数字前可加一位数字，表示特殊权限（八进制）：</p>
<ul>
<li>4：SUID（用户执行文件时以文件所有者身份运行）</li>
<li>2：SGID（用户执行文件时以文件所属组身份运行；对目录，新建文件继承目录所属组）</li>
<li>1：粘滞位（Sticky Bit，对目录，仅文件所有者可删除自己的文件，如 /tmp）</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>设置 SUID 权限（如 passwd 命令）：chmod 4755 /usr/bin/passwd</li>
<li>对目录设置 SGID：chmod 2775 shared_dir/</li>
<li>对目录设置粘滞位：chmod 1777 /tmp</li>
</ul>
<h4 id="5-pwd查看当前位置绝对路径">5.pwd查看当前位置绝对路径</h4>
<h4 id="6-man：查看手册参数为命令">6.man：查看手册	参数为命令</h4>
<p>man+（n）+命令		用 n防止重名因此用类型限定</p>
<p>n:</p>
<p>（1）代表命令</p>
<p>（2）代表系统调用（内核函数）</p>
<p>（3）库函数</p>
<h4 id="7-ls"><strong><a target="_blank" rel="noopener" href="http://7.ls">7.ls</a></strong></h4>
<p><strong>①ls -l：打印当前目录下的所有信息</strong></p>
<p><strong>②ls -a：打印当前目录下文件包含的隐藏文件</strong></p>
<p><strong>③</strong>ls -d**：打印目录本身**</p>
<p><strong>④ls -t：按照文件最后修改时间显示</strong></p>
<p><strong>⑤ls -r：按照文件名称逆序打印</strong></p>
<p><strong>⑥ls -R：按照递归的方式，打印所有目录下包括子目录的所有内容</strong></p>
<h4 id="8-创建目录mkdir-目录名">8.创建目录	mkdir+目录名</h4>
<p><strong>①-P：多级创建</strong>		eg：mkdir -p /home/user/project/src/utils</p>
<p><strong>②-m：创建时修改目录权限</strong>		eg：mkdir -m 775 shared</p>
<h4 id="9-删除目录rmdir-目录名">9.删除目录	rmdir+目录名</h4>
<p><strong>①删除非空目录</strong>		rm±rf+目录名</p>
<p><strong>②删除文件</strong>		rm+文件名</p>
<h4 id="10-vi编辑器">10.vi编辑器</h4>
<h5 id="①进入vi编辑器-相当于winoows下的记事本"><strong>①</strong><em>进入vi编辑器(相当于winoows下的记事本)</em>*</h5>
<p><strong>1.进入命令模式(按下什么都输入不进去)</strong></p>
<p><strong>2.按下a，i，o，A,O进入编辑模式</strong></p>
<p><strong>3.如果想退出，先按下esci艮出编辑模式，进入命令模式</strong></p>
<p><strong>4.然后按下shift+&quot;:“进入底行命令模式，输入wq，即可退出</strong></p>
<h5 id="②编辑模式">②编辑模式</h5>
<p><strong>a:在光标之后插入内容</strong></p>
<p><strong>i: 在光标前插入内容</strong></p>
<p><strong>0:在当前行的下一行输入内容</strong></p>
<p><strong>A:在光标所在行的行尾播入内容</strong></p>
<p><strong>i:在光标所在行的行首插入内容</strong></p>
<p><strong>0:在当前行的上一行输入内容</strong></p>
<h5 id="③命令模式">③命令模式:</h5>
<p><strong>yy-复制当前行</strong><br>
<strong>p-粘贴</strong></p>
<p><strong>nyy-复制n行(从光标所在行开始复制，复制n行)</strong><br>
<strong>np-粘贴n次</strong><br>
<strong>dd-删除光标所在行</strong></p>
<p><strong>ndd-删除n行(包含光标所在行)</strong></p>
<p><strong>u-撤回</strong></p>
<p><strong>ctrl+r:撤回撤回的操作光标移动:</strong></p>
<p><strong>h(左)j(下),k(上),(右)</strong></p>
<p><strong>gg:跳转至文件行首</strong></p>
<p><strong>G:跳转文件末尾</strong></p>
<p><strong>nG:跳转到第n行翻页:</strong></p>
<p><strong>ctrl +“f”(下翻页)ctrl+“b”(上翻页)</strong></p>
<p><strong>x:删除光标所在位置的字符</strong></p>
<p><strong>d^:删除光标所在位置到行首的内容</strong></p>
<p><strong>d$:删除光标所在位置到行尾的内容</strong></p>
<p><strong>/关键字:从光标位置向下查找(/error查找error)</strong></p>
<p><strong>?关键字:从光标位置向上查找(?error查找error)</strong></p>
<p><strong>④底行命令模式</strong></p>
<p><strong>w:保存 	q:退出 	q!:强制退出	wq:保存并退出</strong></p>
<h4 id="11-cat-在屏幕上打印文件信息">11.cat:在屏幕上打印文件信息</h4>
<p><strong>cat :打印文件内容</strong><br>
<strong>cat +文件名</strong><br>
<strong>echo:在屏幕上打印信息</strong></p>
<p><strong>格式</strong>    <strong>cat more less head tail</strong></p>
<p><strong>格式1:cat +文件名</strong>	直接打印指定文件的全部内容到终端。</p>
<p><strong>格式2:cat 文件1 文件2</strong>	按顺序连接并输出多个文件的内容（相当于合并显示）。</p>
<p><strong>格式3:cat 文件1&gt;文件2</strong></p>
<p><strong>格式4:cat 文件1&gt;&gt;文件2</strong>	合并文件内容到新文件</p>
<p><strong>格式5:cat &gt;文件1</strong>. 创建新文件	从键盘输入内容，按 Ctrl+D 结束输入，内容会被写入新文件（若文件已存在，会覆盖原有内容）</p>
<p><strong>格式6:cat&gt;&gt;文件1</strong>	追加内容到已有文件	从键盘输入内容，按 Ctrl+D 结束输入，内容会被写入新文件（若文件已存在，会覆盖原有内容）</p>
<h4 id="12mv-移动文件">12mv:移动文件</h4>
<p><strong>格式1:mv 文件1 文件2 将文件2中的内容替换为文件1的，然后删除文件1</strong></p>
<p><strong>格式2: mv 目录1 目录2 将目录1移动到目录2中，然后删除目录一</strong></p>
<p><strong>格式3:mv 文件1目录1移动文件到目录中</strong></p>
<h4 id="13-通配符的概念"><strong>13.通配符的概念</strong></h4>
<p><strong>?:代表一个字符,但是不限是数字还是字母</strong></p>
<p>*<strong>:代表多个字符，不限是数字还是字母</strong></p>
<p><strong>【abc】:表示在【】内选取一个字符</strong></p>
<p><strong>【A-D】:表示在【】范围内，满足其条件,只取一位</strong></p>
<p><strong>【^abc】:表示不在【】范围内，选取一个字符</strong></p>
<h4 id="14-which-命令：查找命令所在的文件在哪里">14.which+命令：查找命令所在的文件在哪里</h4>
<h4 id="15-find">15.find</h4>
<p><strong>find + 起始地址 ±name“文件名’</strong>	按文件名查找</p>
<p><strong>find +起始地址 -size ± n[kMG]</strong>	按文件大小查找</p>
<h4 id="16-tail-查看文件尾部内容">16.tail	 查看文件尾部内容</h4>
<p><strong>tail -f -num 路径</strong><br>
<strong>-num :查看多少行</strong></p>
<h4 id="17-more查看文件内容-以翻页形式">17.more	查看文件内容(以翻页形式)</h4>
<p><strong>less	分屏看反复查看 q退出</strong></p>
<h4 id="18-cmp比较两个文件是否相同">18.cmp	比较两个文件是否相同</h4>
<h4 id="19-文件拷贝cp">19.文件拷贝	cp</h4>
<p>CP 路径+源文件名称   目标路径+新文件名	 <strong>将文件1的内容拷贝给文件2</strong></p>
<p>cp -r  文件夹1  文件夹2</p>
<p><strong>cat2&gt;3复制文件内容到3中，2不消失</strong></p>
<p><strong>mv 23 复制2中内容到3中，2消失</strong></p>
<h4 id="20-head">20.head</h4>
<p><strong>head :查看文件头部内容</strong></p>
<p><strong>head +文件名 显示该文件的前10 行 默认</strong></p>
<p><strong>head -n 20 文件名 显示该文件的前20行</strong></p>
<p><strong>head -c5 文件名 显示该文件的前5个字符</strong></p>
<h4 id="21-权限掩码">21.权限掩码</h4>
<p>满权限:777 文件默认的权限是666</p>
<p>指令:umask</p>
<p>格式:umask+权限掩码<br>
创建文件或目录的默认权限=<strong>满权限-权限掩码</strong></p>
<h4 id="22-打包tar">22.打包	tar</h4>
<p><strong>格式1:tar -cvf 目标包.tar + 需要打包的文件 打包</strong></p>
<p><strong>格式2:tar -tvf 目标包.tar 查看打包中的内容</strong></p>
<p><strong>格式3:tar -xvf 目标包.tar-c目标地址 解包</strong></p>
<p><strong>格式4:tar-Avf 包1包2 将2中的内容追加到1中</strong></p>
<p><strong>格式5:tar -rvf 目标包.tar 文件</strong></p>
<p><strong>tar zxf my.tar.gz 解包 解压释放一步完成          剩下的后缀百度搜解压方法</strong></p>
<h4 id="23-清屏clear">23.清屏	clear</h4>
<h4 id="24-查看当前用户who">24.查看当前用户	who</h4>
<h4 id="25-显示时间和日期-date">25.显示时间和日期:	date</h4>
<p><strong>格式1: date 显示时间和日期</strong></p>
<p><strong>格式2:date +%c 中文显示时间</strong></p>
<h4 id="26-查看进程-pS">26.查看进程: 	pS</h4>
<p><strong>①格式1: ps</strong><br>
<strong>②格式2:打印正在进行的进程</strong>	<strong>ps -au</strong>         <strong>ps -ef  打印所有进程</strong></p>
<p><strong>user:进程拥有着 		plD:%mem 内存占用率 	vsz:虚拟内存	 rss:串口内存		tty:串口号 stat:进程状态(s代表阻塞 r代表正在运行 t代表暂停)	start:进程开始时间 	time:进程持续时间 command:什么程序触发</strong></p>
<p><strong>③格式3 pstree 以树状图的形式打印进程</strong></p>
<h4 id="kill-结束进程-kill-进程ID">kill   结束进程    kill+进程ID</h4>
<h4 id="27-网络命令-ifconfig">27.网络命令:	ifconfig</h4>
<p><strong>本地回环:表示自己的地址所处的IP地址</strong></p>
<p><strong>硬件地址(mac地址):共有48位,前24位由厂商决定,后24位为个人</strong></p>
<p><strong>逻辑地址(IP地址)-进制255.255.255.255192.168.163.255</strong><br>
<strong>192.168.0.1 .1就是网关地址</strong></p>
<p><strong>子网掩码:1代表ip地址中的网络地址 0表示主机地址255.255.255.0</strong><br>
<strong>ip地址:192.168.163.0</strong>子网掩码:<br>
<strong>A类:第一个字段是网络地址，其余都是主机地址255.0.0.0</strong></p>
<p><strong>B类:第一个和第二个字段是网络地址，其余都是主机地址 255.255.0.0</strong><br>
<strong>C类:第一个和第二个和第三个字段是网络地址，其余都是主机地址 255.255.255.0</strong></p>
<p><strong>D类:作为组播地址</strong></p>
<p><strong>E类:作为测试网段</strong></p>
<p><strong>IPV4:只有32位</strong></p>
<p><strong>IPV6:有128位</strong></p>
<p>**网络协议:</p>
<p><strong>DHCP(动态主机配置协议)自动分配IP地址</strong><br>
<strong>DNS(域名解析办议)</strong><br>
<strong>计算机可以看懂的IP地址(192.0.0.0)</strong></p>
<h4 id="28-rm-删除">28.rm 删除</h4>
<p><strong>rm  文件名     删除文件</strong></p>
<p><strong>rm -r  目录     删除文件夹</strong></p>
<h4 id="29-find-搜索文件"><strong>29.find    搜索文件</strong></h4>
<p><strong>格式： find   路径   -name   文件名   按名字搜索</strong></p>
<h4 id="30-管道-两个进程传输信息的工具">30.管道	|   两个进程传输信息的工具</h4>
<p><strong>eg:ls | grep “pwd”</strong>  		 <strong>ls将结果给grep过滤输出过滤后的含pwd的文件</strong></p>
<h4 id="31-过滤-grep-对命令执行结果进行过滤">31.过滤     grep  对命令执行结果进行过滤</h4>
<p><strong>格式：grep   查找内容     文件名		查找包含找内容的文件内的这一行的信息</strong></p>
<p><strong>-r不区分大小写</strong></p>
<p><strong>-v 查找不包含这个内容的行信息</strong></p>
<h4 id="32-top-相当于windows的任务管理器">32.top  相当于windows的任务管理器</h4>
<h4 id="33-ldd-函数名查看函数所用到的共享库">33.ldd+函数名				查看函数所用到的共享库</h4>
<h2 id="3-shell命令">3.shell命令</h2>
<h4 id="1-创建shell文本">1.创建shell文本</h4>
<p><strong>创建shell文本需要三步:</strong></p>
<p>**创建脚本文件 vi <em>.sh<br>
提升文件权限chmod777 <em>.sh</em></em></p>
<p><strong>执行文件./</strong><em>.sh</em>*</p>
<p><strong>2.注意事项</strong></p>
<p><strong>shell文件在创建变量时，不需要变量的类型,直接去写变量名</strong></p>
<p><strong>a=12 b=20 	两边不需要空格</strong><br>
<strong>使用变量时，需要注意在变量名前加$，$a$(a}打印变量 echo</strong><br>
<strong>输入变量 read</strong><br>
<strong>取消变量的定义:unset+变量名</strong><br>
<strong>设置只读:readonly+变量名 不可被取消定义</strong></p>
<p><strong>命名规则:数字字母下划线组成,不能以数字开头</strong><br>
<strong>单引号:将整句话变成字符串打印</strong><br>
<strong>双引号:寻找其中对应的变量值</strong><br>
<strong>求字符串长度:需要在变量名前加 #且尽量使用0将整个变量括起来</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142534432.png" alt="image-20250727142534432" style="zoom:50%;">
<p><strong>截取相应长度的字符</strong><br>
<strong>echo ${name:n:m}	截取name字符串中从第n个字符开始后的m个</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142609263.png" alt="image-20250727142609263" style="zoom:50%;">
<p><strong>4 表示从第4个字符开始到末尾</strong><br>
<strong>-2(:后需要加空格)从倒数第二个开始输出</strong><br>
<strong>(-2):同上</strong></p>
<h4 id="3-预定义变量"><strong>3.预定义变量</strong></h4>
<p><strong>$0:打印当前脚本文件的名称(执行的第0个参数)</strong></p>
<p><strong>$@:打印从第一个开始后所有的参数</strong><br>
<strong>$#:打印从第一个参数开始的所有参数的个数</strong></p>
<p><strong>$1,2,3,4,5:打印当前脚本文件的第1-n个参数</strong></p>
<p><strong>$$:打印当前shel的进程id号</strong></p>
<h4 id="4-脚本文件的功能型">4.脚本文件的功能型:</h4>
<p><strong>1.运算</strong><br>
<strong>算术语句:expr</strong><br>
<strong>expr是一个表达式计算命令:支持整数运算，字符串处理</strong></p>
<p><strong>表达式中的运算符和操作符之前必须存在空格,否则会被视为字符串</strong></p>
<p><strong>格式:expr 变量1运算符 变量2</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142837253.png" alt="image-20250727142837253" style="zoom: 50%;">
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142849119.png" alt="image-20250727142849119" style="zoom: 50%;">
<p><strong>将a+b之后的结果赋值给num</strong></p>
<h4 id="5-关系运算符">5.关系运算符</h4>
<p><strong>-eq :比较是否相同()</strong><br>
<strong>-ne :比较是否不同(!=)</strong><br>
<strong>-gt:大于号</strong><br>
<strong>-ge:大于等于</strong><br>
<strong>-lt:小于号</strong><br>
<strong>-le:小于等于</strong></p>
<p><strong>-a:并且</strong><br>
<strong>-0:或者</strong></p>
<h4 id="6-文件运算符"><strong>6.文件运算符:</strong></h4>
<p><strong>-r -w -x :判断文件是否可读可写可执<br>
-e:判断文件是否存在</strong><br>
<strong>-f:判断文件是否为普通文件</strong><br>
<strong>-d:判断是否为目录</strong></p>
<p><strong>-ot -nt:</strong></p>
<p><strong>文件1   -ot/-nt   文件2	判断文件1是否比文件21/新</strong></p>
<h4 id="7-if语句">7.if语句</h4>
<p><img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143340095.png" alt="image-20250727143340095"></p>
<h4 id="8-数组">8.数组</h4>
<p><strong>数组:所有数据的集合格式:</strong></p>
<p><strong>数组名=(值1值2 值3)</strong></p>
<p><strong>使用方法; ${数组名[下标]}</strong></p>
<h4 id="9-for循环">9.for循环</h4>
<p><img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143457214.png" alt="image-20250727143457214"></p>
<h4 id="10-continue-遇到后跳过当前循环，执行下一次">10.continue:遇到后跳过当前循环，执行下一次</h4>
<h4 id="break-遇到直接结束循环">break:遇到直接结束循环</h4>
<h4 id="11-until语句">11.until语句</h4>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143549900.png" alt="image-20250727143549900" style="zoom:25%;">
<h4 id="12-while语句">12.while语句</h4>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143615581.png" alt="image-20250727143615581" style="zoom: 25%;">
<h3 id="13-前台与后台的相互转换">13.前台与后台的相互转换</h3>
<p><strong>kill可以结束一切命令     ctrl+c只结束前台命令</strong>   kill -9强制结束</p>
<p><strong>进程：正在运行的程序</strong></p>
<p><strong>sleep+时间   阻塞命令</strong></p>
<p><strong>前台 ：只能一个接着一个运行命令</strong></p>
<p><strong>后台：可以同时运行多个命令</strong></p>
<p><strong>命令   &amp;</strong>    转后台运行</p>
<p><strong>eg:sleep（30）&amp;</strong></p>
<p>jobs   打印正在运行的程序      -l加参数会打印出进程号       任务号不是进程ID</p>
<p>CTRL+Z停止当前命令，但没有终止，相当于将该进程挪到后台，但不会启动运行这个进程</p>
<p>bg %r任务号  前台挪后台</p>
<p><strong>先暂停程序再挪</strong></p>
<p>fg %任务号   后台挪前台</p>
<p>在停止之后进程挪动的时候唤醒暂停的程序</p>
<h3 id="14-gcc编译器编译c语言g-编译c-语言">14.gcc编译器编译c语言			g++编译c++语言</h3>
<p>无论编译何种语言，GCC 都会按 “<strong>预处理→编译→汇编→链接</strong>” 四个固定阶段执行，每个阶段输入特定格式的文件，输出下一级文件，最终生成可执行程序。</p>
<p>GCC 的本质是 “多阶段、模块化的代码转换器”，其完整流程可概括为：</p>
<ol>
<li><strong>预处理</strong>：<code>hello.c</code> → <code>hello.i</code>（文本替换，删除注释 / 展开宏 / 包含头文件）；</li>
<li><strong>编译</strong>：<code>hello.i</code> → <code>hello.s</code>（词法 / 语法 / 语义分析→IR 生成→优化→汇编代码）；</li>
<li><strong>汇编</strong>：<code>hello.s</code> → <code>hello.o</code>（汇编指令→二进制目标文件，含符号表）；不能运行因为没加系统库调运不了</li>
<li><strong>链接</strong>：<code>hello.o</code> + 系统库 → <code>hello</code>（合并目标文件→解析符号→重定位→可执行文件）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预编译    gcc -E main.c -o main.i</span></span><br><span class="line"><span class="comment">//编译      gcc -S main.i -o main.s</span></span><br><span class="line"><span class="comment">//汇编      gcc -C main.s -o main.o</span></span><br><span class="line"><span class="comment">//链接      gcc -O  main.o -o main</span></span><br><span class="line"><span class="comment">//四部结合   gcc -o main main.c    此时为relses版本</span></span><br><span class="line"><span class="comment">//gcc -o main main.c -g   debug版本</span></span><br></pre></td></tr></table></figure>
<p><strong>多个文件的编译     可以先用gcc   -c  对函数实现文件进行语法检查</strong></p>
<p>Debug和relese版本的区别，Debug版本相较于relese多了需要调试的信息</p>
<h3 id="15-make命令以及makefile文件">15.make命令以及makefile文件</h3>
<p>当项目包含多个源代码文件时，手动执行 <code>gcc</code> 等编译命令会非常繁琐（例如 <code>gcc a.c b.c c.c -o app</code>），且每次修改文件后需要重新输入完整命令。</p>
<p><strong>1.<code>make</code> 命令的核心价值在于：</strong></p>
<ol>
<li><strong>自动化构建</strong>：通过 Makefile 定义的规则，自动执行编译、链接等步骤，无需手动输入长命令。</li>
<li><strong>增量编译</strong>：仅重新编译<strong>被修改过的文件</strong>（通过对比文件修改时间判断），避免全量编译，节省时间。</li>
<li><strong>灵活扩展</strong>：支持复杂逻辑（如条件编译、多目标输出、跨平台适配等）。</li>
</ol>
<p><strong>2.<code>make</code> 命令的基本用法</strong>     一般只有一个makefile文件</p>
<p>make编译makefile文件      make+makefile中的方法—clean或者其他有意义的文件否则直接执行make会输出all中包含 的main文件按照依赖关系执行命令</p>
<p>如果makefile文件和make不在同一目录下则需要加相对路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有三个.c文件    add.c  max.c  main.c</span></span><br><span class="line"><span class="comment">//makefile文件</span></span><br><span class="line"><span class="comment">//完整版</span></span><br><span class="line">all : main</span><br><span class="line"></span><br><span class="line">main : main.o add.o max.o</span><br><span class="line">    gcc -o main main.o add.o max.o</span><br><span class="line">main.o : main.c</span><br><span class="line">    gcc -c add.c</span><br><span class="line">max.o : max.c</span><br><span class="line">    gcc -c max.c</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.o main</span><br><span class="line"><span class="comment">//简化版    </span></span><br><span class="line">all: main</span><br><span class="line">main : add.c main.c max.c</span><br><span class="line">    gcc -o main add.c main.c max.c</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.o main    </span><br></pre></td></tr></table></figure>
<p>主函数有三个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv,<span class="type">char</span>* envp)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s&quot;</span>,i,argv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;envp[i]!=<span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;envp[%d]=%s&quot;</span>,i,envp[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>linux有   1.2.3，windows只有1.2</strong></p>
<p><strong>1.参数个数  int  argc    argc最小为1   自己的函数名</strong></p>
<p><em><em>2.参数名称   char</em> argv         参数argv[0]=（Linux）当前函数路径+名称  argv[1]传给主函数第一个参数， argv[2]传给主函数第二个参数</em>*</p>
<p>​							  <strong>windows（函数的路径）</strong></p>
<p><em><em>3.环境变量    char</em> envp[]     envp最后一个元素是空指针</em>*</p>
<h3 id="16-gdb调试">16.gdb调试</h3>
<p>调试的对象是main/main.exe</p>
<p>stdin  stdio stderr  标准输入输出文件从电脑启动已经打开并运行  三个已经打开的文件指针</p>
<p><strong>gcc -o main main.c -g   debug版本</strong></p>
<ol>
<li>
<p>gdb  函数可执行文件</p>
</li>
<li>
<p>b n/函数名   第n行加断点/函数开头加断点</p>
</li>
<li>
<p>info break 打印所有断电信息</p>
</li>
<li>
<p>delete n  删除第n行断电</p>
</li>
<li>
<p>r      运行程序</p>
</li>
<li>
<p>n   执行下一行代码</p>
</li>
<li>
<p>p  参数   打印此时参数值</p>
</li>
<li>
<p>c   continue  执行直到下个断点</p>
</li>
<li>
<p>q  退出</p>
</li>
<li>
<p>l n   显示第n行代码</p>
</li>
<li>
<p>s  函数名    进入该函数       finish跳出函数</p>
</li>
<li>
<p>bt  显示当前函数的位置，现在再哪个函数的那个函数中   if   A-&gt;B-&gt;C</p>
<p>C</p>
<p>B</p>
<p>A</p>
</li>
</ol>
<h3 id="17-静态库与动态库">17.静态库与动态库</h3>
<p>printf实现在哪里?	stdio.h只是声明有这样一个函数	但实现是在库里面C标准库</p>
<p><strong>1.库文件</strong>	预先编译好的函数集合        (静态库 共享库(windows叫动态链接库).dll）</p>
<p>静态库：是可以被多个程序加载和共享的二进制文件			       libXX.a</p>
<p>共享库（动态库）：是可以被多个程序<strong>动态</strong>加载和共享的二进制文件    <a target="_blank" rel="noopener" href="http://libXX.so">libXX.so</a></p>
<p><strong>2.为什么打包成库?</strong></p>
<p>①.便于分享，直接给别人.o的库，避免别人二次编译从.c到.o，防止出现编译器不同问题，导致.o文件不一致</p>
<p>②.防止源码泄露,不希望别人知道自己.c的内容</p>
<p><strong>3.共享库创建步骤:</strong></p>
<p>①将需要生成库文件的所有.c文件编译成.0文件</p>
<p>②使用GCC将所有需要的.o生成为共享库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfool.so add.o max.o</span><br></pre></td></tr></table></figure>
<p>-shared :指定生成共享库 告诉编译器将目标文件(.o)链接成共享库，而不是生成可执行文件</p>
<p>-fPIC:用于生成位置无关代码，这是动态库必要的特性</p>
<p>位置无关代码:代码不依赖于特定的内存地址，无论动态库加载到内存的哪个位置，都能正常执行为什么需要这个?</p>
<p>动态库在程序运行的时候，由操作系统动态分配内存地址空间，而不是编译时固定位置如果代码依赖固定地址(使用绝对地址访问内存),加载到不同位置时会出错，，-fPIC的使用可以确保代码使用相对地址或间接寻址，适配动态加载原则(机制)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfool.so add.c max.c</span><br></pre></td></tr></table></figure>
<p>由于gcc的缘故，所以可以不需要刻意的生成.o再去生成动态库，可以直接拿.c来用</p>
<p>静态库：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//或者先编译.o文件再打包为库</span></span><br><span class="line">gcc -c add.o add.c</span><br><span class="line">gcc -c max.o max.c</span><br><span class="line">ar crv libfoo.a add.o max.o   <span class="comment">//打包为静态库</span></span><br><span class="line"><span class="comment">//但就算引用头文件也不能使用，因为自己创建的库需要自己手动连接，而c标准库会自动链接，需要解决则需要将自己创建的库移动到.c标准库目录下并指定库的名称,否则需要指定路径和名称</span></span><br><span class="line"><span class="comment">//gcc -o main main.c -lfoo     标准目录下</span></span><br><span class="line"><span class="comment">//gcc -o main main.c -L. -lfoo    .表示当前位置</span></span><br><span class="line"><span class="comment">//引用头文件（若要使用尖括号则需要将.h头文件放到头文件存放位置--不建议）双引号会优先在当前目录查找，头文件只实现函数的声明，创建.c文件用来编译为.o文件打包成静态库</span></span><br></pre></td></tr></table></figure>
<p><strong>ldd 查看可执行程序用了哪些共享库</strong></p>
<p><strong>以动态库链接生成的可执行程序不能直接运行，从Idd main中可以看到动态库not found两种解决方式</strong>   编译时任然需要</p>
<p><strong>gcc -o main main…c -L. -lfoo</strong>		但运行时报错则需要</p>
<p><strong>①1.将共享库拷贝到标准目录下</strong></p>
<p>动态库删库之后，文件无法执行了</p>
<p><strong>②告诉程序库就在当前目录中</strong>   配置环境变量<br>
如果库不在标准标准位置下，可以通过设置环境变量来加载库的路径</p>
<p>环境变量:是操作系统中储存系统配置信息或运行时参数的键值对，用于在整个系统中传递配置信息</p>
<p>环境变量相当于系统级别的全局变量<br>
核心特点:1。键值对结构 每个环境变量都由“变量名”=“值”组成</p>
<p>2.全局性</p>
<p>3.动态性 可以在系统运行时进行修改<br>
export:临时设置环境变量(当前终端有效)</p>
<p>执行可执行程序就算没了静态时库，程序依然能执main.0行，因为里面存在拷贝的.o文件的集合</p>
<p>可执行程序运行时，需要加载共享库，没有共享库的链接，没办法执行，没有复制，只有标记，如果后期升级/修改了共享库，那么可执行程序可以直接运行，不需要编译</p>
<p><strong>4.静态库动态库对比</strong></p>
<p>①链接时机和过程<br>
静态库:编译阶段链接     可执行程序会在<strong>链接时，会拷贝原方法到可执行程序</strong>，因此删掉静态库也可运行<br>
动态库:执行阶段链接     可执行程序在<strong>执行阶段</strong>链接动态库，删掉库不可运行，链接时只标记</p>
<p>②内存和磁盘占用<br>
静态库:可执行文件体积大，但是不依赖于外部资源</p>
<p>动态库:体积小，但是依赖外部库文件</p>
<p>③更新与维护<br>
静态库:所有依赖静态库的程序必须重新编译</p>
<p>动态库:无需重新编译，只需要链接新库</p>
<p>④适用场景<br>
静态库:程序只需要独立执行，没有外部依赖 小型工具 嵌入式设备</p>
<p>动态库:多个程序共享代码，需要频繁更新库文件 大型项目使用较多</p>
<h3 id="18-计算机组成原理">18.计算机组成原理</h3>
<p>五大件   运算器  控制器  内存  输入 输出</p>
<p>数据总线   地址总线   控制总线</p>
<p>指令;地址码和操作码组成     执行某种操作的命令     是原子操作不可分割</p>
<p><strong>程序就是指令的集合</strong>   一条高级语言语句可以分割为很多指令</p>
<h3 id="19-进程">19.进程</h3>
<p>只要不是程序员主动结束该进程，那么该进程的结束一定是触发信号被结束。但是程序员也可以通过信号结束该进程。</p>
<p>一、进程终止的原因分类</p>
<p>进程的终止可分为<strong>主动终止</strong>和<strong>被动终止</strong>，信号只是其中一种触发方式：</p>
<ol>
<li>主动终止（由程序员 / 进程自身控制）</li>
</ol>
<ul>
<li><strong>调用 <code>exit()</code> 或 <code>_exit()</code></strong>：进程主动调用退出函数，正常结束并清理资源（如 <code>exit(0)</code> 表示正常退出）。</li>
<li><strong><code>main</code> 函数返回</strong>：<code>main</code> 函数执行 <code>return</code> 语句，等价于调用 <code>exit(返回值)</code>。</li>
</ul>
<p>这些情况属于<strong>进程自主结束</strong>，不依赖信号触发。</p>
<ol start="2">
<li>被动终止（由外部或内部异常触发）</li>
</ol>
<ul>
<li>
<p>信号触发</p>
<p>：</p>
<ul>
<li>程序员主动发送信号终止进程（如 <code>kill -9 进程PID</code> 发送 <code>SIGKILL</code>）。</li>
<li>系统或程序异常触发信号（如 <code>SIGSEGV</code> 段错误、<code>SIGPIPE</code> 管道断裂）。</li>
</ul>
</li>
<li>
<p><strong>资源耗尽</strong>：如内存不足、文件描述符耗尽等，内核可能直接终止进程（部分场景会触发信号，如 <code>SIGABRT</code>）。</p>
</li>
</ul>
<p>二.</p>
<p>操作系统用来管理计算机软硬件资源</p>
<p>核心：进程，内存，中断，文件的管理</p>
<p>进程由操作系统管理</p>
<p>进程一个运行的程序及其所占用的所有资源</p>
<p>**PCB：进程控制块，是进程存在的唯一标志。**用来描述进程的属性信息  <strong>每个唯一</strong>    多个PCB穿起来组成链表</p>
<p><strong>PID：进程ID号   每一个进程唯一标识</strong></p>
<p><strong>PPID</strong>：<strong>父进程ID号</strong></p>
<p>进程状态：</p>
<p>就绪：等待调度运行</p>
<p>运行：正在运行</p>
<p>阻塞：运行到程序程序中断等待修改就绪</p>
<p>并发：两个处理器同时处理两个任务</p>
<p>并行：一个处理器交替进行两个任务</p>
<p>内存管理：逻辑页     物理页     页表（记录逻辑页物理页映射关系）虚拟内存：磁盘上划分空间当作内存用但是速度慢</p>
<p>分时系统：给每个进程分配固定时间同时进行</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>分时系统</th>
<th>实时系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计目标</td>
<td>多用户公平交互、资源共享</td>
<td>任务在规定时间内完成、高可靠</td>
</tr>
<tr>
<td>调度策略</td>
<td>时间片轮转，强调公平性</td>
<td>优先级抢占，强调时效性</td>
</tr>
<tr>
<td>响应时间要求</td>
<td>秒级，用户可接受即可</td>
<td>毫秒 / 微秒级，有严格上限</td>
</tr>
<tr>
<td>可靠性要求</td>
<td>一般，允许偶尔延迟</td>
<td>极高，超时可能导致严重后果</td>
</tr>
<tr>
<td>典型应用</td>
<td>桌面操作系统、服务器系统</td>
<td>工业控制、航电系统、医疗设备</td>
</tr>
</tbody>
</table>
<p>①对于每个进程来说，32位系统其逻辑地址大小都为0-4gb且分为数据区，代码区，堆区，栈区，在每个进程中内核通常都会占用一部分逻辑地址，这部分逻辑地址不能被使用，windows2gb  linux1gb，对于物理内存，操作系统会将物理内存分位内存页，通常大小4kb（与硬件有关），操作系统将内存抽象为逻辑地址，其在每个进程的PCB控制块中包含着逻辑地址映射物理地址的页表，每个进程里其逻辑地址可能相同但映射关系完全不同，逻辑地址转物理地址由cpu中的MMU来实现，虽然说逻辑地址可能相同，但在物理内存上使用区域是完全独立的，给程序员的感觉就好像每个进程都独立使用0-4gb的空间。</p>
<p><strong>注意：逻辑地址在不分配内存时不占用物理内存空间</strong></p>
<p>②真实内存小于逻辑地址时：<strong>虚拟内存 （逻辑地址）+ 交换分区（Swap）</strong> 机制解决，核心是 “用磁盘空间模拟内存，实现逻辑地址的‘按需映射’”。但速度会变慢。</p>
<p>③真实内存大于逻辑地址时：此时的核心问题是：<strong>32 位逻辑地址无法寻址超过 4GB 的物理内存</strong>，需通过硬件和内核机制突破这一限制。</p>
<p>④逻辑地址不足时：在32位操作系统大量使用虚拟内存，或者内存碎片太多，无大且连续的地址空间，会导致malloc  realloc返回错误，解决优化程序或者升级64位系统</p>
<p>内存碎片的产生：内存碎片是内存管理中 “效率与连续性” 矛盾的产物：</p>
<ul>
<li>内部碎片因 “内存对齐要求” 和 “固定分配单元” 产生，表现为已分配内存中的空闲空间；</li>
<li>外部碎片因 “频繁malloc分配释放free” 和 “分配策略” 产生，表现为分散的空闲块无法合并。<strong>malloc和realloc会分配连续的逻辑地址</strong></li>
</ul>
<p>现代操作系统通过分页、虚拟内存、伙伴系统等机制，在一定程度上平衡了碎片问题，但无法完全消除（通常以允许少量内部碎片为代价，换取外部碎片的减少）。</p>
<p>⑤物理内存不足时：多进程同时存在，或者单进程占用大量内存，轻度不足，操作系统回收空闲内存页不会杀死进程，重度不足，<strong>计算 OOM 评分</strong>（进程占用空间大小，优先级，重要程度），<strong>选择并杀死目标进程</strong>，<strong>系统恢复</strong>：释放的物理内存分配给急需内存的进程，避免系统崩溃。解决：增加物理内存，扩大 Swap 分区，限制进程内存使用，优化应用程序。</p>
<p>⑥对于进程复制，fork在执行的时候会将父进程的资源完全复制一份给子进程，包括PCB中的页表和文件结构体struct file ，但是由于这样效率低空间大，于是出现了写时拷贝，即谁改变复制谁，不改变的部分共享同一片物理空间，要改变的部分重新分配物理内存，即改变子进程页表中的映射关系。给程序员的感觉就是完全复制了一份。对于文件来说在struct file结构体中有一个引用计数器，记录了有几个进程在使用这个文件，当这个计数器为0时文件才会被关闭。因此在子进程即使被替换在不需要这个文件时也需要调用close关闭一次使引用计数器减一，父进程也需要关闭。文件表下标从3开始，并且父子进程共享已打开文件的文件偏移量。</p>
<p>⑦fork复制进程，在父进程会返回子进程的PID，在子进程中会返回0，因此可以根据这一特性使父子进程完成不同的功能，或者调用execlp来替换进程，在父进程先结束后，操作系统会自动将孤儿进程分配给一个系统进程，这个系统进程一定会调用wait接受子进程退出码，在子进程先结束后，由于父进程没有调用wait因此子进程会变为僵死进程，直到父进程结束系统重新分配父进程结束僵死进程，解决方法目前在父进程中调用wait，但因为需要子进程先结束因此会阻塞父进程。   linux会用四个字节来表示进程的结束，第一个字节表示系统是否正常退出，第二个字节表示退出码 。wait（）将4个字节的值提取出来，WIFEXITED(val)提取第一个字节表示是否正常，WEXITSTATUS(val)提取第二个字节并打印出退出码。</p>
<p>⑧<strong>用户态切换内核态</strong></p>
<p>每一个系统调用都有编号，当代码执行到需要内核函数时<strong>会产生中断</strong>0x80，用户程序将系统调用号存入Eax寄存器，执行 <code>int 0x80</code> 或者调用指令 syscall后，CPU 跳转到内核的中断处理程序，完成从用户态（特权级 3）到内核态（特权级 0）的切换。通过根据系统调用号从内核函数表中，找到内核中被调用函数，执行完被调用函数后，其返回值被Eax寄存器返回到应用程序中，继续执行后续代码</p>
<p>⑨<strong>系统调用与库函数的区别</strong> ？   <strong>产生中断陷入内核</strong></p>
<p>库函数实现在c库中，系统调用在内核中，实现一个printf函数会有一个用户态到内核态的切换</p>
<ul>
<li><strong>系统调用</strong>是内核提供的 “原子操作”，负责与硬件和内核资源交互，特点是底层、高效（单次调用开销固定）、但易用性差、跨平台性差。</li>
<li><strong>库函数</strong>是对系统调用的封装，提供更友好的接口、优化（如缓冲）和跨平台支持，降低开发难度，同时通过减少系统调用次数提升性能。</li>
</ul>
<p>⑩<strong>既然使用库函数和系统调用都有系统调用的开销为什么推荐使用库函数？</strong>  库函数是 “性价比最高的选择”</p>
<p>库函数虽然最终可能调用系统调用（因此包含系统调用的基础开销），但通过<strong>减少系统调用次数（缓冲区）、提供抽象接口、跨平台兼容和算法优化</strong>，显著降低了开发成本并提升了程序效率。对于绝大多数应用场景，使用库函数的 “收益”（开发效率、性能优化）远大于其引入的 “额外开销”（封装层的少量指令）</p>
<h3 id="20-复制进程-fork">20.复制进程   fork</h3>
<p>返回值为PID参数为NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid=fork();</span><br></pre></td></tr></table></figure>
<p>旧进程——父进程</p>
<p>fork复制——子进程        父子进程一模一样但PID不同</p>
<p>fork在父进程返回值为子进程的PID     在子进程返回值为0</p>
<p><strong>子进程从fork返回这个位置执行</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="number">3</span>;</span><br><span class="line">        s = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="number">7</span>;</span><br><span class="line">        s = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%s curr_pid=%d, ppid=%d\n&quot;</span>, s, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wf@wf-virtual-machine:~/mycode/c2501/day03$ ./test</span><br><span class="line">s=child curr_pid=<span class="number">3043</span>, ppid=<span class="number">3042</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=child curr_pid=<span class="number">3043</span>, ppid=<span class="number">3042</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=child curr_pid=<span class="number">3043</span>, ppid=<span class="number">3042</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">fork()||fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印三次A</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">fork()&amp;&amp;fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印三次A</span></span><br></pre></td></tr></table></figure>
<p>如果打印n的地址全部是逻辑地址且都相同，对于同一个进程逻辑地址唯一对应一个物理地址，每个进程都有一个页表（记录逻辑地址与物理地址的对应关系），对于每个进程页表唯一且不同，父子进程逻辑地址都相同但其中每个页表对应关系不同，因此就算是相同的逻辑地址也对应不同的物理地址。PCB中存储着不同进程的信息。</p>
<p>计算机中通过调试只能看见逻辑地址，真实的物理内存无法看到</p>
<p>逻辑地址是距离0x00000000的偏移量</p>
<p>复制是将父进程的逻辑地址以及全部信息复制一份，但在其子进程的页表中其逻辑地址对应物理地址关系不同。包括其输入输出缓冲区。</p>
<p>也会复制文件表</p>
<p>可以同时操作同一文件</p>
<h5 id="僵死进程">僵死进程</h5>
<p><strong>设计：子进程先结束后，默认要求父进程要获取子进程退出码 ——存在进程PCB中</strong>      <strong>父进程没有获取退出码，子进程变为僵死进程</strong></p>
<p>父进程结束后，子进程会被系统进程接管，而系统进程会获取退出码释放子进程     可能会也可能不会产生，但最终会被解决掉</p>
<p>exit(0);</p>
<p>exit(1);错误码</p>
<p>僵死进程：子进程先结束，父进程没有调用wait（）获取子进程退出码，则子进程一直会存在就算父进程结束，系统会重新将该子进程分配给另一个永不结束的父进程，直到退出码被调用，以前是被pid号为1的进程接管，现在不确定但系统找到的进程一定会调用wait（）结束僵死进程。</p>
<p><strong>解决</strong>①：<strong>在父进程中调用wait()获取子进程退出码</strong>    <strong>但会阻塞父进程得等待子进程结束后获取退出码后再继续执行父进程</strong>    子进程得先结束</p>
<p><code>wait</code> 函数的参数是一个<strong>指针</strong>（<code>&amp;val</code>），内核会通过这个指针将子进程的退出状态写入 <code>val</code> 对应的内存地址。因此，调用 <code>wait</code> 后，<code>val</code> 的值会被更新为子进程的退出状态信息（而非初始的 0）。</p>
<p>子进程的退出状态信息并非简单的 “退出码”，而是一个包含多种信息的<strong>复合值</strong>（如是否正常退出、退出码、是否被信号终止等）。例如：</p>
<ul>
<li>
<p>若子进程通过 <code>exit(3)</code> 正常退出，<code>val</code> 会被设置为一个包含 “正常退出” 标志和 “退出码 3” 的复合值（而非直接等于 3）。</p>
</li>
<li>
<p>需通过 <code>WEXITSTATUS(val)</code> 等宏函数解析，才能得到真正的退出码（3）</p>
</li>
<li>
<p>一个字节</p>
<p>00000000 00000000 00000011 00000000      第一个字节表示是否正常退出        第二个字节表示退出码</p>
<p>wait（）将4个字节的值提取出来</p>
<p>WIFEXITED(val)提取第一个字节表示是否正常退出</p>
<p>WEXITSTATUS(val)提取第二个字节并打印出退出码</p>
</li>
</ul>
<p><strong>或者直接调用wait(NULL);</strong></p>
<p>wait函数的功能	①传回状态码    <strong>通过传入变量的地址</strong>（可以为NULL）意思不传但也能结束僵死进程</p>
<p>​				   ②解决僵死进程</p>
<ul>
<li>父进程调用 <code>wait</code> 后，内核会遍历该父进程的<strong>所有子进程</strong>，查找处于 ** 僵死状态（<code>Z</code>）** 的子进程；</li>
<li>若找到，内核会释放该子进程的残留资源（从进程表中删除），并将其退出状态通过 <code>wait</code> 的 <code>status</code> 参数返回；</li>
<li>若没有僵死子进程，<code>wait</code> 会让父进程<strong>阻塞等待</strong>，直到有子进程终止并变成僵死状态后再继续。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">// 假设已通过fork()创建子进程，此处父进程等待子进程</span></span><br><span class="line">    wait(&amp;val); <span class="comment">// 等待子进程结束，获取退出状态到val</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(val)) &#123; <span class="comment">// 判断子进程是否正常退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，状态码：%d\n&quot;</span>, WEXITSTATUS(val)); <span class="comment">// 提取退出状态码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">3</span>;</span><br><span class="line">        s = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">7</span>;</span><br><span class="line">        s = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        wait(&amp;val);<span class="comment">//获取退出码，子进程不会变成僵死进程</span></span><br><span class="line">       <span class="comment">// 代码中确实先将 val 定义为 0（int val = 0;），但这只是 val 的初始值。当调用 wait(&amp;val); 后，val 的值会被内核覆盖，存储子进程的退出状态信息（不再是初始的 0）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;val=%d\n&quot;</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%s pid=%d,ppid=%d\n&quot;</span>,s,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>②利用 <code>SIGCHLD</code> 信号自动回收     内核在子进程结束时发送给父进程        这个信号默认和忽略效果相近，什么都不做。因此将其改为自定义自动调用wait（）</p>
<p>父进程可以捕获 <code>SIGCHLD</code> 信号（子进程终止时内核会向父进程发送此信号），在信号处理函数中调用 <code>waitpid()</code> 回收资源，避免阻塞主逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sig=%d\n&quot;</span>, sig);</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    wait(&amp;val); <span class="comment">//通用的解决僵死进程的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//signal(SIGCHLD, fun); //linux unix</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN); <span class="comment">//linux 解决僵死进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处可根据需求补充子进程或父进程的后续逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③父进程结束，子进程被接管</p>
<h5 id="写时拷贝">写时拷贝</h5>
<p>推迟甚至免除页面拷贝的技术</p>
<ol>
<li>父进程（PID=100）调用 <code>fork()</code> 创建子进程（PID=101）。</li>
<li>内核不为子进程复制内存，而是让父子进程共享所有内存页（标记为 “只读”）。</li>
<li>父进程修改变量 <code>a</code> 时，内核检测到 “写操作”，为父进程复制 <code>a</code> 所在的内存页，父进程后续操作新副本。</li>
<li>子进程未修改 <code>a</code>，仍使用原内存页；若子进程也修改 <code>a</code>，则内核为其单独复制一份。</li>
</ol>
<p>简单说，COW 的核心是 “<strong>不修改就不复制，谁修改谁复制</strong>”，是操作系统中优化资源复制的经典策略。</p>
<p><strong>传统来说fork时复制全部资源，但这样效率低资源占用大因此写时拷贝</strong>，<strong>以内存页为单位</strong>，<strong>不改的时候共享，改的时候拷贝</strong></p>
<p>对程序员来说是透明的</p>
<ol>
<li>
<p><strong>虚拟地址空间的 4MB</strong>进程的代码段、数据段、堆、栈在虚拟地址空间中总计占用 4MB，意味着这些段的虚拟页总和覆盖了 4MB 的虚拟地址范围（例如，1024 个 4KB 虚拟页）。但这并不等于物理内存实际分配了 4MB，因为：</p>
<ul>
<li><strong>未使用的虚拟页不分配物理页</strong>：例如，堆声明了 1MB 空间但只使用了 100KB，剩余 900KB 的虚拟页未映射到物理页（访问会触发缺页异常，动态分配）。</li>
<li><strong>只读段（如代码段）可能共享物理页</strong>：如果其他进程也运行相同程序，代码段的物理页会被共享，不计入当前进程的 “独有物理占用”。</li>
</ul>
<p>因此，进程的<strong>实际物理内存占用（Resident Set Size, RSS）通常小于虚拟地址空间的使用量</strong>（4MB）。</p>
</li>
</ol>
<h3 id="21-文件操作做的系统调用">21.文件操作做的系统调用</h3>
<p>Linux系统提供了操作文件的底层系统调用：read   write   open   close     （内核中）</p>
<p>linux系统：fopen()——&gt;open()</p>
<p>Linux系统中不分文本文件和二进制文件</p>
<p>windows文本文件会加特殊字符，并且会对这种特殊字符进行处理。</p>
<p><strong>open（）调用一次就会产生一个结构体 struct file</strong>  文件表</p>
<p><strong>文件表：记录打开的文件</strong>     默认1024            <strong>在进程PCB中</strong></p>
<p><strong>进程私有，不同进程文件描述符可以相同，但是与全局文件表映射关系不同，参考逻辑地址与物理地址</strong></p>
<p><strong>本质结构体数组</strong>        描述符和file*指针选一个</p>
<p>0 标准输入</p>
<p>1 标准输出</p>
<p>2 标准错误输出</p>
<p>3 a.txt</p>
<p>文件表从下表为3开始</p>
<p><strong>有一个结构体 struct file  表示打开的文件，这个结构体里面有一个计数器，记录有几个进程打开此文件，等计数器为0的时候文件才会被关闭</strong></p>
<p><strong>父进程打开的文件，fork（）后子进程也可以访问，并且共享文件偏移量</strong></p>
<h3 id="22-系统调用">22.系统调用</h3>
<p><strong>内核是底层资源管理者，系统调用是内核暴露的 “入口”，C 库函数是对系统调用的 “封装与扩展”</strong>，</p>
<p><strong>实现在内核中</strong></p>
<p>1）表示命令</p>
<p>2）表示内核函数</p>
<p>3）表示库函数</p>
<ul>
<li><strong>系统调用</strong>是内核提供的 “原子操作”，负责与硬件和内核资源交互，特点是底层、高效（单次调用开销固定）、但易用性差、跨平台性差。</li>
<li><strong>库函数</strong>是对系统调用的封装，提供更友好的接口、优化（如缓冲）和跨平台支持，降低开发难度，同时通过减少系统调用次数提升性能。</li>
</ul>
<p>①<strong>系统调用与库函数的区别</strong> ？   <strong>产生中断陷入内核</strong></p>
<p>库函数实现在c库中，系统调用在内核中，实现一个printf函数会有一个用户态到内核态的切换</p>
<p>②<strong>既然使用库函数和系统调用都有系统调用的开销为什么推荐使用库函数？</strong></p>
<p><strong>用户态缓冲机制</strong>：这是最关键的优化。库函数会在用户态开辟缓冲区，积累数据后批量调用系统调用，而非每次操作都触发内核切换。、</p>
<p><strong>合并与优化操作</strong>：库函数会对连续的底层请求进行合并，减少内核态的重复工作。</p>
<p><strong>跨平台兼容性</strong>：库函数（如 C 标准库）屏蔽了不同操作系统的系统调用差异，相同代码可在 Linux、Windows 等系统上运行。</p>
<p><strong>更高的易用性</strong>，功能拓展</p>
<p><strong>用户态切换内核态</strong></p>
<p>每一个系统调用都有编号，当代码执行到需要内核函数时<strong>会产生中断</strong>，用户程序将系统调用号存入Eax寄存器，执行 <code>int 0x80</code> 或者调用指令 syscall后，CPU 跳转到内核的中断处理程序，完成从用户态（特权级 3）到内核态（特权级 0）的切换。通过根据系统调用号从内核函数表中，找到内核中被调用函数，执行完被调用函数后，其返回值被Eax寄存器返回到应用程序中，继续执行后续代码</p>
<p><strong>一、系统调用的触发机制</strong></p>
<p>用户程序通过<strong>系统调用接口</strong>（如 C 标准库的 <code>open</code>、<code>read</code> 等封装函数）发起请求，底层通过<strong>硬件指令</strong>触发特权级切换：</p>
<ul>
<li><strong>x86 早期架构</strong>：使用<strong>软中断指令 <code>int 0x80</code></strong>。用户程序将系统调用号存入寄存器（如 <code>eax</code>），执行 <code>int 0x80</code> 后，CPU 跳转到内核的中断处理程序，完成从用户态（特权级 3）到内核态（特权级 0）的切换。</li>
<li><strong>x86 现代架构</strong>：使用<strong>快速系统调用指令 <code>syscall</code></strong>。该指令更高效，通过 <code>syscall</code> 直接进入内核，并利用 MSR（模型特定寄存器）存储的内核入口地址快速跳转。</li>
</ul>
<p><strong>二、系统调用的处理流程</strong></p>
<ol>
<li><strong>参数传递</strong>：用户程序将系统调用号和参数存入指定寄存器（如 <code>eax</code> 存调用号，<code>ebx</code>、<code>ecx</code> 等存参数）。</li>
<li><strong>触发切换</strong>：执行 <code>int 0x80</code> 或 <code>syscall</code> 指令，CPU 切换到内核态，进入<strong>系统调用处理入口</strong>。</li>
<li><strong>内核查表执行</strong>：内核通过系统调用号在<strong>系统调用表</strong>（如 <code>sys_call_table</code>）中查找对应的内核处理函数（如 <code>sys_open</code>、<code>sys_read</code>），并执行该函数。</li>
<li><strong>返回用户态</strong>：内核处理完成后，将结果存入寄存器，恢复用户程序的上下文（如寄存器、栈），执行 <code>iret</code>（对应 <code>int 0x80</code>）或 <code>sysret</code>（对应 <code>syscall</code>）指令，切换回用户态，将结果返回给用户程序。</li>
</ol>
<p><strong>示例：<code>open</code> 系统调用的切换过程</strong></p>
<ol>
<li>用户程序调用 <code>open(&quot;file.txt&quot;, O_RDONLY)</code>，C 库将其封装为系统调用，设置系统调用号（如 <code>eax = 5</code>，对应 <code>sys_open</code>），并将文件名、权限等参数存入 <code>ebx</code>、<code>ecx</code> 等寄存器。</li>
<li>执行 <code>syscall</code> 指令，CPU 切换到内核态，进入内核的系统调用处理函数。</li>
<li>内核通过 <code>sys_call_table[5]</code> 找到 <code>sys_open</code> 函数，执行文件打开操作，将文件描述符存入 <code>eax</code>。</li>
<li>执行 <code>sysret</code> 指令，切换回用户态，用户程序从 <code>open</code> 调用中获取返回的文件描述符。</li>
<li></li>
</ol>
<h3 id="23-替换进程">23.替换进程</h3>
<p>fork()+execl()===全新的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 带路径，参数列表为可变参数（以NULL结尾）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 带路径，参数列表为数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不带路径（从PATH环境变量查找），参数列表为可变参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 不带路径，参数列表为数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 带路径，可指定环境变量，参数列表为可变参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 带路径，可指定环境变量，参数列表为数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>
<p>execl(路径，第一个参数（函数名），第二个参数，……,(char*)0);      (char *)0必须加    通过man看参数</p>
<p>execlp（函数名，第一个参数（函数名），第二个参数，……,(char*)0); 通过环境变量</p>
<p>execle()；</p>
<p>execv（）；</p>
<p>最终调用的是execve（）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">4</span> <span class="built_in">printf</span>(<span class="string">&quot;%d  \n %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line"> <span class="number">5</span> execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,(<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line"> <span class="number">6</span> <span class="built_in">printf</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>bash的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>vi</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_cmd</span><span class="params">(<span class="type">char</span> buff[], <span class="type">char</span>* myargv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( buff == <span class="literal">NULL</span> || myargv == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//buff=&quot;cp  a.c  b.c&quot;;</span></span><br><span class="line">    <span class="type">char</span>* s = strtok(buff,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>( s != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        myargv[i++] = s;</span><br><span class="line">        s = strtok(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myargv[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[],<span class="type">char</span>* envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;32mstu@stu-virtual-machine\033[0m:~/mycode/c2501/day08$&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(buff,<span class="number">128</span>,<span class="built_in">stdin</span>);<span class="comment">//abc</span></span><br><span class="line">        buff[<span class="built_in">strlen</span>(buff) <span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// ls, ps -f , cp a.c b.c </span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* myargv[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//myargv[0]=&quot;cp&quot;, myargv[1]=&quot;a.c&quot; , myargv[2]=&quot;b.c&quot;</span></span><br><span class="line">        <span class="type">char</span>* cmd = get_cmd(buff,myargv);</span><br><span class="line">        <span class="keyword">if</span>( cmd == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(cmd,<span class="string">&quot;exit&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            execvp(cmd,myargv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到这个命令:%s\n&quot;</span>,buff);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-进程间通信（IPC机制）">24.进程间通信（IPC机制）</h3>
<p>管道，<strong>信号量，消息队列，共享内存</strong>，套接字，信号</p>
<h3 id="25-信号">25.信号</h3>
<p>信号:通知进程发生了某个事件</p>
<p>信号大部分由系统定义，其本质为宏定义，为内核函数。当执行某一操作时，发生信号，即一个整型值。用来决定内核函数的调用，其中，信号有三种使用方式，默认，忽略，自定义    signal（信号，函数指针）；SIG_DFL  0     SIG_IGN   1  ，两个宏定义</p>
<p>由于不符合signal函数参数类型，因此SIG_DFL和SIG_IGN相当于被强转为函数指针的宏定义作为参数，其中这两个是特例，当收到0默认调用，收到1忽略。signal（）相当于调整内核响应方式。我需要这个信号被怎么处理。</p>
<p>产生信号，kill 给进程发送某个信号，默认为15（终止进程），但也可以通过加参数发送其他信号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] &lt;信号&gt; &lt;进程ID&gt;...</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//pid：目标进程的 PID（特殊值：0 表示同组进程，-1 表示所有进程，-pid 表示进程组 pid）。</span></span><br><span class="line"><span class="comment">//sig：要发送的信号编号（0 用于检测进程是否存在，不发送信号）。</span></span><br><span class="line"><span class="comment">//返回值：成功返回 0，失败返回 -1 并设置 errno（如 ESRCH 表示进程不存在）。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>&lt;信号&gt;</code></strong>：可以是信号编号（如 <code>9</code>）或信号名（如 <code>KILL</code>），<strong>默认发送 <code>SIGTERM</code>（编号 <code>15</code>，请求进程终止）</strong>。</li>
<li><strong><code>&lt;进程ID&gt;</code></strong>：目标进程的 PID（可通过 <code>ps</code>、<code>pgrep</code> 等命令获取）。</li>
</ul>
<table>
<thead>
<tr>
<th>信号名</th>
<th>编号</th>
<th>含义及触发场景</th>
<th>默认行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGINT</code></td>
<td>2</td>
<td>用户按下 <code>Ctrl+C</code>，请求进程中断</td>
<td>终止进程</td>
</tr>
<tr>
<td><code>SIGQUIT</code></td>
<td>3</td>
<td>用户按下 <code>Ctrl+\</code>，请求进程退出并生成核心转储（core dump）</td>
<td>终止进程并生成 core dump</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>9</td>
<td>强制终止进程（“必杀信号”）</td>
<td>终止进程（不可捕获 / 忽略）</td>
</tr>
<tr>
<td><code>SIGTERM</code></td>
<td>15</td>
<td>请求进程终止（默认的 <code>kill</code> 命令信号），允许进程清理资源</td>
<td>终止进程</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>19</td>
<td>暂停进程执行</td>
<td>暂停进程（不可捕获 / 忽略）</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>18</td>
<td>恢复被暂停的进程</td>
<td>继续进程执行</td>
</tr>
<tr>
<td><code>SIGSEGV</code></td>
<td>11</td>
<td>段错误（进程访问无效内存地址）</td>
<td>终止进程并生成 core dump</td>
</tr>
<tr>
<td><code>SIGPIPE</code></td>
<td>13</td>
<td>向已关闭的管道（pipe）或套接字（socket）写入数据</td>
<td>终止进程</td>
</tr>
<tr>
<td><code>SIGALRM</code></td>
<td>14</td>
<td>定时器超时（如 <code>alarm()</code> 函数设置的定时）</td>
<td>终止进程</td>
</tr>
</tbody>
</table>
<p>三种相应方式</p>
<ol>
<li><strong>默认行为（Default）</strong>：内核预定义的处理，如终止进程、暂停、忽略等（见上表）。SIG_DFL 0</li>
<li><strong>忽略信号（Ignore）</strong>：进程不做任何处理（<code>SIGKILL</code> 和 <code>SIGSTOP</code> 不可忽略）。          SIG_IGN   1</li>
<li><strong>捕获信号（Catch）</strong>：进程执行自定义的信号处理函数（<code>SIGKILL</code> 和 <code>SIGSTOP</code> 不可捕获，确保系统能强制终止 / 暂停进程）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigint</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n收到 SIGINT 信号（编号：%d），程序即将退出...\n&quot;</span>, signum);</span><br><span class="line">    _exit(<span class="number">0</span>); <span class="comment">// 退出进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 SIGINT 信号的处理函数</span></span><br><span class="line">    signal(SIGINT, handle_sigint);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序运行中，按 Ctrl+C 测试信号处理...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 无限循环等待信号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>signal</code> 是简化接口，实现简单但存在历史缺陷（如自动重置、无信号掩码），仅适用于对可靠性要求不高的简单场景。</li>
<li><code>sigaction</code> 是功能完善、可靠的标准接口，支持信号掩码、高级处理逻辑和跨平台兼容，<strong>在实际开发中应优先使用 <code>sigaction</code></strong>。</li>
</ul>
<p>signal相当于告诉内核当收到这个信号时，执行什么操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT,handle_sigint);<span class="comment">//自定义行为  handle_sigin是自定义处理函数，但其类型必须为 void *(int)类型</span></span><br><span class="line">signal(SIGINT,SIG_IGN);<span class="comment">//忽略行为</span></span><br><span class="line"><span class="comment">//不做任何处理位默认行为或者在设定为自定义行为后再设置回默认行为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>signum</code></strong>：要操作的信号（如 <code>SIGINT</code>、<code>SIGTERM</code> 等，<code>SIGKILL</code> 和 <code>SIGSTOP</code> 不可捕获 / 修改）。</li>
<li><strong><code>act</code></strong>：指向 <code>struct sigaction</code> 结构体的指针，定义新的信号处理规则（<code>NULL</code> 表示仅获取当前设置）。</li>
<li><strong><code>oldact</code></strong>：用于保存之前的信号处理设置（<code>NULL</code> 表示不保存）。</li>
<li><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code> 并设置 <code>errno</code>。</li>
</ul>
<p><strong>连续多次发送同一个信号</strong>？</p>
<p>连续发送同一个信号的行为取决于信号类型 —— 标准信号可能合并丢失，实时信号会排队处理。</p>
<h3 id="26-管道">26.管道</h3>
<p><strong>半双工</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls | grep main</span><br><span class="line"><span class="comment">//bash会产生管道文件用于ls和grep的通信</span></span><br></pre></td></tr></table></figure>
<p>普通文件存在磁盘中属于IO   ①操作速度慢，②没有同步</p>
<p><strong>管道文件：必须有读和写同时打开，写入管道的数据在内存</strong>    （只有只读和只写打开）必须存在两个进程</p>
<p>管道中没有数据会阻塞，只有读/写，没有同时被两个进程分别以读写方式打开会阻塞</p>
<p><strong>头指针  和   尾指针</strong></p>
<p>当两个进程采用管道文件通信时，当某一进程关闭管道文件时，内核会发出信号（<strong>SIGPIPE  13</strong>）通知，结束进程，如果不想结束，则改变信号的响应方式。</p>
<p><strong>管道满：写端阻塞</strong></p>
<p><strong>管道空：读端阻塞</strong></p>
<p><strong>写端关闭：读端read()返回值0</strong></p>
<p><strong>读端关闭：写端write()会触发信号   SIGPIPE（异常）程序退出</strong></p>
<p><strong>写入管道数据在内存</strong></p>
<p><strong>有名管道：任意两个进程间通信</strong>                 <strong>mkfifo</strong></p>
<p><strong>无名管道：用于父子进程间的通信</strong>       <strong>pipe（int fd[2]）</strong>        	<strong>fd[0]固定读端        fd[1]固定写端</strong></p>
<p>创建无名管道时，管道文件已打开，只需要使用读或者写</p>
<p><strong>通过fork（）复制               同一时刻只能有一方读一方写，不能同时读或写     半双工</strong></p>
<p>1.创建有名管道文件                 管道文件只存此管道的属性，存储在磁盘，内容存储在内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo fifo</span><br></pre></td></tr></table></figure>
<p>eg:从管道文件读写数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//从管道文件读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;fifo&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd=%d\n&quot;</span>,fd);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> n=read(fd,buff,<span class="number">127</span>);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n=%d,buff=%s\n&quot;</span>,n,buff);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    <span class="comment">//写入管道文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> fd=open(<span class="string">&quot;fifo&quot;</span>,O_WRONLY);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buff,<span class="string">&quot;end&quot;</span>)==<span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    write(fd,buff,<span class="built_in">strlen</span>(buff));</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-信号量">27.信号量</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>核心作用</th>
<th>关键产出 / 操作</th>
<th>依赖参数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>semget</code></td>
<td>创建 / 查找信号量集</td>
<td>产出 semid（信号量集唯一标识）</td>
<td>key、nsems、semflg</td>
</tr>
<tr>
<td><code>semctl</code></td>
<td>管理信号量集（初始化、查询、销毁）</td>
<td>执行 SETVAL/GETVAL/IPC_RMID 等命令</td>
<td>semid、semnum、cmd</td>
</tr>
<tr>
<td><code>semop</code></td>
<td>执行 P/V 同步操作（核心同步逻辑）</td>
<td>实现资源申请（-1）/ 释放（+1）</td>
<td>semid、struct sembuf、nsops</td>
</tr>
</tbody>
</table>
<p>信号量数组。</p>
<p>信号量：同步进程       信号量需要自己定义</p>
<p>信号量是一种用于<strong>进程同步与互斥</strong>的 IPC 机制，本质是内核维护的<strong>计数器</strong>，通过<strong>P/V 原语</strong>（也叫 “wait/signal” 操作）实现对共享资源的访问控制。</p>
<ul>
<li>
<p><strong>计数器（Value）</strong>：表示可用资源的数量（或互斥锁的状态）。</p>
</li>
<li>
<p><strong>P 操作（Proberen）</strong>：计数器减 1，若计数器 <code>&lt;= 0</code>，进程阻塞。    获取资源</p>
</li>
<li>
<p><strong>V 操作（Verhogen）</strong>：计数器加 1，若计数器 <code>&lt;= 0</code>，唤醒一个阻塞进程。  释放资源</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>二进制信号量</strong></td>
<td>计数器只能取 <code>0</code> 或 <code>1</code>，等价于 “互斥锁”（Mutex）。</td>
<td>保护<strong>互斥资源</strong>（如共享内存、文件）</td>
</tr>
<tr>
<td><strong>计数信号量</strong></td>
<td>计数器可取 <code>0~N</code>，用于控制<strong>N 个同类资源</strong>的并发访问。</td>
<td>控制线程 / 进程对 “有限资源池” 的访问</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>临界资源：同一时刻只允许一个进程访问的资源</strong></p>
<p><strong>临界区：访问临界资源的代码段</strong>    <strong>pv操作代码自己设计，核心使临界资源访问高效，因此临界区不能很长</strong></p>
<p><strong>定义为四个方法</strong></p>
<p>sem.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">()</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_p</span><span class="params">()</span>;<span class="comment">//p操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_v</span><span class="params">()</span>;<span class="comment">//v操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_destroy</span><span class="params">()</span>;<span class="comment">//销毁操作</span></span><br></pre></td></tr></table></figure>
<p>sem.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> semid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    semid = semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">1</span>,IPC_CREAT|IPC_EXCL|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>( semid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        semid = semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">1</span>,<span class="number">0600</span>);</span><br><span class="line">        <span class="keyword">if</span>( semid == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;semget err\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">union</span> semun a;</span><br><span class="line">        a.val = <span class="number">1</span>;<span class="comment">//信号量初始值</span></span><br><span class="line">        <span class="keyword">if</span>( semctl(semid,<span class="number">0</span>,SETVAL,a) == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;semctl err\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_p</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = <span class="number">0</span>;</span><br><span class="line">    buf.sem_op = <span class="number">-1</span>;<span class="comment">//p</span></span><br><span class="line">    buf.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>( semop(semid,&amp;buf,<span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_v</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = <span class="number">0</span>;</span><br><span class="line">    buf.sem_op = <span class="number">1</span>;<span class="comment">//v</span></span><br><span class="line">    buf.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>( semop(semid,&amp;buf,<span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;v err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_destroy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( semctl(semid,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destroy err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>a.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p();<span class="comment">//p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">int</span> n = rand() % <span class="number">3</span>;<span class="comment">////临界区</span></span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_v();<span class="comment">//v</span></span><br><span class="line"></span><br><span class="line">        n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    sem_destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>b.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p();<span class="comment">//p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">int</span> n = rand() % <span class="number">3</span>;<span class="comment">//临界区</span></span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_v();<span class="comment">//v</span></span><br><span class="line"></span><br><span class="line">        n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                                                                                                                                                                                                 </span><br></pre></td></tr></table></figure>
<h3 id="28-共享内存">28.共享内存</h3>
<p>共享内存和信号量由于类别不同因此key就算相同也指向不同的类别，无影响</p>
<p>shmget创建共享内存</p>
<p>全双工</p>
<p><strong>不同进程的不同逻辑地址映射到同一块物理内存</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>共享内存（Shared Memory）</th>
<th>管道（Pipe/FIFO）</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>通信原理</td>
<td>映射同一块物理内存，进程直接读写，无内核中转</td>
<td>内核维护环形缓冲区，数据经「用户态→内核态→用户态」中转</td>
<td></td>
</tr>
<tr>
<td>数据拷贝次数</td>
<td>1 次（写进程→共享内存，读进程直接读取）</td>
<td>2 次（写进程→内核缓冲区→读进程）</td>
<td></td>
</tr>
<tr>
<td>通信效率</td>
<td>极高（接近内存访问速度，无额外中转开销）</td>
<td>较低（两次拷贝 + 系统调用开销）</td>
<td></td>
</tr>
<tr>
<td>通信方向</td>
<td>全双工（支持多进程同时读写）</td>
<td>匿名管道：半双工（单向）；命名管道：可双向但本质半双工</td>
<td></td>
</tr>
<tr>
<td>跨进程支持</td>
<td>任意进程（无亲缘关系），通过 key/shmid 访问</td>
<td>匿名管道：仅支持亲缘进程（依赖 fd 继承）；命名管道：任意进程（通过文件路径）</td>
<td></td>
</tr>
<tr>
<td>同步互斥机制</td>
<td>无内置机制，需手动搭配信号量 / 互斥锁</td>
<td>内置简单同步（写满阻塞、读空阻塞）；无内置互斥</td>
<td></td>
</tr>
<tr>
<td>生命周期</td>
<td>进程退出后仍存在，需显式调用 <code>shmctl(IPC_RMID)</code> 删除</td>
<td>匿名管道：随进程组终止销毁；命名管道：需手动 <code>rm</code> 删除文件</td>
<td></td>
</tr>
<tr>
<td>数据大小限制</td>
<td>可配置，受系统内存限制（<code>shmmax</code> 参数）</td>
<td>内核缓冲区固定（默认 4KB~64KB，可通过 <code>fcntl</code> 微调）</td>
<td></td>
</tr>
<tr>
<td>实现复杂度</td>
<td>较高（需处理内存映射 + 同步逻辑）</td>
<td>较低（匿名管道：<code>pipe()</code>+<code>read/write</code>；命名管道：<code>mkfifo()</code>+ 文件操作）</td>
<td></td>
</tr>
<tr>
<td>资源残留风险</td>
<td>易产生 “孤儿内存”，需手动清理</td>
<td>匿名管道无残留；命名管道可能残留文件</td>
<td></td>
</tr>
<tr>
<td>典型场景</td>
<td>高频、大数据量、低延迟通信（如视频流、实时数据同步）</td>
<td>简单交互、小数据量通信</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid = shmget((<span class="type">key_t</span>)<span class="number">1234</span>, <span class="number">128</span>, IPC_CREAT | <span class="number">0600</span>); <span class="comment">// 创建或获取共享内存，返回id</span></span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* s = (<span class="type">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 映射到当前进程地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (s == (<span class="type">char</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(s, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    shmdt(s); <span class="comment">// 断开映射,当前进程不能再使用共享内存，其他进程可继续访问</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid = shmget((<span class="type">key_t</span>)<span class="number">1234</span>, <span class="number">128</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 映射到当前进程地址空间</span></span><br><span class="line">    <span class="keyword">if</span> (s == (<span class="type">char</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s=%s\n&quot;</span>, s);</span><br><span class="line">    shmdt(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ipcs：查询 System V IPC 资源</strong></p>
<p>功能</p>
<p>列出系统中当前存在的共享内存、信号量、消息队列，显示关键信息（ID、键值、所有者、大小等），方便定位资源。</p>
<p>常用选项（核心组合）</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能说明</th>
<th>示例命令</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-m</code></td>
<td>仅显示 <strong>共享内存</strong> 资源（最常用）</td>
<td><code>ipcs -m</code></td>
</tr>
<tr>
<td><code>-s</code></td>
<td>仅显示 <strong>信号量</strong> 资源</td>
<td><code>ipcs -s</code></td>
</tr>
<tr>
<td><code>-i &lt;id&gt;</code></td>
<td>显示指定 ID 资源的详细信息（搭配 <code>-m/-s</code>）</td>
<td><code>ipcs -m -i 12345</code>（查看 shmid=12345 的详情）</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>显示资源的创建 / 最后操作时间</td>
<td><code>ipcs -m -t</code>（共享内存 + 时间）</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>显示使用资源的进程 PID（创建者 / 最后操作进程）</td>
<td><code>ipcs -m -p</code>（共享内存 + 进程 PID）</td>
</tr>
</tbody>
</table>
<p><strong>ipcrm：删除 System V IPC 资源</strong></p>
<p>功能</p>
<p>手动删除系统中残留的共享内存、信号量、消息队列（对应 C 代码的 <code>shmctl(IPC_RMID)</code>/<code>semctl(IPC_RMID)</code>，代码未调用时用此命令清理）</p>
<p>选项区分（避免混淆）</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th>作用对象</th>
<th>参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-m</code></td>
<td>共享内存</td>
<td>shmid（数字）</td>
</tr>
<tr>
<td style="text-align:center"><code>-M</code></td>
<td>共享内存</td>
<td>key（数字 / 十六进制）</td>
</tr>
<tr>
<td style="text-align:center"><code>-s</code></td>
<td>信号量</td>
<td>semid（数字）</td>
</tr>
<tr>
<td style="text-align:center"><code>-S</code></td>
<td>信号量</td>
<td>key（数字 / 十六进制）</td>
</tr>
</tbody>
</table>
<h4 id="共享内存与信号量的结合">共享内存与信号量的结合</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SEMID</span>&#123;</span>SEM1 = <span class="number">0</span>,SEM2&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">()</span>;<span class="comment">//创建两个信号量，或 获取id</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_p</span><span class="params">(<span class="keyword">enum</span> SEMID index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_v</span><span class="params">(<span class="keyword">enum</span> SEMID index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_destroy</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> semid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">()</span><span class="comment">//创建两个信号量，或 获取id</span></span><br><span class="line">&#123;</span><br><span class="line">    semid = semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">2</span>,IPC_CREAT|IPC_EXCL|<span class="number">0600</span>);<span class="comment">//全新创建，已存在，则失败</span></span><br><span class="line">    <span class="keyword">if</span>( semid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        semid = semget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">2</span>,<span class="number">0600</span>);<span class="comment">//获取</span></span><br><span class="line">        <span class="keyword">if</span>( semid == <span class="number">-1</span>  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;semget err\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">union</span> semun a;</span><br><span class="line">        <span class="type">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//初始化时，我们只需要 val 成员（存初始值），但必须把 val 包装到 union semun 中，才能符/							合 semctl 的接口要求 —— 内核会通过联合体的 val 成员读取你要设置的初始值。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.val = arr[i];</span><br><span class="line">            <span class="keyword">if</span>( semctl(semid,i,SETVAL,a) == <span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;semctl setval err\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_p</span><span class="params">(<span class="keyword">enum</span> SEMID index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = index;</span><br><span class="line">    buf.sem_op = <span class="number">-1</span>;<span class="comment">//p</span></span><br><span class="line">    buf.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>( semop(semid,&amp;buf,<span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_v</span><span class="params">(<span class="keyword">enum</span> SEMID index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = index;</span><br><span class="line">    buf.sem_op = <span class="number">1</span>;<span class="comment">//v</span></span><br><span class="line">    buf.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">if</span>( semop(semid,&amp;buf,<span class="number">1</span>) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;v err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_destroy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( semctl(semid,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;destroy err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid = shmget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">128</span>,IPC_CREAT|<span class="number">0600</span>);<span class="comment">//创建或获取共享内存，返回id</span></span><br><span class="line">    <span class="keyword">if</span>( shmid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* s = (<span class="type">char</span>*)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="comment">//映射到当前进程地址空间</span></span><br><span class="line">    <span class="keyword">if</span>( s == (<span class="type">char</span>*)<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shmat err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_init();<span class="comment">//创建或者获取信号量</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line"></span><br><span class="line">        sem_p(SEM1);<span class="comment">//p(s1)</span></span><br><span class="line">        <span class="built_in">strcpy</span>(s,buff);</span><br><span class="line">        sem_v(SEM2);<span class="comment">//v(s2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(buff,<span class="string">&quot;end&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shmdt(s);<span class="comment">//断开映射,当前进程就不能使用共享内存，其他进程可继续访问</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid = shmget((<span class="type">key_t</span>)<span class="number">1234</span>,<span class="number">128</span>,IPC_CREAT|<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>( shmid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span>*)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="comment">//映射到当前进程地址空间</span></span><br><span class="line">    <span class="keyword">if</span>( s == (<span class="type">char</span>*)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(SEM2);<span class="comment">//p(s2)</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(s,<span class="string">&quot;end&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%s\n&quot;</span>,s);</span><br><span class="line">        sem_v(SEM1);<span class="comment">//v(s1)</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(s);</span><br><span class="line">    sem_destroy();<span class="comment">//销毁信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-消息队列">29.消息队列</h3>
<p>消息队列亦称报文队列，也叫做信箱。这种通信机制传递的数据具有某种结构，而不是简单的字节流。它允许一个或多个进程向其中写入消息，也可以有一个或多个进程从其中读取消息，写入的消息会按照发送的顺序依次排列在队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span>   <span class="comment">// 消息队列相关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息结构（必须包含long类型的消息类型）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mess</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> type;       <span class="comment">// 消息类型（用于接收端筛选）</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">32</span>];   <span class="comment">// 消息数据（长度与发送/接收的字节数匹配）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或获取消息队列（key=1234，权限0600：所有者可读写）</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget((<span class="type">key_t</span>)<span class="number">1234</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 失败则退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mess</span> <span class="title">dt</span>;</span></span><br><span class="line">    dt.type = <span class="number">2</span>;                  <span class="comment">// 设置消息类型为2</span></span><br><span class="line">    <span class="built_in">strcpy</span>(dt.buff, <span class="string">&quot;hello2&quot;</span>);    <span class="comment">// 填充消息内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息（参数：队列ID、消息地址、数据部分长度、标志0=阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (msgsnd(msgid, (<span class="type">void</span>*)&amp;dt, <span class="number">32</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 发送失败处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span>   <span class="comment">// 消息队列相关函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与发送端一致的消息结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mess</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> type;       <span class="comment">// 消息类型</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">32</span>];   <span class="comment">// 消息数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取已创建的消息队列（key=1234，权限0600）</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget((<span class="type">key_t</span>)<span class="number">1234</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 获取失败处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mess</span> <span class="title">dt</span>;</span></span><br><span class="line">    <span class="comment">// 接收消息（参数：队列ID、消息地址、数据部分长度、类型0=任意类型、标志0=阻塞）</span></span><br><span class="line">    <span class="keyword">if</span> (msgrcv(msgid, (<span class="type">void</span>*)&amp;dt, <span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  <span class="comment">// 接收失败处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印接收的消息内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dt.buff=%s\n&quot;</span>, dt.buff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="30-套接字">30.套接字</h3>
<h3 id="31-线程">31.线程</h3>
<h4 id="进程线程的区别">进程线程的区别</h4>
<p>进程：一个正在运行的程序，操作系统资源分配的基本单位，资源互相隔离。</p>
<p>线程：进程内部的一条执行序列      单线程     多线程（并发），是进程内的<strong>执行单元</strong>，是 CPU 调度和执行的基本单位，共享所属进程的资源。</p>
<p><strong>LINUX系统为内核级，把线程当作进程来调度，没有定义线程的数据结构，只是让这两个进程（线程）共享地址空间，本质上还是以进程的方式实现，但对外展示位父线程ID号，存在  taskstruct  结构体线程控制块PCB。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf<span class="comment">//显示进程中的线程</span></span><br></pre></td></tr></table></figure>
<p><strong>无论是JAVA/c/c++在Linux系统中都为内核级，本质一样</strong></p>
<p><strong>①内核中线程与进程的区别？</strong></p>
<p>Linux 内核中，无论是进程还是线程，都使用同一个核心数据结构<code>task_struct</code>（任务结构体）来描述。内核并不区分 “进程” 和 “线程”，只区分不同的<strong>任务</strong></p>
<ul>
<li><strong>普通进程</strong>：拥有独立的地址空间、文件描述符、信号处理等资源，<code>task_struct</code>中的<code>mm_struct</code>（内存描述符）指向独立的地址空间。</li>
<li><strong>线程（LWP）</strong>：与其他线程共享同一进程的地址空间、文件描述符等资源，多个线程的<code>task_struct</code>指向同一个<code>mm_struct</code>，仅保留私有栈、寄存器、调度优先级等独立属性。</li>
</ul>
<p>Linux 中的线程本质上是一组共享大部分资源的进程：</p>
<ul>
<li>同一进程内的所有线程属于同一个 “线程组”（Thread Group），共享进程的 PID（主线程的 PID 作为线程组 ID）。</li>
<li>线程的创建通过<code>clone()</code>系统调用实现，与进程创建（<code>fork()</code>）的区别仅在于传入的参数 —— 线程创建时会指定共享地址空间（<code>CLONE_VM</code>）、文件描述符表（<code>CLONE_FILES</code>）、信号处理表（<code>CLONE_SIGHAND</code>）等资源，而进程创建时默认不共享。</li>
</ul>
<p>在 Linux 中，<strong>每个线程在内核中有独立的 TID（线程 ID，也叫 LWP，轻量级进程 ID）</strong>，这是内核真正用于标识任务的唯一 ID，相当于线程的 “内核级 PID”；而<strong>用户层工具（如<code>ps</code>、<code>top</code>）默认展示的 “PID” 其实是线程组 ID（TGID）</strong>，同一进程内的所有线程共享这个 TGID（等于主线程的 TID），因此对外呈现为同一个 “PID”（进程 PID）。</p>
<p>简单总结：</p>
<ul>
<li>线程有内核层面独立的 TID（可视为 “真实 PID”）；</li>
<li>对外展示时统一使用线程组的 TGID（即进程 PID），因此用户视角下同一进程的线程共享同一个 “PID”</li>
<li>线程的内核唯一标识和对外展示的 ID 是分离的，对外统一展示进程级的 ID。</li>
</ul>
<p><strong>②线程实现</strong></p>
<p>用户级线程：多对一     只能并发</p>
<p>内核级：一对一          并行</p>
<p>组合：多对多        可并发可并行</p>
<p><strong>③并发与并行</strong></p>
<p>并发：一个处理器交替执行</p>
<p>并行：多个处理器同时运行</p>
<p>多线程运行起来的时候必须保证正确性，每个线程可以得到自己正确的结果</p>
<p>pthread.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入标准输入输出头文件，用于printf等输出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入标准库头文件，用于exit等函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入POSIX标准头文件，用于sleep等系统调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入字符串处理头文件（本示例未直接使用，但为规范保留）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入线程库头文件，用于pthread_create/pthread_join等线程操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 子线程的入口函数</span></span><br><span class="line"><span class="comment"> * @param arg 线程创建时传入的参数（本示例为NULL）</span></span><br><span class="line"><span class="comment"> * @return void* 线程退出时的返回值（本示例返回字符串常量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子线程循环执行5次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印子线程运行信息（含\n触发stdout行缓冲刷新）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun run\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 子线程休眠1秒（释放CPU，让其他线程有机会执行）</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子线程退出，返回字符串&quot;fun over\n&quot;作为退出状态（pthread_exit用于显式返回值）</span></span><br><span class="line">    pthread_exit(<span class="string">&quot;fun over\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 主线程入口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义pthread_t类型变量，用于存储子线程的ID（唯一标识线程）</span></span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="comment">// 创建子线程：</span></span><br><span class="line">    <span class="comment">// &amp;id：存储新创建线程的ID</span></span><br><span class="line">    <span class="comment">// NULL：使用默认的线程属性（如栈大小、调度策略等）</span></span><br><span class="line">    <span class="comment">// fun：子线程的入口函数</span></span><br><span class="line">    <span class="comment">// NULL：传递给fun函数的参数（本示例无参数）</span></span><br><span class="line">    pthread_create(&amp;id, <span class="literal">NULL</span>, fun, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程循环执行2次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印主线程运行信息（含\n触发stdout行缓冲刷新）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main run\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 主线程休眠1秒（释放CPU，让子线程有机会执行）</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义字符指针，用于接收子线程退出时的返回值</span></span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 阻塞等待ID为id的子线程结束：</span></span><br><span class="line">    <span class="comment">// id：要等待的子线程ID</span></span><br><span class="line">    <span class="comment">// (void**)&amp;s：接收子线程的返回值（pthread_exit的参数）</span></span><br><span class="line">    pthread_join(id, (<span class="type">void</span>**)&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印子线程返回的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s=%s\n&quot;</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主线程正常退出（exit(0)表示成功，会自动刷新stdout缓冲区）</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多线程争抢资源解决：">多线程争抢资源解决：</h4>
<p>在linux系统上用的原生创建机制</p>
<h5 id="①线程间信号量">①线程间信号量</h5>
<p>解决：线程间信号量来控制唯一资源的使用</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>线程间信号量</th>
<th>进程间信号量</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享范围</td>
<td>仅同一进程内的所有线程共享</td>
<td>不同进程之间共享（跨进程）</td>
</tr>
<tr>
<td>存储位置</td>
<td>进程的全局变量、堆内存（进程地址空间内）</td>
<td>进程间共享内存（如 POSIX 共享内存）或文件系统标识（有名信号量）</td>
</tr>
<tr>
<td>初始化参数（POSIX）</td>
<td><code>sem_init</code>的<code>pshared=0</code></td>
<td>无名信号量：<code>sem_init</code>的<code>pshared=1</code>；有名信号量：<code>sem_open</code>创建</td>
</tr>
<tr>
<td>生命周期</td>
<td>随所属进程的终止而销毁</td>
<td>系统级资源，进程退出后仍存在，需显式销毁</td>
</tr>
<tr>
<td>销毁方式</td>
<td>调用<code>sem_destroy</code>即可释放进程内资源</td>
<td>无名信号量：先<code>sem_destroy</code>再释放共享内存；有名信号量：<code>sem_unlink</code>删除标识</td>
</tr>
<tr>
<td>实现依赖</td>
<td>依赖进程内地址空间共享，无需额外系统资源</td>
<td>依赖共享内存或文件系统，需跨进程访问机制</td>
</tr>
<tr>
<td>权限控制</td>
<td>继承进程权限，无需额外配置</td>
<td>需设置跨进程访问权限（如<code>sem_open</code>指定<code>0644</code>）</td>
</tr>
<tr>
<td>典型 API（POSIX）</td>
<td><code>sem_init</code>（pshared=0）、<code>sem_wait</code>、<code>sem_post</code></td>
<td>无名：<code>sem_init</code>（pshared=1）+ 共享内存；有名：<code>sem_open</code>/<code>sem_close</code>/<code>sem_unlink</code></td>
</tr>
<tr>
<td>典型场景</td>
<td>进程内线程同步（如共享变量访问、线程池调度）</td>
<td>多进程资源竞争（如共享文件、硬件设备访问）</td>
</tr>
<tr>
<td>资源开销</td>
<td>开销低（进程内内存操作）</td>
<td>开销较高（涉及系统级共享资源管理）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><code>sem_init</code></th>
<th><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code></th>
<th>- <code>sem</code>：指向要初始化的信号量对象（线程间可存全局 / 堆内存）- <code>pshared</code>：<strong>必须设为 0</strong>（表示线程间共享）- <code>value</code>：信号量初始值（二进制设 1，计数设资源总数）</th>
<th>初始化线程间信号量，<code>pshared=0</code>是线程间使用的关键标识；需在创建线程前初始化，避免竞争。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sem_wait</code></td>
<td><code>int sem_wait(sem_t *sem);</code></td>
<td><code>sem</code>：已初始化的线程间信号量对象</td>
<td>P 操作（申请资源）：原子减 1，值 &lt; 0 则阻塞线程；线程间用于进入临界区，确保互斥 / 同步。</td>
</tr>
<tr>
<td><code>sem_post</code></td>
<td><code>int sem_post(sem_t *sem);</code></td>
<td><code>sem</code>：已初始化的线程间信号量对象</td>
<td>V 操作（释放资源）：原子加 1，值≤0 则唤醒阻塞线程；线程间用于退出临界区，释放资源。</td>
</tr>
<tr>
<td><code>sem_destroy</code></td>
<td><code>int sem_destroy(sem_t *sem);</code></td>
<td><code>sem</code>：已初始化的线程间信号量对象</td>
<td>销毁线程间信号量，释放进程内资源；需在所有线程使用完信号量后调用，避免资源泄漏。</td>
</tr>
</tbody>
</table>
<p>三个线程轮流打印ABCABCABC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sema;<span class="comment">//通过三个信号量解决</span></span><br><span class="line"><span class="type">sem_t</span> semb;</span><br><span class="line"><span class="type">sem_t</span> semc;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">funa</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;sema); <span class="comment">// ps1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_post(&amp;semb); <span class="comment">// vs2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">funb</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;semb); <span class="comment">// ps2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_post(&amp;semc); <span class="comment">// vs3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;semc); <span class="comment">// ps3</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sem_post(&amp;sema); <span class="comment">// vs1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;sema, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;semb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;semc, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> ida, idb, idc;</span><br><span class="line">    pthread_create(&amp;ida, <span class="literal">NULL</span>, funa, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;idb, <span class="literal">NULL</span>, funb, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;idc, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(ida, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(idb, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(idc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;sema);</span><br><span class="line">    sem_destroy(&amp;semb);</span><br><span class="line">    sem_destroy(&amp;semc);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②互斥锁">②互斥锁</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义全局互斥锁对象（线程间共享）</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 互斥锁核心函数原型及参数作用说明：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. 初始化互斥锁</span></span><br><span class="line"><span class="comment"> * @param mutex: 指向要初始化的pthread_mutex_t类型互斥锁对象的指针（输出参数，初始化后可使用）</span></span><br><span class="line"><span class="comment"> * @param attr: 互斥锁属性指针（输入参数），NULL表示使用默认属性（如普通锁类型、线程间共享）</span></span><br><span class="line"><span class="comment"> * @return: 成功返回0，失败返回非0错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 阻塞加锁（获取互斥锁）</span></span><br><span class="line"><span class="comment"> * @param mutex: 指向已初始化的互斥锁对象的指针（输入参数），尝试锁定该互斥锁</span></span><br><span class="line"><span class="comment"> * @return: 成功返回0，失败返回非0错误码（如EINVAL表示锁未初始化）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 非阻塞加锁（尝试获取互斥锁）</span></span><br><span class="line"><span class="comment"> * @param mutex: 指向已初始化的互斥锁对象的指针（输入参数）</span></span><br><span class="line"><span class="comment"> * @return: 成功返回0；锁被占用时返回EBUSY，其他错误返回对应错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4. 解锁（释放互斥锁）</span></span><br><span class="line"><span class="comment"> * @param mutex: 指向已锁定的互斥锁对象的指针（输入参数），仅持有锁的线程可调用</span></span><br><span class="line"><span class="comment"> * @return: 成功返回0，失败返回非0错误码（如EPERM表示无锁所有权）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5. 销毁互斥锁</span></span><br><span class="line"><span class="comment"> * @param mutex: 指向已初始化的互斥锁对象的指针（输入参数），释放锁占用的资源</span></span><br><span class="line"><span class="comment"> * @return: 成功返回0，失败返回非0错误码（如EBUSY表示锁仍被持有）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>示例：注释部分为信号量PV操作            带本身为互斥锁的应用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sem_t sem;//定义信号量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义互斥锁</span></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//sem_wait(&amp;sem);//p</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;g_val=%d\n&quot;</span>,g_val++);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="comment">//sem_post(&amp;sem);//v</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//sem_init(&amp;sem,0,1);//初始化信号量 值为1</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> id[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;id[i],<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(id[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sem_destroy(&amp;sem);//销毁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③条件变量">③条件变量</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化条件变量</span></span><br><span class="line"><span class="comment">// - cond：指向要初始化的条件变量（pthread_cond_t类型）</span></span><br><span class="line"><span class="comment">// - cond_attr：条件变量属性（通常传NULL用默认属性）</span></span><br><span class="line"><span class="comment">// - 返回值：0=成功，非0=失败（如EINVAL=参数无效）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* cond_attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 销毁条件变量</span></span><br><span class="line"><span class="comment">// - cond：指向已初始化的条件变量</span></span><br><span class="line"><span class="comment">// - 返回值：0=成功，非0=失败（如EBUSY=条件变量仍被线程等待）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 广播唤醒：唤醒所有等待该条件变量的线程</span></span><br><span class="line"><span class="comment">// - cond：指向条件变量</span></span><br><span class="line"><span class="comment">// - 返回值：0=成功，非0=失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 单线程唤醒：唤醒1个等待该条件变量的线程（通常是等待队列的第一个）</span></span><br><span class="line"><span class="comment">// - cond：指向条件变量</span></span><br><span class="line"><span class="comment">// - 返回值：0=成功，非0=失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 等待条件变量：阻塞线程，直到被唤醒+条件满足</span></span><br><span class="line"><span class="comment">// - cond：指向条件变量</span></span><br><span class="line"><span class="comment">// - mutex：关联的互斥锁（调用时会自动释放锁，被唤醒后自动重新获取锁）</span></span><br><span class="line"><span class="comment">// - 返回值：0=成功，非0=失败（如EINVAL=参数无效）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_mutex_t</span>* mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>    <span class="comment">// 标准输入输出函数（如printf、fgets）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">// 标准库函数（如exit）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">// 系统调用函数（如sleep，本代码未使用）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>   <span class="comment">// 字符串操作函数（如strncmp、memset）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span>  <span class="comment">// 线程相关函数（线程创建、锁、条件变量等）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局条件变量：用于线程间同步，实现&quot;等待-唤醒&quot;机制</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 全局互斥锁：保护共享资源（buff），同时与条件变量配合使用（条件变量必须依赖互斥锁）</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 全局共享缓冲区：main线程写入数据，funa/funb线程读取数据，需互斥访问</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程A函数：等待条件变量唤醒，读取并打印共享缓冲区内容</span></span><br><span class="line"><span class="comment"> * @param arg 线程传入参数（本代码未使用，设为NULL）</span></span><br><span class="line"><span class="comment"> * @return void* 线程返回值（本代码未使用，返回NULL）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funa</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 线程循环运行，直到收到&quot;end&quot;退出信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 加互斥锁：保护共享资源buff，同时满足pthread_cond_wait的调用要求（必须持有锁）</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2. 等待条件变量：核心同步操作，做三件事（原子执行）：</span></span><br><span class="line"><span class="comment">         *    a) 释放已持有的互斥锁（让其他线程有机会操作共享资源）</span></span><br><span class="line"><span class="comment">         *    b) 将当前线程加入条件变量的等待队列，阻塞休眠</span></span><br><span class="line"><span class="comment">         *    c) 被唤醒后，自动重新获取互斥锁，然后函数返回</span></span><br><span class="line"><span class="comment">         * 注意：必须在加锁后调用，否则会报错；唤醒后需重新检查共享资源状态（本代码逻辑简单未检查，实际复杂场景需用while循环）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 释放互斥锁：当前线程已获取到锁并完成后续判断，释放锁让其他线程使用</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 判断是否收到退出信号：比较buff前3个字符是否为&quot;end&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;funa：收到退出信号，即将退出\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 退出循环，线程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 5. 打印共享缓冲区内容（非退出信号时）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;funa：读取到内容 -&gt; %s&quot;</span>, buff);  <span class="comment">// fgets读取的内容包含换行符，printf无需额外加\n</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 线程函数返回（NULL表示无返回数据）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线程B函数：功能与funa完全一致，等待条件变量唤醒并打印共享缓冲区内容</span></span><br><span class="line"><span class="comment"> * @param arg 线程传入参数（本代码未使用，设为NULL）</span></span><br><span class="line"><span class="comment"> * @return void* 线程返回值（本代码未使用，返回NULL）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funb</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 线程循环运行，直到收到&quot;end&quot;退出信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 加互斥锁：保护共享资源buff，配合条件变量使用</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 等待条件变量：阻塞等待被main线程唤醒，唤醒后自动重加锁</span></span><br><span class="line">        pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 释放互斥锁：避免长时间持有锁导致其他线程阻塞</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 判断是否收到退出信号</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;funb：收到退出信号，即将退出\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 退出循环，线程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 5. 打印共享缓冲区内容</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;funb：读取到内容 -&gt; %s&quot;</span>, buff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 主函数：程序入口，负责初始化资源、创建线程、读取输入、唤醒线程、清理资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化互斥锁：第二个参数为锁属性，NULL表示使用默认属性（非递归、非共享）</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 2. 初始化条件变量：第二个参数为条件变量属性，NULL表示使用默认属性</span></span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个线程ID（pthread_t类型用于唯一标识线程）</span></span><br><span class="line">    <span class="type">pthread_t</span> ida, idb;</span><br><span class="line">    <span class="comment">// 3. 创建线程A：参数依次为（线程ID指针、线程属性、线程函数、函数参数）</span></span><br><span class="line">    pthread_create(&amp;ida, <span class="literal">NULL</span>, funa, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 4. 创建线程B：同上，绑定到funb函数</span></span><br><span class="line">    pthread_create(&amp;idb, <span class="literal">NULL</span>, funb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 主线程循环：读取标准输入，控制线程唤醒逻辑</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从标准输入（键盘）读取字符串到buff，最多读127个字符（留1个给&#x27;\0&#x27;）</span></span><br><span class="line">        fgets(buff, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断输入是否为退出信号（前3个字符为&quot;end&quot;）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buff, <span class="string">&quot;end&quot;</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;main：收到退出指令，唤醒所有等待线程...\n&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 加互斥锁：虽然此处仅唤醒线程，未直接修改buff，但规范上条件变量操作需在锁保护下（避免竞态）</span></span><br><span class="line">            pthread_mutex_lock(&amp;mutex);</span><br><span class="line">            <span class="comment">// 广播唤醒：唤醒所有等待该条件变量的线程（funa和funb同时被唤醒）</span></span><br><span class="line">            pthread_cond_broadcast(&amp;cond);</span><br><span class="line">            <span class="comment">// 释放互斥锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 退出主线程输入循环，准备等待线程结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 非退出指令：唤醒一个等待线程（funa或funb，由系统调度决定）</span></span><br><span class="line">            pthread_mutex_lock(&amp;mutex);</span><br><span class="line">            <span class="comment">// 单线程唤醒：从条件变量的等待队列中选一个线程唤醒（默认FIFO顺序）</span></span><br><span class="line">            pthread_cond_signal(&amp;cond);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 等待线程结束：主线程阻塞，直到ida和idb对应的线程执行完毕（避免线程未退出主线程先结束）</span></span><br><span class="line">    pthread_join(ida, <span class="literal">NULL</span>);  <span class="comment">// 第二个参数为线程返回值指针，NULL表示不接收返回值</span></span><br><span class="line">    pthread_join(idb, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. 清理资源：销毁互斥锁和条件变量，释放系统资源（必须在所有线程结束后调用）</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main：所有线程已退出，资源清理完成，程序结束\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="④读写锁">④读写锁</h5>
<p>多个可以同时读，但是只能一个写，写时不可读</p>
<p>互斥锁使用场景的细化</p>
<ul>
<li><code>pthread_rwlock_init</code>：初始化读写锁（需传入锁对象地址、锁属性，通常传<code>NULL</code>用默认属性）。</li>
<li><code>pthread_rwlock_rdlock</code>：<strong>加读锁</strong>（允许多个读线程同时持有，写线程会阻塞）。</li>
<li><code>pthread_rwlock_wrlock</code>：<strong>加写锁</strong>（独占锁，同一时间仅一个写线程持有，读 / 其他写线程会阻塞）。</li>
<li><code>pthread_rwlock_unlock</code>：释放读锁 / 写锁（无论之前加的是读锁还是写锁，统一用该函数解锁）。</li>
<li>当调用 <code>pthread_rwlock_unlock</code> 时，锁会自动完成以下判断和操作：
<ul>
<li>若当前是 “写锁持有” 状态：直接将状态置为 “空闲”，唤醒等待队列中的线程（读 / 写线程按优先级竞争）；</li>
<li>若当前是 “读锁持有” 状态：将读锁计数器减 1，若计数器减至 0（所有读线程都已释放），则将状态置为 “空闲”，唤醒等待的写线程。</li>
</ul>
</li>
<li><code>pthread_rwlock_destroy </code>：销毁锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> lock; <span class="comment">// 读写锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;lock); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun1 读开始\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun1 读结束\n&quot;</span>);</span><br><span class="line">        pthread_rwlock_unlock(&amp;lock); <span class="comment">// 解锁</span></span><br><span class="line">        <span class="type">int</span> n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;lock); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun2 读开始\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fun2 读结束\n&quot;</span>);</span><br><span class="line">        pthread_rwlock_unlock(&amp;lock); <span class="comment">// 解锁</span></span><br><span class="line">        n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">fun3</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------fun3 开始写\n&quot;</span>);</span><br><span class="line">        <span class="type">int</span> n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------fun3 写结束\n&quot;</span>);</span><br><span class="line">        pthread_rwlock_unlock(&amp;lock);</span><br><span class="line">        n = rand() % <span class="number">3</span>;</span><br><span class="line">        sleep(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">pthread_t</span> id1, id2, id3;</span><br><span class="line">    pthread_create(&amp;id1, <span class="literal">NULL</span>, fun1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;id2, <span class="literal">NULL</span>, fun2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;id3, <span class="literal">NULL</span>, fun3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(id3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;lock);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生产者-消费者问题">生产者/消费者问题</h4>
<p>生产者消费者问题（Producer-Consumer Problem）是<strong>进程 / 线程同步</strong>中的经典问题，核心矛盾是：有一块缓冲区，<strong>生产者线程生产数据，消费者线程消费数据</strong>，需保证两者的协作 —— 生产者不能在缓冲区满时继续生产，消费者不能在缓冲区空时继续消费</p>
<p>操作系统概念</p>
<p><strong>先pv操作，后互斥</strong></p>
<p><strong>如果先互斥则当一方不能操作并且获得锁时会产生死锁</strong></p>
<p><strong>当一段代码可以写入临界区内或者外时，写到临界区外部。</strong></p>
<p>**解决：**通过互斥锁和信号量解决</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_SIZE 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SC_NUM 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XF_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buff[BUFF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> in = <span class="number">0</span>;<span class="comment">//生产者 写数据的位置</span></span><br><span class="line"><span class="type">int</span> out = <span class="number">0</span>;<span class="comment">//消费者取数据的位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty_sem;<span class="comment">//空闲格子的数目</span></span><br><span class="line"><span class="type">sem_t</span> full_sem;<span class="comment">//有数据的格子数目</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//互斥锁，用来保证生产者消费者互斥访问缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sc_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;empty_sem);<span class="comment">//ps1</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);<span class="comment">//lock</span></span><br><span class="line">        buff[in] = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者在%d位置，产生数据:%d\n&quot;</span>,in,buff[in]);</span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFF_SIZE;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);<span class="comment">//unlock</span></span><br><span class="line">        sem_post(&amp;full_sem);<span class="comment">//vs2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">xf_fun</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;full_sem);<span class="comment">//ps2</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----消费者在%d位置，取数据:%d\n&quot;</span>,out,buff[out]);</span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFF_SIZE;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;empty_sem);<span class="comment">//vs1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_init(&amp;empty_sem,<span class="number">0</span>,BUFF_SIZE);<span class="comment">//</span></span><br><span class="line">    sem_init(&amp;full_sem,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));<span class="comment">//初始化随机数种子 rand()</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> sc_id[SC_NUM];</span><br><span class="line">    <span class="type">pthread_t</span> xf_id[XF_NUM];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SC_NUM; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;sc_id[i],<span class="literal">NULL</span>,sc_fun,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; XF_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;xf_id[i],<span class="literal">NULL</span>,xf_fun,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; SC_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(sc_id[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; XF_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(xf_id[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;empty_sem);</span><br><span class="line">    sem_destroy(&amp;full_sem);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读者-写者问题">读者/写者问题</h4>
<h4 id="多线程安全">多线程安全</h4>
<p>eg:strtok()函数不能在多线程使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>*arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[]=<span class="string">&quot;1 2 3 4 5&quot;</span>;</span><br><span class="line">    <span class="type">char</span>*s= strtok(buff,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        s=strtok(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> ID1;</span><br><span class="line">    pthread_create(&amp;ID1,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buff[]=<span class="string">&quot;a b c d e&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s=strtok(buff,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        s=strtok(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(ID1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>此代码会输出错误，因为strtok中有个全局变量来记录指针位置，多线程中使用会改变此全局变量导致错误</strong></p>
<p><strong>当存在多个函数调用全局变量时要注意是否产生影响</strong></p>
<p><strong>解决：使用线程安全函数 或者 手搓函数</strong>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//改用strtok_r()线程安全函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">fun</span><span class="params">(<span class="type">void</span>*arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[]=<span class="string">&quot;1 2 3 4 5&quot;</span>;</span><br><span class="line">    <span class="type">char</span>*ptr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>*s= strtok_r(buff,<span class="string">&quot; &quot;</span>,&amp;ptr);</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        s=strtok_r(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>,&amp;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> ID1;</span><br><span class="line">    pthread_create(&amp;ID1,<span class="literal">NULL</span>,fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buff[]=<span class="string">&quot;a b c d e&quot;</span>;</span><br><span class="line">    <span class="type">char</span>*ptr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *s=strtok_r(buff,<span class="string">&quot; &quot;</span>,&amp;ptr);</span><br><span class="line">    <span class="keyword">while</span>(s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        s=strtok_r(<span class="literal">NULL</span>,<span class="string">&quot; &quot;</span>,&amp;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(ID1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/">http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">WF的知识空间</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言</div></div><div class="info-2"><div class="info-item-1">1.什么是指针 描述:由来+描述 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024Byte 1Byte=8bit  每一个Bit物理原件可以保存0或1 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 为什么？ 在计算机内部存在32根地址线供计算机给每个字节（内存中的最小单元）都分配了地址和编号 每一根电线	正电荷1	负电荷0(不固定)					  十六进制（0X）    8bit的空间 第一块字节编号	00000000 00000000 00000000 00000000	0X 00 00 00 00	00000000 第二块字节编号	00000000 00000000 00000000 00000001	0X 00 00 00 01	00000001 第三块字节编号	00000000 00000000 00000000 00000010	0X 00 00 00 02	00000010 第四块字节编号	...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WF</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WF-git-code"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="//github.com/WF-git-code" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18628492787@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">1.Linux系统基础文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">2.Linux系统基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%82%E6%94%BE%E5%A4%A7%E7%95%8C%E9%9D%A2%EF%BC%9Actrl-shift-%E2%80%9C-%E2%80%9D%E7%BC%A9%E5%B0%8F%E7%95%8C%E9%9D%A2%EF%BC%9Actrl-%E2%80%9D-%E2%80%9C"><span class="toc-number">2.0.1.</span> <span class="toc-text">1。放大界面：ctrl+shift+“+”			缩小界面：ctrl+”-“</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.第一个字符：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E4%B8%BA%E4%B8%89%E7%BB%84%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%80%85%E6%9D%83%E9%99%90%E7%BB%84%E5%91%98%E6%9D%83%E9%99%90%E5%85%B6%E4%BB%96%E4%BA%BA%E6%9D%83%E9%99%90rwx%E5%8F%AF%E8%AF%BB%E5%8F%AF%E5%86%99%E5%8F%AF%E6%89%A7%E8%A1%8C-777"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.分为三组：创建者权限	组员权限	其他人权限	rwx可读可写可执行   777</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90chmod"><span class="toc-number">2.0.4.</span> <span class="toc-text">4,修改文件权限	chmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-pwd%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.0.5.</span> <span class="toc-text">5.pwd查看当前位置绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-man%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%8B%E5%86%8C%E5%8F%82%E6%95%B0%E4%B8%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.6.</span> <span class="toc-text">6.man：查看手册	参数为命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-ls"><span class="toc-number">2.0.7.</span> <span class="toc-text">7.ls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95mkdir-%E7%9B%AE%E5%BD%95%E5%90%8D"><span class="toc-number">2.0.8.</span> <span class="toc-text">8.创建目录	mkdir+目录名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95rmdir-%E7%9B%AE%E5%BD%95%E5%90%8D"><span class="toc-number">2.0.9.</span> <span class="toc-text">9.删除目录	rmdir+目录名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-vi%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">2.0.10.</span> <span class="toc-text">10.vi编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E8%BF%9B%E5%85%A5vi%E7%BC%96%E8%BE%91%E5%99%A8-%E7%9B%B8%E5%BD%93%E4%BA%8Ewinoows%E4%B8%8B%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC"><span class="toc-number">2.0.10.1.</span> <span class="toc-text">①进入vi编辑器(相当于winoows下的记事本)*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.0.10.2.</span> <span class="toc-text">②编辑模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.0.10.3.</span> <span class="toc-text">③命令模式:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-cat-%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">2.0.11.</span> <span class="toc-text">11.cat:在屏幕上打印文件信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12mv-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.12.</span> <span class="toc-text">12mv:移动文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.13.</span> <span class="toc-text">13.通配符的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-which-%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">2.0.14.</span> <span class="toc-text">14.which+命令：查找命令所在的文件在哪里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-find"><span class="toc-number">2.0.15.</span> <span class="toc-text">15.find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-tail-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-number">2.0.16.</span> <span class="toc-text">16.tail	 查看文件尾部内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-more%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-%E4%BB%A5%E7%BF%BB%E9%A1%B5%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.0.17.</span> <span class="toc-text">17.more	查看文件内容(以翻页形式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-cmp%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-number">2.0.18.</span> <span class="toc-text">18.cmp	比较两个文件是否相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9Dcp"><span class="toc-number">2.0.19.</span> <span class="toc-text">19.文件拷贝	cp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-head"><span class="toc-number">2.0.20.</span> <span class="toc-text">20.head</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%9D%83%E9%99%90%E6%8E%A9%E7%A0%81"><span class="toc-number">2.0.21.</span> <span class="toc-text">21.权限掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%89%93%E5%8C%85tar"><span class="toc-number">2.0.22.</span> <span class="toc-text">22.打包	tar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E6%B8%85%E5%B1%8Fclear"><span class="toc-number">2.0.23.</span> <span class="toc-text">23.清屏	clear</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7who"><span class="toc-number">2.0.24.</span> <span class="toc-text">24.查看当前用户	who</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F-date"><span class="toc-number">2.0.25.</span> <span class="toc-text">25.显示时间和日期:	date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-pS"><span class="toc-number">2.0.26.</span> <span class="toc-text">26.查看进程: 	pS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill-%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B-kill-%E8%BF%9B%E7%A8%8BID"><span class="toc-number">2.0.27.</span> <span class="toc-text">kill   结束进程    kill+进程ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4-ifconfig"><span class="toc-number">2.0.28.</span> <span class="toc-text">27.网络命令:	ifconfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-rm-%E5%88%A0%E9%99%A4"><span class="toc-number">2.0.29.</span> <span class="toc-text">28.rm 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-find-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.30.</span> <span class="toc-text">29.find    搜索文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-%E7%AE%A1%E9%81%93-%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BE%93%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.0.31.</span> <span class="toc-text">30.管道	|   两个进程传输信息的工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E8%BF%87%E6%BB%A4-grep-%E5%AF%B9%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">2.0.32.</span> <span class="toc-text">31.过滤     grep  对命令执行结果进行过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-top-%E7%9B%B8%E5%BD%93%E4%BA%8Ewindows%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.0.33.</span> <span class="toc-text">32.top  相当于windows的任务管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-ldd-%E5%87%BD%E6%95%B0%E5%90%8D%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">2.0.34.</span> <span class="toc-text">33.ldd+函数名				查看函数所用到的共享库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-shell%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">3.shell命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAshell%E6%96%87%E6%9C%AC"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.创建shell文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">3.预定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9E%8B"><span class="toc-number">3.0.3.</span> <span class="toc-text">4.脚本文件的功能型:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.0.4.</span> <span class="toc-text">5.关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.0.5.</span> <span class="toc-text">6.文件运算符:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-if%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.0.6.</span> <span class="toc-text">7.if语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84"><span class="toc-number">3.0.7.</span> <span class="toc-text">8.数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.0.8.</span> <span class="toc-text">9.for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-continue-%E9%81%87%E5%88%B0%E5%90%8E%E8%B7%B3%E8%BF%87%E5%BD%93%E5%89%8D%E5%BE%AA%E7%8E%AF%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AC%A1"><span class="toc-number">3.0.9.</span> <span class="toc-text">10.continue:遇到后跳过当前循环，执行下一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break-%E9%81%87%E5%88%B0%E7%9B%B4%E6%8E%A5%E7%BB%93%E6%9D%9F%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.0.10.</span> <span class="toc-text">break:遇到直接结束循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-until%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.0.11.</span> <span class="toc-text">11.until语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-while%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.0.12.</span> <span class="toc-text">12.while语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%89%8D%E5%8F%B0%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">13.前台与后台的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-gcc%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91c%E8%AF%AD%E8%A8%80g-%E7%BC%96%E8%AF%91c-%E8%AF%AD%E8%A8%80"><span class="toc-number">3.2.</span> <span class="toc-text">14.gcc编译器编译c语言			g++编译c++语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-make%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8Amakefile%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">15.make命令以及makefile文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-gdb%E8%B0%83%E8%AF%95"><span class="toc-number">3.4.</span> <span class="toc-text">16.gdb调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">3.5.</span> <span class="toc-text">17.静态库与动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">18.计算机组成原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">19.进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%A4%8D%E5%88%B6%E8%BF%9B%E7%A8%8B-fork"><span class="toc-number">3.8.</span> <span class="toc-text">20.复制进程   fork</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.8.0.1.</span> <span class="toc-text">僵死进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.8.0.2.</span> <span class="toc-text">写时拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%81%9A%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.9.</span> <span class="toc-text">21.文件操作做的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.10.</span> <span class="toc-text">22.系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%9B%BF%E6%8D%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">23.替换进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88IPC%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">3.12.</span> <span class="toc-text">24.进程间通信（IPC机制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.13.</span> <span class="toc-text">25.信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%AE%A1%E9%81%93"><span class="toc-number">3.14.</span> <span class="toc-text">26.管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.15.</span> <span class="toc-text">27.信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">3.16.</span> <span class="toc-text">28.共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-number">3.16.1.</span> <span class="toc-text">共享内存与信号量的结合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.17.</span> <span class="toc-text">29.消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">3.18.</span> <span class="toc-text">30.套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.19.</span> <span class="toc-text">31.线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.19.1.</span> <span class="toc-text">进程线程的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%89%E6%8A%A2%E8%B5%84%E6%BA%90%E8%A7%A3%E5%86%B3%EF%BC%9A"><span class="toc-number">3.19.2.</span> <span class="toc-text">多线程争抢资源解决：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.19.2.1.</span> <span class="toc-text">①线程间信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.19.2.2.</span> <span class="toc-text">②互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.19.2.3.</span> <span class="toc-text">③条件变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.19.2.4.</span> <span class="toc-text">④读写锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.19.3.</span> <span class="toc-text">生产者&#x2F;消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.19.4.</span> <span class="toc-text">读者&#x2F;写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.19.5.</span> <span class="toc-text">多线程安全</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="无标题">无标题</a><time datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统">linux 系统</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言">C语言</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By WF</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>