<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>linux 系统 | WF的知识空间</title><meta name="author" content="WF"><meta name="copyright" content="WF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.Linux系统基础文件 倒状的树 1.&#x2F;bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令. 2.&#x2F;sbin:系统管理命令(超级用户二进制文件) 仅存放root用户的可执行命令 3.&#x2F;usr:用户共享资源 是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86) 4&#x2F;etc:系统配置文件 存放的是系统和应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="linux 系统">
<meta property="og:url" content="http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="WF的知识空间">
<meta property="og:description" content="1.Linux系统基础文件 倒状的树 1.&#x2F;bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令. 2.&#x2F;sbin:系统管理命令(超级用户二进制文件) 仅存放root用户的可执行命令 3.&#x2F;usr:用户共享资源 是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86) 4&#x2F;etc:系统配置文件 存放的是系统和应用程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WF.png">
<meta property="article:published_time" content="2025-07-27T00:52:57.000Z">
<meta property="article:modified_time" content="2025-11-15T09:03:52.718Z">
<meta property="article:author" content="WF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "linux 系统",
  "url": "http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/",
  "image": "http://example.com/img/WF.png",
  "datePublished": "2025-07-27T00:52:57.000Z",
  "dateModified": "2025-11-15T09:03:52.718Z",
  "author": [
    {
      "@type": "Person",
      "name": "WF",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux 系统',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WF的知识空间</span></a><a class="nav-page-title" href="/"><span class="site-name">linux 系统</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">linux 系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-15T09:03:52.718Z" title="更新于 2025-11-15 17:03:52">2025-11-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-Linux系统基础文件">1.Linux系统基础文件</h2>
<p><strong>倒状的树</strong></p>
<p><strong>1./bin:基础用户命令目录(二进制可执行文件)存放普通用户以及管理员可执行的基本命令.</strong></p>
<p><strong>2./sbin:系统管理命令(超级用户二进制文件)</strong><br>
<strong>仅存放root用户的可执行命令</strong><br>
<strong>3./usr:用户共享资源</strong><br>
<strong>是系统中最大的目录之一，相当于windows中C盘中的&quot;C:\Program Files (x86)</strong></p>
<p><strong>4/etc:系统配置文件</strong><br>
<strong>存放的是系统和应用程序的配置文件,包含网络配置，用户配置，服务配置，系统启动</strong><br>
<strong>'etc/network 网络配置</strong><br>
<strong>5./dev 设备文件目录</strong><br>
<strong>块设备(读写，硬盘)，字符设备(键盘鼠标)，虚拟设备:</strong></p>
<p><strong>6.proc:进程与系统信息文件目录</strong><br>
<strong>存放虚拟目录，不占用磁盘空间，反映内核，进程，硬件的状态:</strong></p>
<p><strong>7.home 家目录</strong><br>
<strong>存放普通用户下的所有文件信息</strong><br>
<strong>'8./root 超级用户目录</strong><br>
<strong>，存放超级用户下的所有文件信息</strong><br>
<strong>'9./boot系统启动相关文件</strong><br>
<strong>启动Lin脑ux系统必备文件</strong><br>
<strong>:10./lib /lib64 共享库文件</strong><br>
<strong>/lib存放共享库 /lib/libc.so,6C标准库</strong><br>
<strong>/linb64 64位系统库</strong><br>
<strong>'11.media 可移动设备挂载</strong><br>
<strong>用于临时挂载移动设备，例如U盘，光盘，硬盘’</strong></p>
<p><strong>12./tmp 临时数据文件</strong><br>
<strong>运行系统或者程序的时候会产生临时文件，存放于该目录下</strong></p>
<h2 id="2-Linux系统基础命令">2.Linux系统基础命令</h2>
<p>$(…….)      命令替换 <code>$(...)</code> 会先执行括号内的命令，再将其输出作为字符串替换到当前命令中。</p>
<p>eg:编译所有.c后缀的文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -o main $(ls | grep .c)   等价于     gcc -o main *.c</span></span><br></pre></td></tr></table></figure>
<h4 id="1。放大界面：ctrl-shift-“-”缩小界面：ctrl-”-“">1。放大界面：ctrl+shift+“+”			缩小界面：ctrl+”-“</h4>
<p><strong>ctrl+c	结束前台正在运行的程序</strong>  		  <strong>~相当于家目录</strong>		<strong>…   上一级目录</strong>       <strong>/   根目录</strong></p>
<p>CTRL+alt+t打开终端</p>
<p>PID：进程的唯一标识符，用来区分唯一的进程        UID：用户唯一标识符</p>
<h4 id="2-第一个字符：">2.第一个字符：</h4>
<p>d开头：代表目录 	-开头：代表文件	l开头：代表链接文件相当于windows下的快捷方式</p>
<h4 id="3-分为三组：创建者权限组员权限其他人权限rwx可读可写可执行-777">3.分为三组：创建者权限	组员权限	其他人权限	rwx可读可写可执行   777</h4>
<p><strong>r 4 读	w 2 写	x 1 执行	– 0 没有权限</strong></p>
<p><strong>绝对路径：从根目录开始到跳转的地方</strong></p>
<p><strong>相对路径：从当前位置开始到跳转的地方</strong></p>
<h4 id="4-修改文件权限chmod">4,修改文件权限	chmod</h4>
<p><strong>①文字设定法</strong>  u创建者	g组员权限	o其他人	a所有人</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x file.txt<span class="comment">//创建者+可执行权限</span></span><br><span class="line"></span><br><span class="line">chmod g-w file.txt<span class="comment">//同组人-可写权限</span></span><br></pre></td></tr></table></figure>
<p><strong>②数字设定法</strong></p>
<p>chmod+权限的8进制+文件名（目录名）</p>
<p><strong>③递归修改（-R 选项）</strong></p>
<p>对目录及其子目录、文件批量修改权限，需加 -R 选项：<br>
chmod -R 权限 目录名</p>
<p><strong>示例</strong>：<br>
递归修改 project 目录下所有内容的权限为 755：chmod -R 755 project/</p>
<p><strong>④ 参考其他文件权限（–reference 选项）</strong></p>
<p>以另一个文件的权限为模板，复制权限到目标文件：<br>
chmod --reference=参考文件 目标文件</p>
<p><strong>示例</strong>：<br>
让 file2.txt 拥有与 file1.txt 相同的权限：chmod --reference=file1.txt file2.txt</p>
<p><strong>⑤ 特殊权限（SUID、SGID、粘滞位）</strong></p>
<p>在三位数字前可加一位数字，表示特殊权限（八进制）：</p>
<ul>
<li>4：SUID（用户执行文件时以文件所有者身份运行）</li>
<li>2：SGID（用户执行文件时以文件所属组身份运行；对目录，新建文件继承目录所属组）</li>
<li>1：粘滞位（Sticky Bit，对目录，仅文件所有者可删除自己的文件，如 /tmp）</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>设置 SUID 权限（如 passwd 命令）：chmod 4755 /usr/bin/passwd</li>
<li>对目录设置 SGID：chmod 2775 shared_dir/</li>
<li>对目录设置粘滞位：chmod 1777 /tmp</li>
</ul>
<h4 id="5-pwd查看当前位置绝对路径">5.pwd查看当前位置绝对路径</h4>
<h4 id="6-man：查看手册参数为命令">6.man：查看手册	参数为命令</h4>
<p>man+（n）+命令		用 n防止重名因此用类型限定</p>
<p>n:</p>
<p>（1）代表命令</p>
<p>（2）代表系统调用（内核函数）</p>
<p>（3）库函数</p>
<h4 id="7-ls"><strong><a target="_blank" rel="noopener" href="http://7.ls">7.ls</a></strong></h4>
<p><strong>①ls -l：打印当前目录下的所有信息</strong></p>
<p><strong>②ls -a：打印当前目录下文件包含的隐藏文件</strong></p>
<p><strong>③</strong>ls -d**：打印目录本身**</p>
<p><strong>④ls -t：按照文件最后修改时间显示</strong></p>
<p><strong>⑤ls -r：按照文件名称逆序打印</strong></p>
<p><strong>⑥ls -R：按照递归的方式，打印所有目录下包括子目录的所有内容</strong></p>
<h4 id="8-创建目录mkdir-目录名">8.创建目录	mkdir+目录名</h4>
<p><strong>①-P：多级创建</strong>		eg：mkdir -p /home/user/project/src/utils</p>
<p><strong>②-m：创建时修改目录权限</strong>		eg：mkdir -m 775 shared</p>
<h4 id="9-删除目录rmdir-目录名">9.删除目录	rmdir+目录名</h4>
<p><strong>①删除非空目录</strong>		rm±rf+目录名</p>
<p><strong>②删除文件</strong>		rm+文件名</p>
<h4 id="10-vi编辑器">10.vi编辑器</h4>
<h5 id="①进入vi编辑器-相当于winoows下的记事本"><strong>①</strong><em>进入vi编辑器(相当于winoows下的记事本)</em>*</h5>
<p><strong>1.进入命令模式(按下什么都输入不进去)</strong></p>
<p><strong>2.按下a，i，o，A,O进入编辑模式</strong></p>
<p><strong>3.如果想退出，先按下esci艮出编辑模式，进入命令模式</strong></p>
<p><strong>4.然后按下shift+&quot;:“进入底行命令模式，输入wq，即可退出</strong></p>
<h5 id="②编辑模式">②编辑模式</h5>
<p><strong>a:在光标之后插入内容</strong></p>
<p><strong>i: 在光标前插入内容</strong></p>
<p><strong>0:在当前行的下一行输入内容</strong></p>
<p><strong>A:在光标所在行的行尾播入内容</strong></p>
<p><strong>i:在光标所在行的行首插入内容</strong></p>
<p><strong>0:在当前行的上一行输入内容</strong></p>
<h5 id="③命令模式">③命令模式:</h5>
<p><strong>yy-复制当前行</strong><br>
<strong>p-粘贴</strong></p>
<p><strong>nyy-复制n行(从光标所在行开始复制，复制n行)</strong><br>
<strong>np-粘贴n次</strong><br>
<strong>dd-删除光标所在行</strong></p>
<p><strong>ndd-删除n行(包含光标所在行)</strong></p>
<p><strong>u-撤回</strong></p>
<p><strong>ctrl+r:撤回撤回的操作光标移动:</strong></p>
<p><strong>h(左)j(下),k(上),(右)</strong></p>
<p><strong>gg:跳转至文件行首</strong></p>
<p><strong>G:跳转文件末尾</strong></p>
<p><strong>nG:跳转到第n行翻页:</strong></p>
<p><strong>ctrl +“f”(下翻页)ctrl+“b”(上翻页)</strong></p>
<p><strong>x:删除光标所在位置的字符</strong></p>
<p><strong>d^:删除光标所在位置到行首的内容</strong></p>
<p><strong>d$:删除光标所在位置到行尾的内容</strong></p>
<p><strong>/关键字:从光标位置向下查找(/error查找error)</strong></p>
<p><strong>?关键字:从光标位置向上查找(?error查找error)</strong></p>
<p><strong>④底行命令模式</strong></p>
<p><strong>w:保存 	q:退出 	q!:强制退出	wq:保存并退出</strong></p>
<h4 id="11-cat-在屏幕上打印文件信息">11.cat:在屏幕上打印文件信息</h4>
<p><strong>cat :打印文件内容</strong><br>
<strong>cat +文件名</strong><br>
<strong>echo:在屏幕上打印信息</strong></p>
<p><strong>格式</strong>    <strong>cat more less head tail</strong></p>
<p><strong>格式1:cat +文件名</strong>	直接打印指定文件的全部内容到终端。</p>
<p><strong>格式2:cat 文件1 文件2</strong>	按顺序连接并输出多个文件的内容（相当于合并显示）。</p>
<p><strong>格式3:cat 文件1&gt;文件2</strong></p>
<p><strong>格式4:cat 文件1&gt;&gt;文件2</strong>	合并文件内容到新文件</p>
<p><strong>格式5:cat &gt;文件1</strong>. 创建新文件	从键盘输入内容，按 Ctrl+D 结束输入，内容会被写入新文件（若文件已存在，会覆盖原有内容）</p>
<p><strong>格式6:cat&gt;&gt;文件1</strong>	追加内容到已有文件	从键盘输入内容，按 Ctrl+D 结束输入，内容会被写入新文件（若文件已存在，会覆盖原有内容）</p>
<h4 id="12mv-移动文件">12mv:移动文件</h4>
<p><strong>格式1:mv 文件1 文件2 将文件2中的内容替换为文件1的，然后删除文件1</strong></p>
<p><strong>格式2: mv 目录1 目录2 将目录1移动到目录2中，然后删除目录一</strong></p>
<p><strong>格式3:mv 文件1目录1移动文件到目录中</strong></p>
<h4 id="13-通配符的概念"><strong>13.通配符的概念</strong></h4>
<p><strong>?:代表一个字符,但是不限是数字还是字母</strong></p>
<p>*<strong>:代表多个字符，不限是数字还是字母</strong></p>
<p><strong>【abc】:表示在【】内选取一个字符</strong></p>
<p><strong>【A-D】:表示在【】范围内，满足其条件,只取一位</strong></p>
<p><strong>【^abc】:表示不在【】范围内，选取一个字符</strong></p>
<h4 id="14-which-命令：查找命令所在的文件在哪里">14.which+命令：查找命令所在的文件在哪里</h4>
<h4 id="15-find">15.find</h4>
<p><strong>find + 起始地址 ±name“文件名’</strong>	按文件名查找</p>
<p><strong>find +起始地址 -size ± n[kMG]</strong>	按文件大小查找</p>
<h4 id="16-tail-查看文件尾部内容">16.tail	 查看文件尾部内容</h4>
<p><strong>tail -f -num 路径</strong><br>
<strong>-num :查看多少行</strong></p>
<h4 id="17-more查看文件内容-以翻页形式">17.more	查看文件内容(以翻页形式)</h4>
<p><strong>less	分屏看反复查看 q退出</strong></p>
<h4 id="18-cmp比较两个文件是否相同">18.cmp	比较两个文件是否相同</h4>
<h4 id="19-文件拷贝cp">19.文件拷贝	cp</h4>
<p>CP 路径+源文件名称   目标路径+新文件名	 <strong>将文件1的内容拷贝给文件2</strong></p>
<p>cp -r  文件夹1  文件夹2</p>
<p><strong>cat2&gt;3复制文件内容到3中，2不消失</strong></p>
<p><strong>mv 23 复制2中内容到3中，2消失</strong></p>
<h4 id="20-head">20.head</h4>
<p><strong>head :查看文件头部内容</strong></p>
<p><strong>head +文件名 显示该文件的前10 行 默认</strong></p>
<p><strong>head -n 20 文件名 显示该文件的前20行</strong></p>
<p><strong>head -c5 文件名 显示该文件的前5个字符</strong></p>
<h4 id="21-权限掩码">21.权限掩码</h4>
<p>满权限:777 文件默认的权限是666</p>
<p>指令:umask</p>
<p>格式:umask+权限掩码<br>
创建文件或目录的默认权限=<strong>满权限-权限掩码</strong></p>
<h4 id="22-打包tar">22.打包	tar</h4>
<p><strong>格式1:tar -cvf 目标包.tar + 需要打包的文件 打包</strong></p>
<p><strong>格式2:tar -tvf 目标包.tar 查看打包中的内容</strong></p>
<p><strong>格式3:tar -xvf 目标包.tar-c目标地址 解包</strong></p>
<p><strong>格式4:tar-Avf 包1包2 将2中的内容追加到1中</strong></p>
<p><strong>格式5:tar -rvf 目标包.tar 文件</strong></p>
<p><strong>tar zxf my.tar.gz 解包 解压释放一步完成          剩下的后缀百度搜解压方法</strong></p>
<h4 id="23-清屏clear">23.清屏	clear</h4>
<h4 id="24-查看当前用户who">24.查看当前用户	who</h4>
<h4 id="25-显示时间和日期-date">25.显示时间和日期:	date</h4>
<p><strong>格式1: date 显示时间和日期</strong></p>
<p><strong>格式2:date +%c 中文显示时间</strong></p>
<h4 id="26-查看进程-pS">26.查看进程: 	pS</h4>
<p><strong>①格式1: ps</strong><br>
<strong>②格式2:打印正在进行的进程</strong>	<strong>ps -au</strong>         <strong>ps -ef  打印所有进程</strong></p>
<p><strong>user:进程拥有着 		plD:%mem 内存占用率 	vsz:虚拟内存	 rss:串口内存		tty:串口号 stat:进程状态(s代表阻塞 r代表正在运行 t代表暂停)	start:进程开始时间 	time:进程持续时间 command:什么程序触发</strong></p>
<p><strong>③格式3 pstree 以树状图的形式打印进程</strong></p>
<h4 id="kill-结束进程-kill-进程ID">kill   结束进程    kill+进程ID</h4>
<h4 id="27-网络命令-ifconfig">27.网络命令:	ifconfig</h4>
<p><strong>本地回环:表示自己的地址所处的IP地址</strong></p>
<p><strong>硬件地址(mac地址):共有48位,前24位由厂商决定,后24位为个人</strong></p>
<p><strong>逻辑地址(IP地址)-进制255.255.255.255192.168.163.255</strong><br>
<strong>192.168.0.1 .1就是网关地址</strong></p>
<p><strong>子网掩码:1代表ip地址中的网络地址 0表示主机地址255.255.255.0</strong><br>
<strong>ip地址:192.168.163.0</strong>子网掩码:<br>
<strong>A类:第一个字段是网络地址，其余都是主机地址255.0.0.0</strong></p>
<p><strong>B类:第一个和第二个字段是网络地址，其余都是主机地址 255.255.0.0</strong><br>
<strong>C类:第一个和第二个和第三个字段是网络地址，其余都是主机地址 255.255.255.0</strong></p>
<p><strong>D类:作为组播地址</strong></p>
<p><strong>E类:作为测试网段</strong></p>
<p><strong>IPV4:只有32位</strong></p>
<p><strong>IPV6:有128位</strong></p>
<p>**网络协议:</p>
<p><strong>DHCP(动态主机配置协议)自动分配IP地址</strong><br>
<strong>DNS(域名解析办议)</strong><br>
<strong>计算机可以看懂的IP地址(192.0.0.0)</strong></p>
<h4 id="28-rm-删除">28.rm 删除</h4>
<p><strong>rm  文件名     删除文件</strong></p>
<p><strong>rm -r  目录     删除文件夹</strong></p>
<h4 id="29-find-搜索文件"><strong>29.find    搜索文件</strong></h4>
<p><strong>格式： find   路径   -name   文件名   按名字搜索</strong></p>
<h4 id="30-管道-两个进程传输信息的工具">30.管道	|   两个进程传输信息的工具</h4>
<p><strong>eg:ls | grep “pwd”</strong>  		 <strong>ls将结果给grep过滤输出过滤后的含pwd的文件</strong></p>
<h4 id="31-过滤-grep-对命令执行结果进行过滤">31.过滤     grep  对命令执行结果进行过滤</h4>
<p><strong>格式：grep   查找内容     文件名		查找包含找内容的文件内的这一行的信息</strong></p>
<p><strong>-r不区分大小写</strong></p>
<p><strong>-v 查找不包含这个内容的行信息</strong></p>
<h4 id="32-top-相当于windows的任务管理器">32.top  相当于windows的任务管理器</h4>
<h4 id="33-ldd-函数名查看函数所用到的共享库">33.ldd+函数名				查看函数所用到的共享库</h4>
<h2 id="3-shell命令">3.shell命令</h2>
<h4 id="1-创建shell文本">1.创建shell文本</h4>
<p><strong>创建shell文本需要三步:</strong></p>
<p>**创建脚本文件 vi <em>.sh<br>
提升文件权限chmod777 <em>.sh</em></em></p>
<p><strong>执行文件./</strong><em>.sh</em>*</p>
<p><strong>2.注意事项</strong></p>
<p><strong>shell文件在创建变量时，不需要变量的类型,直接去写变量名</strong></p>
<p><strong>a=12 b=20 	两边不需要空格</strong><br>
<strong>使用变量时，需要注意在变量名前加$，$a$(a}打印变量 echo</strong><br>
<strong>输入变量 read</strong><br>
<strong>取消变量的定义:unset+变量名</strong><br>
<strong>设置只读:readonly+变量名 不可被取消定义</strong></p>
<p><strong>命名规则:数字字母下划线组成,不能以数字开头</strong><br>
<strong>单引号:将整句话变成字符串打印</strong><br>
<strong>双引号:寻找其中对应的变量值</strong><br>
<strong>求字符串长度:需要在变量名前加 #且尽量使用0将整个变量括起来</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142534432.png" alt="image-20250727142534432" style="zoom:50%;">
<p><strong>截取相应长度的字符</strong><br>
<strong>echo ${name:n:m}	截取name字符串中从第n个字符开始后的m个</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142609263.png" alt="image-20250727142609263" style="zoom:50%;">
<p><strong>4 表示从第4个字符开始到末尾</strong><br>
<strong>-2(:后需要加空格)从倒数第二个开始输出</strong><br>
<strong>(-2):同上</strong></p>
<h4 id="3-预定义变量"><strong>3.预定义变量</strong></h4>
<p><strong>$0:打印当前脚本文件的名称(执行的第0个参数)</strong></p>
<p><strong>$@:打印从第一个开始后所有的参数</strong><br>
<strong>$#:打印从第一个参数开始的所有参数的个数</strong></p>
<p><strong>$1,2,3,4,5:打印当前脚本文件的第1-n个参数</strong></p>
<p><strong>$$:打印当前shel的进程id号</strong></p>
<h4 id="4-脚本文件的功能型">4.脚本文件的功能型:</h4>
<p><strong>1.运算</strong><br>
<strong>算术语句:expr</strong><br>
<strong>expr是一个表达式计算命令:支持整数运算，字符串处理</strong></p>
<p><strong>表达式中的运算符和操作符之前必须存在空格,否则会被视为字符串</strong></p>
<p><strong>格式:expr 变量1运算符 变量2</strong></p>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142837253.png" alt="image-20250727142837253" style="zoom: 50%;">
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727142849119.png" alt="image-20250727142849119" style="zoom: 50%;">
<p><strong>将a+b之后的结果赋值给num</strong></p>
<h4 id="5-关系运算符">5.关系运算符</h4>
<p><strong>-eq :比较是否相同()</strong><br>
<strong>-ne :比较是否不同(!=)</strong><br>
<strong>-gt:大于号</strong><br>
<strong>-ge:大于等于</strong><br>
<strong>-lt:小于号</strong><br>
<strong>-le:小于等于</strong></p>
<p><strong>-a:并且</strong><br>
<strong>-0:或者</strong></p>
<h4 id="6-文件运算符"><strong>6.文件运算符:</strong></h4>
<p><strong>-r -w -x :判断文件是否可读可写可执<br>
-e:判断文件是否存在</strong><br>
<strong>-f:判断文件是否为普通文件</strong><br>
<strong>-d:判断是否为目录</strong></p>
<p><strong>-ot -nt:</strong></p>
<p><strong>文件1   -ot/-nt   文件2	判断文件1是否比文件21/新</strong></p>
<h4 id="7-if语句">7.if语句</h4>
<p><img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143340095.png" alt="image-20250727143340095"></p>
<h4 id="8-数组">8.数组</h4>
<p><strong>数组:所有数据的集合格式:</strong></p>
<p><strong>数组名=(值1值2 值3)</strong></p>
<p><strong>使用方法; ${数组名[下标]}</strong></p>
<h4 id="9-for循环">9.for循环</h4>
<p><img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143457214.png" alt="image-20250727143457214"></p>
<h4 id="10-continue-遇到后跳过当前循环，执行下一次">10.continue:遇到后跳过当前循环，执行下一次</h4>
<h4 id="break-遇到直接结束循环">break:遇到直接结束循环</h4>
<h4 id="11-until语句">11.until语句</h4>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143549900.png" alt="image-20250727143549900" style="zoom:25%;">
<h4 id="12-while语句">12.while语句</h4>
<img src="https://cdn.jsdelivr.net/gh/wf-git-code/wf-git-code.github.io@master//images/image-20250727143615581.png" alt="image-20250727143615581" style="zoom: 25%;">
<h3 id="13-前台与后台的相互转换">13.前台与后台的相互转换</h3>
<p><strong>kill可以结束一切命令     ctrl+c只结束前台命令</strong>   kill -9强制结束</p>
<p><strong>进程：正在运行的程序</strong></p>
<p><strong>sleep+时间   阻塞命令</strong></p>
<p><strong>前台 ：只能一个接着一个运行命令</strong></p>
<p><strong>后台：可以同时运行多个命令</strong></p>
<p><strong>命令   &amp;</strong>    转后台运行</p>
<p><strong>eg:sleep（30）&amp;</strong></p>
<p>jobs   打印正在运行的程序      -l加参数会打印出进程号       任务号不是进程ID</p>
<p>CTRL+Z停止当前命令，但没有终止，相当于将该进程挪到后台，但不会启动运行这个进程</p>
<p>bg %r任务号  前台挪后台</p>
<p><strong>先暂停程序再挪</strong></p>
<p>fg %任务号   后台挪前台</p>
<p>在停止之后进程挪动的时候唤醒暂停的程序</p>
<h3 id="14-gcc编译器编译c语言g-编译c-语言">14.gcc编译器编译c语言			g++编译c++语言</h3>
<p>无论编译何种语言，GCC 都会按 “<strong>预处理→编译→汇编→链接</strong>” 四个固定阶段执行，每个阶段输入特定格式的文件，输出下一级文件，最终生成可执行程序。</p>
<p>GCC 的本质是 “多阶段、模块化的代码转换器”，其完整流程可概括为：</p>
<ol>
<li><strong>预处理</strong>：<code>hello.c</code> → <code>hello.i</code>（文本替换，删除注释 / 展开宏 / 包含头文件）；</li>
<li><strong>编译</strong>：<code>hello.i</code> → <code>hello.s</code>（词法 / 语法 / 语义分析→IR 生成→优化→汇编代码）；</li>
<li><strong>汇编</strong>：<code>hello.s</code> → <code>hello.o</code>（汇编指令→二进制目标文件，含符号表）；不能运行因为没加系统库调运不了</li>
<li><strong>链接</strong>：<code>hello.o</code> + 系统库 → <code>hello</code>（合并目标文件→解析符号→重定位→可执行文件）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//预编译    gcc -E main.c -o main.i</span></span><br><span class="line"><span class="comment">//编译      gcc -S main.i -o main.s</span></span><br><span class="line"><span class="comment">//汇编      gcc -C main.s -o main.o</span></span><br><span class="line"><span class="comment">//链接      gcc -O  main.o -o main</span></span><br><span class="line"><span class="comment">//四部结合   gcc -o main main.c    此时为relses版本</span></span><br><span class="line"><span class="comment">//gcc -o main main.c -g   debug版本</span></span><br></pre></td></tr></table></figure>
<p><strong>多个文件的编译     可以先用gcc   -c  对函数实现文件进行语法检查</strong></p>
<p>Debug和relese版本的区别，Debug版本相较于relese多了需要调试的信息</p>
<h3 id="15-make命令以及makefile文件">15.make命令以及makefile文件</h3>
<p>当项目包含多个源代码文件时，手动执行 <code>gcc</code> 等编译命令会非常繁琐（例如 <code>gcc a.c b.c c.c -o app</code>），且每次修改文件后需要重新输入完整命令。</p>
<p><strong>1.<code>make</code> 命令的核心价值在于：</strong></p>
<ol>
<li><strong>自动化构建</strong>：通过 Makefile 定义的规则，自动执行编译、链接等步骤，无需手动输入长命令。</li>
<li><strong>增量编译</strong>：仅重新编译<strong>被修改过的文件</strong>（通过对比文件修改时间判断），避免全量编译，节省时间。</li>
<li><strong>灵活扩展</strong>：支持复杂逻辑（如条件编译、多目标输出、跨平台适配等）。</li>
</ol>
<p><strong>2.<code>make</code> 命令的基本用法</strong>     一般只有一个makefile文件</p>
<p>make编译makefile文件      make+makefile中的方法—clean或者其他有意义的文件否则直接执行make会输出all中包含 的main文件按照依赖关系执行命令</p>
<p>如果makefile文件和make不在同一目录下则需要加相对路径</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有三个.c文件    add.c  max.c  main.c</span></span><br><span class="line"><span class="comment">//makefile文件</span></span><br><span class="line"><span class="comment">//完整版</span></span><br><span class="line">all : main</span><br><span class="line"></span><br><span class="line">main : main.o add.o max.o</span><br><span class="line">    gcc -o main main.o add.o max.o</span><br><span class="line">main.o : main.c</span><br><span class="line">    gcc -c add.c</span><br><span class="line">max.o : max.c</span><br><span class="line">    gcc -c max.c</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.o main</span><br><span class="line"><span class="comment">//简化版    </span></span><br><span class="line">all: main</span><br><span class="line">main : add.c main.c max.c</span><br><span class="line">    gcc -o main add.c main.c max.c</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.o main    </span><br></pre></td></tr></table></figure>
<p>主函数有三个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv,<span class="type">char</span>* envp)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s&quot;</span>,i,argv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;envp[i]!=<span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;envp[%d]=%s&quot;</span>,i,envp[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>linux有   1.2.3，windows只有1.2</strong></p>
<p><strong>1.参数个数  int  argc    argc最小为1   自己的函数名</strong></p>
<p><em><em>2.参数名称   char</em> argv         参数argv[0]=（Linux）当前函数路径+名称  argv[1]传给主函数第一个参数， argv[2]传给主函数第二个参数</em>*</p>
<p>​							  <strong>windows（函数的路径）</strong></p>
<p><em><em>3.环境变量    char</em> envp[]     envp最后一个元素是空指针</em>*</p>
<h3 id="16-gdb调试">16.gdb调试</h3>
<p>调试的对象是main/main.exe</p>
<p>stdin  stdio stderr  标准输入输出文件从电脑启动已经打开并运行  三个已经打开的文件指针</p>
<p><strong>gcc -o main main.c -g   debug版本</strong></p>
<ol>
<li>
<p>gdb  函数可执行文件</p>
</li>
<li>
<p>b n/函数名   第n行加断点/函数开头加断点</p>
</li>
<li>
<p>info break 打印所有断电信息</p>
</li>
<li>
<p>delete n  删除第n行断电</p>
</li>
<li>
<p>r      运行程序</p>
</li>
<li>
<p>n   执行下一行代码</p>
</li>
<li>
<p>p  参数   打印此时参数值</p>
</li>
<li>
<p>c   continue  执行直到下个断点</p>
</li>
<li>
<p>q  退出</p>
</li>
<li>
<p>l n   显示第n行代码</p>
</li>
<li>
<p>s  函数名    进入该函数       finish跳出函数</p>
</li>
<li>
<p>bt  显示当前函数的位置，现在再哪个函数的那个函数中   if   A-&gt;B-&gt;C</p>
<p>C</p>
<p>B</p>
<p>A</p>
</li>
</ol>
<h3 id="17-静态库与动态库">17.静态库与动态库</h3>
<p>printf实现在哪里?	stdio.h只是声明有这样一个函数	但实现是在库里面C标准库</p>
<p><strong>1.库文件</strong>	预先编译好的函数集合        (静态库 共享库(windows叫动态链接库).dll）</p>
<p>静态库：是可以被多个程序加载和共享的二进制文件			       libXX.a</p>
<p>共享库（动态库）：是可以被多个程序<strong>动态</strong>加载和共享的二进制文件    <a target="_blank" rel="noopener" href="http://libXX.so">libXX.so</a></p>
<p><strong>2.为什么打包成库?</strong></p>
<p>①.便于分享，直接给别人.o的库，避免别人二次编译从.c到.o，防止出现编译器不同问题，导致.o文件不一致</p>
<p>②.防止源码泄露,不希望别人知道自己.c的内容</p>
<p><strong>3.共享库创建步骤:</strong></p>
<p>①将需要生成库文件的所有.c文件编译成.0文件</p>
<p>②使用GCC将所有需要的.o生成为共享库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfool.so add.o max.o</span><br></pre></td></tr></table></figure>
<p>-shared :指定生成共享库 告诉编译器将目标文件(.o)链接成共享库，而不是生成可执行文件</p>
<p>-fPIC:用于生成位置无关代码，这是动态库必要的特性</p>
<p>位置无关代码:代码不依赖于特定的内存地址，无论动态库加载到内存的哪个位置，都能正常执行为什么需要这个?</p>
<p>动态库在程序运行的时候，由操作系统动态分配内存地址空间，而不是编译时固定位置如果代码依赖固定地址(使用绝对地址访问内存),加载到不同位置时会出错，，-fPIC的使用可以确保代码使用相对地址或间接寻址，适配动态加载原则(机制)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libfool.so add.c max.c</span><br></pre></td></tr></table></figure>
<p>由于gcc的缘故，所以可以不需要刻意的生成.o再去生成动态库，可以直接拿.c来用</p>
<p>静态库：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//或者先编译.o文件再打包为库</span></span><br><span class="line">gcc -c add.o add.c</span><br><span class="line">gcc -c max.o max.c</span><br><span class="line">ar crv libfoo.a add.o max.o   <span class="comment">//打包为静态库</span></span><br><span class="line"><span class="comment">//但就算引用头文件也不能使用，因为自己创建的库需要自己手动连接，而c标准库会自动链接，需要解决则需要将自己创建的库移动到.c标准库目录下并指定库的名称,否则需要指定路径和名称</span></span><br><span class="line"><span class="comment">//gcc -o main main.c -lfoo     标准目录下</span></span><br><span class="line"><span class="comment">//gcc -o main main.c -L. -lfoo    .表示当前位置</span></span><br><span class="line"><span class="comment">//引用头文件（若要使用尖括号则需要将.h头文件放到头文件存放位置--不建议）双引号会优先在当前目录查找，头文件只实现函数的声明，创建.c文件用来编译为.o文件打包成静态库</span></span><br></pre></td></tr></table></figure>
<p><strong>ldd 查看可执行程序用了哪些共享库</strong></p>
<p><strong>以动态库链接生成的可执行程序不能直接运行，从Idd main中可以看到动态库not found两种解决方式</strong>   编译时任然需要</p>
<p><strong>gcc -o main main…c -L. -lfoo</strong>		但运行时报错则需要</p>
<p><strong>①1.将共享库拷贝到标准目录下</strong></p>
<p>动态库删库之后，文件无法执行了</p>
<p><strong>②告诉程序库就在当前目录中</strong>   配置环境变量<br>
如果库不在标准标准位置下，可以通过设置环境变量来加载库的路径</p>
<p>环境变量:是操作系统中储存系统配置信息或运行时参数的键值对，用于在整个系统中传递配置信息</p>
<p>环境变量相当于系统级别的全局变量<br>
核心特点:1。键值对结构 每个环境变量都由“变量名”=“值”组成</p>
<p>2.全局性</p>
<p>3.动态性 可以在系统运行时进行修改<br>
export:临时设置环境变量(当前终端有效)</p>
<p>执行可执行程序就算没了静态时库，程序依然能执main.0行，因为里面存在拷贝的.o文件的集合</p>
<p>可执行程序运行时，需要加载共享库，没有共享库的链接，没办法执行，没有复制，只有标记，如果后期升级/修改了共享库，那么可执行程序可以直接运行，不需要编译</p>
<p><strong>4.静态库动态库对比</strong></p>
<p>①链接时机和过程<br>
静态库:编译阶段链接     可执行程序会在<strong>链接时，会拷贝原方法到可执行程序</strong>，因此删掉静态库也可运行<br>
动态库:执行阶段链接     可执行程序在<strong>执行阶段</strong>链接动态库，删掉库不可运行，链接时只标记</p>
<p>②内存和磁盘占用<br>
静态库:可执行文件体积大，但是不依赖于外部资源</p>
<p>动态库:体积小，但是依赖外部库文件</p>
<p>③更新与维护<br>
静态库:所有依赖静态库的程序必须重新编译</p>
<p>动态库:无需重新编译，只需要链接新库</p>
<p>④适用场景<br>
静态库:程序只需要独立执行，没有外部依赖 小型工具 嵌入式设备</p>
<p>动态库:多个程序共享代码，需要频繁更新库文件 大型项目使用较多</p>
<h3 id="18-计算机组成原理">18.计算机组成原理</h3>
<p>五大件   运算器  控制器  内存  输入 输出</p>
<p>数据总线   地址总线   控制总线</p>
<p>指令;地址码和操作码组成     执行某种操作的命令     是原子操作不可分割</p>
<p><strong>程序就是指令的集合</strong>   一条高级语言语句可以分割为很多指令</p>
<h3 id="19-进程">19.进程</h3>
<p>操作系统用来管理计算机软硬件资源</p>
<p>核心：进程，内存，中断，文件的管理</p>
<p>进程由操作系统管理</p>
<p>进程一个运行的程序及其所占用的所有资源</p>
<p>**PCB：进程控制块，是进程存在的唯一标志。**用来描述进程的属性信息  <strong>每个唯一</strong>    多个PCB穿起来组成链表</p>
<p><strong>PID：进程ID号   每一个进程唯一标识</strong></p>
<p><strong>PPID</strong>：<strong>父进程ID号</strong></p>
<p>进程状态：</p>
<p>就绪：等待调度运行</p>
<p>运行：正在运行</p>
<p>阻塞：运行到程序程序中断等待修改就绪</p>
<p>并发：两个处理器同时处理两个任务</p>
<p>并行：一个处理器交替进行两个任务</p>
<p>内存管理：逻辑页     物理页     页表（记录逻辑页物理页映射关系）虚拟内存：磁盘上划分空间当作内存用但是速度慢</p>
<p>分时系统：给每个进程分配固定时间同时进行</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>分时系统</th>
<th>实时系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计目标</td>
<td>多用户公平交互、资源共享</td>
<td>任务在规定时间内完成、高可靠</td>
</tr>
<tr>
<td>调度策略</td>
<td>时间片轮转，强调公平性</td>
<td>优先级抢占，强调时效性</td>
</tr>
<tr>
<td>响应时间要求</td>
<td>秒级，用户可接受即可</td>
<td>毫秒 / 微秒级，有严格上限</td>
</tr>
<tr>
<td>可靠性要求</td>
<td>一般，允许偶尔延迟</td>
<td>极高，超时可能导致严重后果</td>
</tr>
<tr>
<td>典型应用</td>
<td>桌面操作系统、服务器系统</td>
<td>工业控制、航电系统、医疗设备</td>
</tr>
</tbody>
</table>
<p>①对于每个进程来说，其逻辑地址大小都为0-4gb且分为数据区，代码区，堆区，栈区，在每个进程中内核通常都会占用一部分逻辑地址，这部分逻辑地址不能被使用，windows2gb  linux1gb，对于物理内存，操作系统会将物理内存分位内存页，通常大小4kb（与硬件有关），操作系统将内存抽象为逻辑地址，其在每个进程的PCB控制块中包含着逻辑地址映射物理地址的页表，每个进程里其逻辑地址可能相同但映射关系完全不同，逻辑地址转物理地址由cpu中的MMU来实现，虽然说物理地址可能相同，但在物理内存上使用区域是完全独立的，给程序员的感觉就好像每个进程都独立使用0-4gb的空间。</p>
<p>②真实内存小于逻辑地址时：<strong>虚拟内存 （逻辑地址）+ 交换分区（Swap）</strong> 机制解决，核心是 “用磁盘空间模拟内存，实现逻辑地址的‘按需映射’”。但速度会变慢。</p>
<p>③真实内存大于逻辑地址时：此时的核心问题是：<strong>32 位逻辑地址无法寻址超过 4GB 的物理内存</strong>，需通过硬件和内核机制突破这一限制。</p>
<p>④逻辑地址不足时：在32位操作系统大量使用虚拟内存，或者内存碎片太多，无大且连续的地址空间，会导致malloc  realloc返回错误，解决优化程序或者升级64位系统</p>
<p>内存碎片的产生：内存碎片是内存管理中 “效率与连续性” 矛盾的产物：</p>
<ul>
<li>内部碎片因 “内存对齐要求” 和 “固定分配单元” 产生，表现为已分配内存中的空闲空间；</li>
<li>外部碎片因 “频繁malloc分配释放free” 和 “分配策略” 产生，表现为分散的空闲块无法合并。<strong>malloc和realloc会分配连续的逻辑地址</strong></li>
</ul>
<p>现代操作系统通过分页、虚拟内存、伙伴系统等机制，在一定程度上平衡了碎片问题，但无法完全消除（通常以允许少量内部碎片为代价，换取外部碎片的减少）。</p>
<p>⑤物理内存不足时：多进程同时存在，或者单进程占用大量内存，轻度不足，操作系统回收空闲内存页不会杀死进程，重度不足，<strong>计算 OOM 评分</strong>（进程占用空间大小，优先级，重要程度），<strong>选择并杀死目标进程</strong>，<strong>系统恢复</strong>：释放的物理内存分配给急需内存的进程，避免系统崩溃。解决：增加物理内存，扩大 Swap 分区，限制进程内存使用，优化应用程序。</p>
<p>⑥对于进程复制，fork在执行的时候会将父进程的资源完全复制一份给子进程，包括PCB中的页表和文件结构体struct file ，但是由于这样效率低空间大，于是出现了写时拷贝，即谁改变复制谁，不改变的部分共享同一片物理空间，要改变的部分重新分配物理内存，即改变子进程页表中的映射关系。给程序员的感觉就是完全复制了一份。对于文件来说在struct file结构体中有一个引用计数器，记录了有几个进程在使用这个文件，当这个计数器为0时文件才会被关闭。因此在子进程即使被替换在不需要这个文件时也需要调用close关闭一次时引用计数器减一，父进程也需要关闭。文件表下标从3开始，并且父子进程共享已打开文件的文件偏移量。</p>
<p>⑦fork复制进程，在父进程会返回子进程的PID，在子进程中会返回0，因此可以根据这一特性使父子进程完成不同的功能，或者调用execlp来替换进程，在父进程先结束后，操作系统会自动将孤儿进程分配给一个系统进程，这个系统进程一定会调用wait接受子进程退出码，在子进程先结束后，由于父进程没有调用wait因此子进程会变为僵死进程，直到父进程结束系统重新分配父进程结束僵死进程，解决方法目前在父进程中调用wait，但因为需要子进程先结束因此会阻塞父进程。   linux会用四个字节来表示进程的结束，第一个字节表示系统是否正常退出，第二个字节表示退出码 。wait（）将4个字节的值提取出来，WIFEXITED(val)提取第一个字节表示是否正常，WEXITSTATUS(val)提取第二个字节并打印出退出码。</p>
<p>⑧<strong>用户态切换内核态</strong></p>
<p>每一个系统调用都有编号，当代码执行到需要内核函数时<strong>会产生中断</strong>0x80，用户程序将系统调用号存入Eax寄存器，执行 <code>int 0x80</code> 或者调用指令 syscall后，CPU 跳转到内核的中断处理程序，完成从用户态（特权级 3）到内核态（特权级 0）的切换。通过根据系统调用号从内核函数表中，找到内核中被调用函数，执行完被调用函数后，其返回值被Eax寄存器返回到应用程序中，继续执行后续代码</p>
<p>⑨<strong>系统调用与库函数的区别</strong> ？   <strong>产生中断陷入内核</strong></p>
<p>库函数实现在c库中，系统调用在内核中，实现一个printf函数会有一个用户态到内核态的切换</p>
<ul>
<li><strong>系统调用</strong>是内核提供的 “原子操作”，负责与硬件和内核资源交互，特点是底层、高效（单次调用开销固定）、但易用性差、跨平台性差。</li>
<li><strong>库函数</strong>是对系统调用的封装，提供更友好的接口、优化（如缓冲）和跨平台支持，降低开发难度，同时通过减少系统调用次数提升性能。</li>
</ul>
<p>⑩<strong>既然使用库函数和系统调用都有系统调用的开销为什么推荐使用库函数？</strong>  库函数是 “性价比最高的选择”</p>
<p>库函数虽然最终可能调用系统调用（因此包含系统调用的基础开销），但通过<strong>减少系统调用次数、提供抽象接口、跨平台兼容和算法优化</strong>，显著降低了开发成本并提升了程序效率。对于绝大多数应用场景，使用库函数的 “收益”（开发效率、性能优化）远大于其引入的 “额外开销”（封装层的少量指令）</p>
<h3 id="20-复制进程-fork">20.复制进程   fork</h3>
<p>返回值为PID参数为NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid=fork();</span><br></pre></td></tr></table></figure>
<p>旧进程——父进程</p>
<p>fork复制——子进程        父子进程一模一样但PID不同</p>
<p>fork在父进程返回值为子进程的PID     在子进程返回值为0</p>
<p><strong>子进程从fork返回这个位置执行</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="number">3</span>;</span><br><span class="line">        s = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="number">7</span>;</span><br><span class="line">        s = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%s curr_pid=%d, ppid=%d\n&quot;</span>, s, getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wf@wf-virtual-machine:~/mycode/c2501/day03$ ./test</span><br><span class="line">s=child curr_pid=<span class="number">3043</span>, ppid=<span class="number">3042</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=child curr_pid=<span class="number">3043</span>, ppid=<span class="number">3042</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=child curr_pid=<span class="number">3043</span>, ppid=<span class="number">3042</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br><span class="line">s=parent curr_pid=<span class="number">3042</span>, ppid=<span class="number">2177</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">fork()||fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印三次A</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">fork()&amp;&amp;fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印三次A</span></span><br></pre></td></tr></table></figure>
<p>如果打印n的地址全部是逻辑地址且都相同，对于同一个进程逻辑地址唯一对应一个物理地址，每个进程都有一个页表（记录逻辑地址与物理地址的对应关系），对于每个进程页表唯一且不同，父子进程逻辑地址都相同但其中每个页表对应关系不同，因此就算是相同的逻辑地址也对应不同的物理地址。PCB中存储着不同进程的信息。</p>
<p>计算机中通过调试只能看见逻辑地址，真实的物理内存无法看到</p>
<p>逻辑地址是距离0x00000000的偏移量</p>
<p>复制是将父进程的逻辑地址以及全部信息复制一份，但在其子进程的页表中其逻辑地址对应物理地址关系不同。包括其输入输出缓冲区。</p>
<p>也会复制文件表</p>
<p>可以同时操作同一文件</p>
<h5 id="僵死进程">僵死进程</h5>
<p><strong>设计：子进程先结束后，默认要求父进程要获取子进程退出码 ——存在进程PCB中</strong>      <strong>父进程没有获取退出码，子进程变为僵死进程</strong></p>
<p>父进程结束后，子进程会被系统进程接管，而系统进程会获取退出码释放子进程     可能会也可能不会产生，但最终会被解决掉</p>
<p>exit(0);</p>
<p>exit(1);错误码</p>
<p>僵死进程：子进程先结束，父进程没有调用wait（）获取子进程退出码，则子进程一直会存在就算父进程结束，系统会重新将该子进程分配给另一个永不结束的父进程，直到退出码被调用，以前是被pid号为1的进程接管，现在不确定但系统找到的进程一定会调用wait（）结束僵死进程。</p>
<p><strong>解决</strong>：<strong>在父进程中调用wait()获取子进程退出码</strong>    <strong>但会阻塞父进程得等待子进程结束后获取退出码后再继续执行父进程</strong>    子进程得先结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* s = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">3</span>;</span><br><span class="line">        s = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">7</span>;</span><br><span class="line">        s = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        wait(&amp;val);<span class="comment">//获取退出码，子进程不会变成僵死进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;val=%d\n&quot;</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s=%s pid=%d,ppid=%d\n&quot;</span>,s,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="写时拷贝">写时拷贝</h5>
<p>推迟甚至免除页面拷贝的技术</p>
<ol>
<li>父进程（PID=100）调用 <code>fork()</code> 创建子进程（PID=101）。</li>
<li>内核不为子进程复制内存，而是让父子进程共享所有内存页（标记为 “只读”）。</li>
<li>父进程修改变量 <code>a</code> 时，内核检测到 “写操作”，为父进程复制 <code>a</code> 所在的内存页，父进程后续操作新副本。</li>
<li>子进程未修改 <code>a</code>，仍使用原内存页；若子进程也修改 <code>a</code>，则内核为其单独复制一份。</li>
</ol>
<p>简单说，COW 的核心是 “<strong>不修改就不复制，谁修改谁复制</strong>”，是操作系统中优化资源复制的经典策略。</p>
<p><strong>传统来说fork时复制全部资源，但这样效率低资源占用大因此写时拷贝</strong>，<strong>以内存页为单位</strong>，<strong>不改的时候共享，改的时候拷贝</strong></p>
<p>对程序员来说是透明的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">// 假设已通过fork()创建子进程，此处父进程等待子进程</span></span><br><span class="line">    wait(&amp;val); <span class="comment">// 等待子进程结束，获取退出状态到val</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(val)) &#123; <span class="comment">// 判断子进程是否正常退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程正常退出，状态码：%d\n&quot;</span>, WEXITSTATUS(val)); <span class="comment">// 提取退出状态码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个字节</p>
<p>00000000 00000000 00000011 00000000      第一个字节表示是否正常退出        第二个字节表示退出码</p>
<p>wait（）将4个字节的值提取出来</p>
<p>WIFEXITED(val)提取第一个字节表示是否正常退出</p>
<p>WEXITSTATUS(val)提取第二个字节并打印出退出码</p>
<ol>
<li>
<p><strong>虚拟地址空间的 4MB</strong>进程的代码段、数据段、堆、栈在虚拟地址空间中总计占用 4MB，意味着这些段的虚拟页总和覆盖了 4MB 的虚拟地址范围（例如，1024 个 4KB 虚拟页）。但这并不等于物理内存实际分配了 4MB，因为：</p>
<ul>
<li><strong>未使用的虚拟页不分配物理页</strong>：例如，堆声明了 1MB 空间但只使用了 100KB，剩余 900KB 的虚拟页未映射到物理页（访问会触发缺页异常，动态分配）。</li>
<li><strong>只读段（如代码段）可能共享物理页</strong>：如果其他进程也运行相同程序，代码段的物理页会被共享，不计入当前进程的 “独有物理占用”。</li>
</ul>
<p>因此，进程的<strong>实际物理内存占用（Resident Set Size, RSS）通常小于虚拟地址空间的使用量</strong>（4MB）。</p>
</li>
</ol>
<h3 id="21-文件操作做的系统调用">21.文件操作做的系统调用</h3>
<p>Linux系统提供了操作文件的底层系统调用：read   write   open   close     （内核中）</p>
<p>linux系统：fopen()——&gt;open()</p>
<p>Linux系统中不分文本文件和二进制文件</p>
<p>windows文本文件会加特殊字符，并且会对这种特殊字符进行处理。</p>
<p><strong>open（）调用一次就会产生一个结构体 struct file</strong>  文件表</p>
<p><strong>文件表：记录打开的文件</strong>     默认1024            <strong>在进程PCB中</strong></p>
<p><strong>本质结构体数组</strong>        描述符和file*指针选一个</p>
<p>0 标准输入</p>
<p>1 标准输出</p>
<p>2 标准错误输出</p>
<p>3 a.txt</p>
<p>文件表从下表为3开始</p>
<p><strong>有一个结构体 struct file  表示打开的文件，这个结构体里面有一个计数器，记录有几个进程打开此文件，等计数器为0的时候文件才会被关闭</strong></p>
<p><strong>父进程打开的文件，fork（）后子进程也可以访问，并且共享文件偏移量</strong></p>
<h3 id="22-系统调用">22.系统调用</h3>
<p><strong>内核是底层资源管理者，系统调用是内核暴露的 “入口”，C 库函数是对系统调用的 “封装与扩展”</strong>，</p>
<p><strong>实现在内核中</strong></p>
<p>1）表示命令</p>
<p>2）表示内核函数</p>
<p>3）表示库函数</p>
<ul>
<li><strong>系统调用</strong>是内核提供的 “原子操作”，负责与硬件和内核资源交互，特点是底层、高效（单次调用开销固定）、但易用性差、跨平台性差。</li>
<li><strong>库函数</strong>是对系统调用的封装，提供更友好的接口、优化（如缓冲）和跨平台支持，降低开发难度，同时通过减少系统调用次数提升性能。</li>
</ul>
<p>①<strong>系统调用与库函数的区别</strong> ？   <strong>产生中断陷入内核</strong></p>
<p>库函数实现在c库中，系统调用在内核中，实现一个printf函数会有一个用户态到内核态的切换</p>
<p>②<strong>既然使用库函数和系统调用都有系统调用的开销为什么推荐使用库函数？</strong></p>
<p><strong>用户态缓冲机制</strong>：这是最关键的优化。库函数会在用户态开辟缓冲区，积累数据后批量调用系统调用，而非每次操作都触发内核切换。、</p>
<p><strong>合并与优化操作</strong>：库函数会对连续的底层请求进行合并，减少内核态的重复工作。</p>
<p><strong>跨平台兼容性</strong>：库函数（如 C 标准库）屏蔽了不同操作系统的系统调用差异，相同代码可在 Linux、Windows 等系统上运行。</p>
<p><strong>更高的易用性</strong>，功能拓展</p>
<p><strong>用户态切换内核态</strong></p>
<p>每一个系统调用都有编号，当代码执行到需要内核函数时<strong>会产生中断</strong>，用户程序将系统调用号存入Eax寄存器，执行 <code>int 0x80</code> 或者调用指令 syscall后，CPU 跳转到内核的中断处理程序，完成从用户态（特权级 3）到内核态（特权级 0）的切换。通过根据系统调用号从内核函数表中，找到内核中被调用函数，执行完被调用函数后，其返回值被Eax寄存器返回到应用程序中，继续执行后续代码</p>
<p><strong>一、系统调用的触发机制</strong></p>
<p>用户程序通过<strong>系统调用接口</strong>（如 C 标准库的 <code>open</code>、<code>read</code> 等封装函数）发起请求，底层通过<strong>硬件指令</strong>触发特权级切换：</p>
<ul>
<li><strong>x86 早期架构</strong>：使用<strong>软中断指令 <code>int 0x80</code></strong>。用户程序将系统调用号存入寄存器（如 <code>eax</code>），执行 <code>int 0x80</code> 后，CPU 跳转到内核的中断处理程序，完成从用户态（特权级 3）到内核态（特权级 0）的切换。</li>
<li><strong>x86 现代架构</strong>：使用<strong>快速系统调用指令 <code>syscall</code></strong>。该指令更高效，通过 <code>syscall</code> 直接进入内核，并利用 MSR（模型特定寄存器）存储的内核入口地址快速跳转。</li>
</ul>
<p><strong>二、系统调用的处理流程</strong></p>
<ol>
<li><strong>参数传递</strong>：用户程序将系统调用号和参数存入指定寄存器（如 <code>eax</code> 存调用号，<code>ebx</code>、<code>ecx</code> 等存参数）。</li>
<li><strong>触发切换</strong>：执行 <code>int 0x80</code> 或 <code>syscall</code> 指令，CPU 切换到内核态，进入<strong>系统调用处理入口</strong>。</li>
<li><strong>内核查表执行</strong>：内核通过系统调用号在<strong>系统调用表</strong>（如 <code>sys_call_table</code>）中查找对应的内核处理函数（如 <code>sys_open</code>、<code>sys_read</code>），并执行该函数。</li>
<li><strong>返回用户态</strong>：内核处理完成后，将结果存入寄存器，恢复用户程序的上下文（如寄存器、栈），执行 <code>iret</code>（对应 <code>int 0x80</code>）或 <code>sysret</code>（对应 <code>syscall</code>）指令，切换回用户态，将结果返回给用户程序。</li>
</ol>
<p><strong>示例：<code>open</code> 系统调用的切换过程</strong></p>
<ol>
<li>用户程序调用 <code>open(&quot;file.txt&quot;, O_RDONLY)</code>，C 库将其封装为系统调用，设置系统调用号（如 <code>eax = 5</code>，对应 <code>sys_open</code>），并将文件名、权限等参数存入 <code>ebx</code>、<code>ecx</code> 等寄存器。</li>
<li>执行 <code>syscall</code> 指令，CPU 切换到内核态，进入内核的系统调用处理函数。</li>
<li>内核通过 <code>sys_call_table[5]</code> 找到 <code>sys_open</code> 函数，执行文件打开操作，将文件描述符存入 <code>eax</code>。</li>
<li>执行 <code>sysret</code> 指令，切换回用户态，用户程序从 <code>open</code> 调用中获取返回的文件描述符。</li>
<li></li>
</ol>
<h3 id="23-替换进程">23.替换进程</h3>
<p>fork()+execl()===全新的进程</p>
<p>execl(路径，第一个参数（函数名），第二个参数，……,(char*)0);      (char *)0必须加    通过man看参数</p>
<p>execlp（函数名，第一个参数（函数名），第二个参数，……,(char*)0); 通过环境变量</p>
<p>execle()；</p>
<p>execv（）；</p>
<p>最终调用的是execve（）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="number">4</span> <span class="built_in">printf</span>(<span class="string">&quot;%d  \n %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line"> <span class="number">5</span> execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,(<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line"> <span class="number">6</span> <span class="built_in">printf</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[],<span class="type">char</span>* envp[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;32mstu@stu-virtual-machine\033[0m:~/mycode/c2501/day08$&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buff[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(buff,<span class="number">128</span>,<span class="built_in">stdin</span>);<span class="comment">//abc</span></span><br><span class="line">        buff[<span class="built_in">strlen</span>(buff)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// ls</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(buff,<span class="string">&quot;exit&quot;</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( buff[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            execlp(buff,buff,(<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;没有找到这个命令:%s\n&quot;</span>,buff);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/">http://example.com/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">WF的知识空间</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言</div></div><div class="info-2"><div class="info-item-1">1.什么是指针 描述:由来+描述 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024Byte 1Byte=8bit  每一个Bit物理原件可以保存0或1 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 为什么？ 在计算机内部存在32根地址线供计算机给每个字节（内存中的最小单元）都分配了地址和编号 每一根电线	正电荷1	负电荷0(不固定)					  十六进制（0X）    8bit的空间 第一块字节编号	00000000 00000000 00000000 00000000	0X 00 00 00 00	00000000 第二块字节编号	00000000 00000000 00000000 00000001	0X 00 00 00 01	00000001 第三块字节编号	00000000 00000000 00000000 00000010	0X 00 00 00 02	00000010 第四块字节编号	...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WF</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WF-git-code"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="//github.com/WF-git-code" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18628492787@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%96%87%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">1.Linux系统基础文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">2.Linux系统基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%82%E6%94%BE%E5%A4%A7%E7%95%8C%E9%9D%A2%EF%BC%9Actrl-shift-%E2%80%9C-%E2%80%9D%E7%BC%A9%E5%B0%8F%E7%95%8C%E9%9D%A2%EF%BC%9Actrl-%E2%80%9D-%E2%80%9C"><span class="toc-number">2.0.1.</span> <span class="toc-text">1。放大界面：ctrl+shift+“+”			缩小界面：ctrl+”-“</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.第一个字符：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E4%B8%BA%E4%B8%89%E7%BB%84%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%80%85%E6%9D%83%E9%99%90%E7%BB%84%E5%91%98%E6%9D%83%E9%99%90%E5%85%B6%E4%BB%96%E4%BA%BA%E6%9D%83%E9%99%90rwx%E5%8F%AF%E8%AF%BB%E5%8F%AF%E5%86%99%E5%8F%AF%E6%89%A7%E8%A1%8C-777"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.分为三组：创建者权限	组员权限	其他人权限	rwx可读可写可执行   777</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90chmod"><span class="toc-number">2.0.4.</span> <span class="toc-text">4,修改文件权限	chmod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-pwd%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.0.5.</span> <span class="toc-text">5.pwd查看当前位置绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-man%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%8B%E5%86%8C%E5%8F%82%E6%95%B0%E4%B8%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.6.</span> <span class="toc-text">6.man：查看手册	参数为命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-ls"><span class="toc-number">2.0.7.</span> <span class="toc-text">7.ls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95mkdir-%E7%9B%AE%E5%BD%95%E5%90%8D"><span class="toc-number">2.0.8.</span> <span class="toc-text">8.创建目录	mkdir+目录名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95rmdir-%E7%9B%AE%E5%BD%95%E5%90%8D"><span class="toc-number">2.0.9.</span> <span class="toc-text">9.删除目录	rmdir+目录名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-vi%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">2.0.10.</span> <span class="toc-text">10.vi编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E8%BF%9B%E5%85%A5vi%E7%BC%96%E8%BE%91%E5%99%A8-%E7%9B%B8%E5%BD%93%E4%BA%8Ewinoows%E4%B8%8B%E7%9A%84%E8%AE%B0%E4%BA%8B%E6%9C%AC"><span class="toc-number">2.0.10.1.</span> <span class="toc-text">①进入vi编辑器(相当于winoows下的记事本)*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.0.10.2.</span> <span class="toc-text">②编辑模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.0.10.3.</span> <span class="toc-text">③命令模式:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-cat-%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">2.0.11.</span> <span class="toc-text">11.cat:在屏幕上打印文件信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12mv-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.12.</span> <span class="toc-text">12mv:移动文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.13.</span> <span class="toc-text">13.通配符的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-which-%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">2.0.14.</span> <span class="toc-text">14.which+命令：查找命令所在的文件在哪里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-find"><span class="toc-number">2.0.15.</span> <span class="toc-text">15.find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-tail-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-number">2.0.16.</span> <span class="toc-text">16.tail	 查看文件尾部内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-more%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-%E4%BB%A5%E7%BF%BB%E9%A1%B5%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.0.17.</span> <span class="toc-text">17.more	查看文件内容(以翻页形式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-cmp%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-number">2.0.18.</span> <span class="toc-text">18.cmp	比较两个文件是否相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9Dcp"><span class="toc-number">2.0.19.</span> <span class="toc-text">19.文件拷贝	cp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-head"><span class="toc-number">2.0.20.</span> <span class="toc-text">20.head</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%9D%83%E9%99%90%E6%8E%A9%E7%A0%81"><span class="toc-number">2.0.21.</span> <span class="toc-text">21.权限掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%89%93%E5%8C%85tar"><span class="toc-number">2.0.22.</span> <span class="toc-text">22.打包	tar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E6%B8%85%E5%B1%8Fclear"><span class="toc-number">2.0.23.</span> <span class="toc-text">23.清屏	clear</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7who"><span class="toc-number">2.0.24.</span> <span class="toc-text">24.查看当前用户	who</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F-date"><span class="toc-number">2.0.25.</span> <span class="toc-text">25.显示时间和日期:	date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-pS"><span class="toc-number">2.0.26.</span> <span class="toc-text">26.查看进程: 	pS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kill-%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B-kill-%E8%BF%9B%E7%A8%8BID"><span class="toc-number">2.0.27.</span> <span class="toc-text">kill   结束进程    kill+进程ID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4-ifconfig"><span class="toc-number">2.0.28.</span> <span class="toc-text">27.网络命令:	ifconfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-rm-%E5%88%A0%E9%99%A4"><span class="toc-number">2.0.29.</span> <span class="toc-text">28.rm 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-find-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.30.</span> <span class="toc-text">29.find    搜索文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-%E7%AE%A1%E9%81%93-%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BC%A0%E8%BE%93%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.0.31.</span> <span class="toc-text">30.管道	|   两个进程传输信息的工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E8%BF%87%E6%BB%A4-grep-%E5%AF%B9%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">2.0.32.</span> <span class="toc-text">31.过滤     grep  对命令执行结果进行过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-top-%E7%9B%B8%E5%BD%93%E4%BA%8Ewindows%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">2.0.33.</span> <span class="toc-text">32.top  相当于windows的任务管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-ldd-%E5%87%BD%E6%95%B0%E5%90%8D%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0%E6%89%80%E7%94%A8%E5%88%B0%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">2.0.34.</span> <span class="toc-text">33.ldd+函数名				查看函数所用到的共享库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-shell%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">3.shell命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAshell%E6%96%87%E6%9C%AC"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.创建shell文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">3.预定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9E%8B"><span class="toc-number">3.0.3.</span> <span class="toc-text">4.脚本文件的功能型:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.0.4.</span> <span class="toc-text">5.关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%87%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.0.5.</span> <span class="toc-text">6.文件运算符:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-if%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.0.6.</span> <span class="toc-text">7.if语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84"><span class="toc-number">3.0.7.</span> <span class="toc-text">8.数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.0.8.</span> <span class="toc-text">9.for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-continue-%E9%81%87%E5%88%B0%E5%90%8E%E8%B7%B3%E8%BF%87%E5%BD%93%E5%89%8D%E5%BE%AA%E7%8E%AF%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AC%A1"><span class="toc-number">3.0.9.</span> <span class="toc-text">10.continue:遇到后跳过当前循环，执行下一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break-%E9%81%87%E5%88%B0%E7%9B%B4%E6%8E%A5%E7%BB%93%E6%9D%9F%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.0.10.</span> <span class="toc-text">break:遇到直接结束循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-until%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.0.11.</span> <span class="toc-text">11.until语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-while%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.0.12.</span> <span class="toc-text">12.while语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%89%8D%E5%8F%B0%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">13.前台与后台的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-gcc%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91c%E8%AF%AD%E8%A8%80g-%E7%BC%96%E8%AF%91c-%E8%AF%AD%E8%A8%80"><span class="toc-number">3.2.</span> <span class="toc-text">14.gcc编译器编译c语言			g++编译c++语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-make%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8Amakefile%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">15.make命令以及makefile文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-gdb%E8%B0%83%E8%AF%95"><span class="toc-number">3.4.</span> <span class="toc-text">16.gdb调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">3.5.</span> <span class="toc-text">17.静态库与动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">18.计算机组成原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">19.进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%A4%8D%E5%88%B6%E8%BF%9B%E7%A8%8B-fork"><span class="toc-number">3.8.</span> <span class="toc-text">20.复制进程   fork</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.8.0.1.</span> <span class="toc-text">僵死进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.8.0.2.</span> <span class="toc-text">写时拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%81%9A%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.9.</span> <span class="toc-text">21.文件操作做的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.10.</span> <span class="toc-text">22.系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E6%9B%BF%E6%8D%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">23.替换进程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统">linux 系统</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言">C语言</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By WF</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>