<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | WF的知识空间</title><meta name="author" content="WF"><meta name="copyright" content="WF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用 集合结构：将一堆元素集合起来	数组 顺序结构：①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接后继节点 树形结构： 图形结构： 对于算法来说：一般用最差情况下的时间复杂度O(n) 一.线性表（顺序表+链表） 线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="WF的知识空间">
<meta property="og:description" content="数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用 集合结构：将一堆元素集合起来	数组 顺序结构：①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接后继节点 树形结构： 图形结构： 对于算法来说：一般用最差情况下的时间复杂度O(n) 一.线性表（顺序表+链表） 线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WF.png">
<meta property="article:published_time" content="2025-08-16T00:03:03.000Z">
<meta property="article:modified_time" content="2025-11-12T08:48:51.534Z">
<meta property="article:author" content="WF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法",
  "url": "http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/",
  "image": "http://example.com/img/WF.png",
  "datePublished": "2025-08-16T00:03:03.000Z",
  "dateModified": "2025-11-12T08:48:51.534Z",
  "author": [
    {
      "@type": "Person",
      "name": "WF",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WF的知识空间</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构与算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-12T08:48:51.534Z" title="更新于 2025-11-12 16:48:51">2025-11-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="数据结构：让数据可以以一种手段或者一种规则组成起来的集合方便管理和应用"><strong>数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用</strong></h3>
<p>集合结构：将一堆元素集合起来	数组</p>
<p>顺序结构：①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接后继节点</p>
<p>树形结构：</p>
<p>图形结构：</p>
<p>对于算法来说：一般用最差情况下的时间复杂度O(n)</p>
<h3 id="一-线性表（顺序表-链表）">一.线性表（顺序表+链表）</h3>
<p><strong>线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都有前驱（后继）。</strong></p>
<p>①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接尾驱节点</p>
<p><strong>顺序表：物理地址连续的线性结构</strong>（<strong>数组 != 顺序表</strong>）	<strong>（物理连续）</strong></p>
<p><strong>线性表： 物理地址不连续，但通过保存下一个节点的地址，可以访问，形成了一个逻辑上面的连续，又符合线性结构的特征</strong> <strong>（逻辑连续）</strong></p>
<p>一个最基础的顺序表由</p>
<p>① arr顺序表保存数据的空间主体<br>
② size记录顺序表中的元素的个数，为了更好的管理元素<br>
③ capacity记录顺序表中最大容量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];<span class="comment">//保存数据的空间</span></span><br><span class="line"><span class="type">int</span> size;<span class="comment">//统计顺序表中的个数</span></span><br><span class="line"><span class="type">int</span> Capacity;<span class="comment">//统计顺序表中的容量</span></span><br></pre></td></tr></table></figure>
<p>1.可扩容顺序表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建顺序表	结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seqlist</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>* arr;<span class="comment">//保存数据的空间   动态申请，动态扩容</span></span><br><span class="line">	<span class="type">int</span> seqlist;<span class="comment">//统计顺序表中的个数</span></span><br><span class="line">	<span class="type">int</span> capacity;<span class="comment">//统计顺序表中的容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-单向链表">1.单向链表</h3>
<p><strong>每一个节点（成员）需要保存下一个节点或成员的地址才可以形成一个逻辑上连续的线性结构。链表最后一个元素的下一个为NULL。对于链表而言也有一个管理者，可以管理链表头部和长度</strong></p>
<p>链表有一个管理员：8Byte</p>
<p>①管理链表头部的成员–指针</p>
<p>②统计链表的个数size</p>
<p>链表插入元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span><span class="comment">//每一个节点的结构体</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	List* next;</span><br><span class="line">&#125;List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line">	List* head;<span class="comment">//保存链表的头部</span></span><br><span class="line">	<span class="type">size_t</span> cursize;<span class="comment">//链表节点的个数</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"><span class="comment">//使用堆区资源进行管理链表</span></span><br><span class="line">List* <span class="title function_">BuyNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">	List* p1 = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	<span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	p1-&gt;val = data;</span><br><span class="line">	p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有前驱</span></span><br><span class="line">p6-&gt;next= p2;  p2-&gt;next=p6;<span class="comment">//中间插</span></span><br><span class="line">p6-&gt;next=p5;  p5-&gt;next=p6;<span class="comment">//尾删</span></span><br><span class="line"><span class="comment">//无前驱</span></span><br><span class="line">p6-&gt;next=head;     k-&gt;head=p6;<span class="comment">//头插</span></span><br><span class="line"><span class="comment">//删除  无前驱</span></span><br><span class="line">p2-&gt;next=p2-&gt;next-&gt;next;<span class="comment">//中间删</span></span><br><span class="line">p4-&gt;next=p4-&gt;next-&gt;next;</span><br><span class="line"><span class="comment">//有前驱</span></span><br><span class="line">k-&gt;head=k-&gt;head-&gt;next;<span class="comment">//头删</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List* <span class="title function_">PrevFindValue</span><span class="params">(<span class="type">const</span> List* pList, ElemType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = (List*)pList;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NO_Head_list.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">// 买节点</span></span><br><span class="line">List* <span class="title function_">Buy_Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">	List* new_List = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	<span class="keyword">if</span> (new_List == <span class="literal">NULL</span>)<span class="keyword">return</span> new_List;</span><br><span class="line">	new_List-&gt;val = val;</span><br><span class="line">	new_List-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> new_List;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLinkList</span><span class="params">(LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	pList-&gt;cuisize = <span class="number">0</span>;</span><br><span class="line">	pList-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取元素个数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">GetSize</span><span class="params">(<span class="type">const</span> LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> pList-&gt;cuisize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(<span class="type">const</span> LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> !pList-&gt;cuisize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.找到pos位置的节点并返回地址</span></span><br><span class="line">List* <span class="title function_">FindPos</span><span class="params">(<span class="type">const</span> LinkList* pList, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;GetSize(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (--pos) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.找到pos位置的节点前驱并返回地址</span></span><br><span class="line">List* <span class="title function_">PrevFindPos</span><span class="params">(<span class="type">const</span> LinkList* pList, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//验证pos范围</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;pList-&gt;cuisize + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//找pos节点的前驱</span></span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (--pos - <span class="number">1</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_Back</span><span class="params">(LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList)) &#123;</span><br><span class="line">		New_Node-&gt;next = pList-&gt;head;</span><br><span class="line">		pList-&gt;head = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		List* p = pList-&gt;head;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		New_Node-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	pList-&gt;cuisize++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_Head</span><span class="params">(LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//头插</span></span><br><span class="line">	List* new_List = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!new_List)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	new_List-&gt;next = pList-&gt;head;</span><br><span class="line">	pList-&gt;head = new_List;</span><br><span class="line">	pList-&gt;cuisize++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.按位置插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_pos</span><span class="params">(LinkList* pList, <span class="type">size_t</span> pos, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判断pos值范围</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;pList-&gt;cuisize + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//找pos位置的前驱</span></span><br><span class="line">	List* new_List = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!new_List)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">		new_List-&gt;next = pList-&gt;head;</span><br><span class="line">		pList-&gt;head = new_List;</span><br><span class="line">		pList-&gt;cuisize++;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (--pos - <span class="number">1</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	new_List-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = new_List;</span><br><span class="line">	pList-&gt;cuisize++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9.再ptr后插一个元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_ptr</span><span class="params">(LinkList* pList, List* ptr, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span> &amp;&amp; ptr != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//在ptr后插入元素</span></span><br><span class="line">	<span class="comment">//如果是头插则无头链表ptr和pList地址值相同</span></span><br><span class="line">	<span class="comment">//但是由于传值类型不同所以不可能是头插</span></span><br><span class="line">	<span class="keyword">if</span> (pList-&gt;cuisize == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/*if (pList==(LinkList*)ptr) &#123;</span></span><br><span class="line"><span class="comment">		ptr-&gt;next = pList-&gt;head;</span></span><br><span class="line"><span class="comment">		pList-&gt;head = ptr-&gt;next;</span></span><br><span class="line"><span class="comment">		pList-&gt;cuisize++;</span></span><br><span class="line"><span class="comment">		return true;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="keyword">if</span> (pList-&gt;cuisize == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* new_List = Buy_Node(val);</span><br><span class="line">	new_List-&gt;next = ptr-&gt;next;</span><br><span class="line">	ptr-&gt;next = new_List;</span><br><span class="line">	pList-&gt;cuisize++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10.按位置删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_pos</span><span class="params">(LinkList* pList, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//判断pos范围</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;pList-&gt;cuisize)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//找pos位置的前一个元素</span></span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">		pList-&gt;head = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = <span class="literal">NULL</span>;</span><br><span class="line">		pList-&gt;cuisize--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (--pos<span class="number">-1</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	List* temp = p-&gt;next;</span><br><span class="line">	p-&gt;next = temp-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	pList-&gt;cuisize--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11.打印链表所有元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_List</span><span class="params">(<span class="type">const</span> LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;val);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12.头删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_head</span><span class="params">(LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//头删</span></span><br><span class="line">	List* temp = pList-&gt;head;</span><br><span class="line">	pList-&gt;head = temp-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	pList-&gt;cuisize--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//13.尾删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_Back</span><span class="params">(LinkList* pList)</span> &#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//寻找尾节点前驱</span></span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">if</span> (pList-&gt;cuisize == <span class="number">1</span>) &#123;</span><br><span class="line">		List* temp = pList-&gt;head;</span><br><span class="line">		pList-&gt;head = temp-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">		pList-&gt;cuisize--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	List* temp = p-&gt;next;</span><br><span class="line">	p-&gt;next = temp-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	pList-&gt;cuisize--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//14.按值查找，返回当前节点，没有的话返回空</span></span><br><span class="line">List* <span class="title function_">FindValue</span><span class="params">(<span class="type">const</span> LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) <span class="keyword">return</span> p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//15.按值查找，返回当前节点前驱，没有的话返回空</span></span><br><span class="line">List* <span class="title function_">PrevFindValue</span><span class="params">(<span class="type">const</span> LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pList-&gt;head-&gt;val == val)<span class="keyword">return</span> (List*)pList;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next-&gt;val != val) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16.按值删除一次</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Removeval</span><span class="params">(LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//断言</span></span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	List* temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pList-&gt;head-&gt;val == val) &#123;</span><br><span class="line">		temp = p;</span><br><span class="line">		pList-&gt;head = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">		pList-&gt;cuisize--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next-&gt;val != val) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	temp = p-&gt;next;</span><br><span class="line">	p-&gt;next = temp-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	pList-&gt;cuisize--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//17.按值删除多次</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MemoreRemoveval</span><span class="params">(LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	List* temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//先处理第二个元素开始</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">			temp = p-&gt;next;</span><br><span class="line">			p-&gt;next = temp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(temp);</span><br><span class="line">			temp = <span class="literal">NULL</span>;</span><br><span class="line">			pList-&gt;cuisize--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断第一个元素</span></span><br><span class="line">	<span class="keyword">if</span> (pList-&gt;head-&gt;val == val) &#123;</span><br><span class="line">		temp = pList-&gt;head;</span><br><span class="line">		pList-&gt;head = temp-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">		pList-&gt;cuisize--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">MemoreRemoveval_headList</span><span class="params">(LinkList* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//判空</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//创建头节点</span></span><br><span class="line">	List* h = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	<span class="keyword">if</span> (h == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	h-&gt;next = pList-&gt;head;</span><br><span class="line">	List* p =h;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">			List* temp = p-&gt;next;</span><br><span class="line">			p-&gt;next = temp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(temp);</span><br><span class="line">			temp = <span class="literal">NULL</span>;</span><br><span class="line">			pList-&gt;cuisize--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	pList-&gt;head = h-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(h);</span><br><span class="line">	h = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//18.清除链表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		List* q = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	pList-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">	pList-&gt;cuisize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//19.销毁链表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(LinkList* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span>;</span><br><span class="line">	List* p = pList-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		List* q = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	pList-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">	pList-&gt;cuisize = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">free</span>(pList);</span><br><span class="line">	pList = <span class="literal">NULL</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">struct</span> List* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//申请头节点，由于要删倒数第n个因此要找其前驱</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">h</span> =</span> (<span class="keyword">struct</span> List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">	<span class="keyword">if</span> (h == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	h-&gt;next = head;</span><br><span class="line">	<span class="comment">//定义前驱指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">first</span> =</span> head;</span><br><span class="line">	<span class="comment">//定义要删除元素的前驱节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">second</span> =</span> h;</span><br><span class="line">	<span class="comment">//更新first指针</span></span><br><span class="line">	<span class="keyword">while</span> (--n) &#123;</span><br><span class="line">		first = first-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同步循环first和second指针</span></span><br><span class="line">	<span class="keyword">while</span> (first-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		first = first-&gt;next;</span><br><span class="line">		second = second-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此时删除second下一个节点元素</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">temp</span> =</span> second-&gt;next;</span><br><span class="line">	second-&gt;next = temp-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	head = h-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(h);</span><br><span class="line">	h = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表分为四种</p>
<p>1.<strong>没有头节点的链表（插入和删除都需要考虑特殊情况这个位置有没有前驱）</strong></p>
<p>2.<strong>带头节点的链表给首节点前面创造了一个前驱，则链表所有节点都有前驱所以所有节点操作方法一模一样，不需要特殊考虑</strong></p>
<p>注意：首节点是链表第一个元素的节点</p>
<p>头节点是人造的第一个元素节点的前驱（首节点的前驱）    核心目的：让每一个节点都有前驱</p>
<h4 id="逆置">逆置</h4>
<p>借助头节点       无限头插</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.单链表逆置(借助头节点无线头插）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse_List1</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">	assert(head != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(head))<span class="keyword">return</span>;</span><br><span class="line">	List* p = head-&gt;next;<span class="comment">//保存第一个有效节点地址</span></span><br><span class="line">	List* q = p-&gt;next;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;<span class="comment">//断开头节点</span></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		p-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = p;</span><br><span class="line">		p = q;</span><br><span class="line">		<span class="keyword">if</span>(q)q = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不借助头节点  就地逆置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse_List2</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">	assert(head != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(head))<span class="keyword">return</span>;</span><br><span class="line">	List* p = head;</span><br><span class="line">	List* q = head-&gt;next;</span><br><span class="line">	List* r = <span class="literal">NULL</span>;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		r = q-&gt;next;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		p = q;</span><br><span class="line">		q = r;</span><br><span class="line">	&#125;</span><br><span class="line">	head=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表是否相交"><strong>链表是否相交</strong></h4>
<p>定义两个指针，分别走到各自尾节点，判断尾节点是否相等      相等即相交</p>
<p><strong>找交点</strong></p>
<p>定义两个指针，求出长的单链表和短单链表差值，让长的先走差值长度，再同时走并且判断两个指针是否相等，相等则是交点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="type">int</span> A=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> B=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">PA</span>=</span>headA;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">PB</span>=</span>headB;</span><br><span class="line">    <span class="keyword">while</span>(PA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        A++;</span><br><span class="line">        PA=PA-&gt;next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(PB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        B++;</span><br><span class="line">        PB=PB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    PA=headA;</span><br><span class="line">    PB=headB;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">       n=A-B;</span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">                PA=PA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            n=-n;</span><br><span class="line">            <span class="keyword">while</span>(n--)&#123; </span><br><span class="line">                PB=PB-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(PA&amp;&amp;PB)&#123;<span class="comment">//此时PA   PB相距尾节点距离相等</span></span><br><span class="line">        <span class="keyword">if</span>(PA==PB)<span class="keyword">return</span> PA;    </span><br><span class="line">         PA=PA-&gt;next;</span><br><span class="line">         PB=PB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除任意节点（不是尾节点）"><strong>删除任意节点（不是尾节点）</strong></h4>
<p><strong>给出一个节点，不知道前驱，如何删除该节点</strong></p>
<p>①先判断p自身是不是尾节点，如果是直接返回无法删除</p>
<p>②申请一个q指向下一个节点，把q有效值拷贝到p</p>
<p>③删除q</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Delete_Node</span><span class="params">(Node*t)</span>&#123;</span><br><span class="line">    assert(t!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!t-&gt;next)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node*p=t;</span><br><span class="line">    Node*q=p-&gt;next;</span><br><span class="line">    p-&gt;val=q-&gt;val;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回文链表">回文链表</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="环形链表">环形链表</h4>
<p>判断是否有环</p>
<p><strong>快慢指针    快指针一次走两步，慢指针一次走一步，如果指针相遇即有交点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>找交点           依旧快慢指针     找到相遇点后定义一个新指针，然后让新指针和慢指针同时走，相遇点即入环点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-双向链表">2.双向链表</h3>
<p>双向链表相较于单向链表只多了一个保存前驱节点的指针域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">List* <span class="title function_">Buy_Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;<span class="comment">//购买新节点</span></span><br><span class="line">	List* New_Node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> New_Node;</span><br><span class="line">	New_Node-&gt;val = val;</span><br><span class="line">	New_Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	New_Node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> New_Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的链表需要在初始化阶段将头节点插入到链表中</span></span><br><span class="line"><span class="comment">//1.初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_DoubleList</span><span class="params">(List* pList)</span> &#123;</span><br><span class="line">	List* Head = Buy_Node(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Head)<span class="keyword">return</span>;</span><br><span class="line">	Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	Head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	pList = Head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取元素个数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">GetSize</span><span class="params">(<span class="type">const</span> List* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	List* p = (List*)pList;</span><br><span class="line">	<span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		count++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(<span class="type">const</span> List* pList)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> !pList-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.找到pos位置的节点并返回地址</span></span><br><span class="line">List* <span class="title function_">FindPos</span><span class="params">(<span class="type">const</span> List* pList, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= GetSize(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = pList-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pos--) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.找到pos位置的节点前驱并返回地址</span></span><br><span class="line">List* <span class="title function_">PrevFindPos</span><span class="params">(<span class="type">const</span> List* pList, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= GetSize(pList))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = (List*)pList;</span><br><span class="line">	<span class="keyword">while</span> (pos--) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.尾插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_Back</span><span class="params">(List* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = pList;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	New_Node-&gt;next = p-&gt;next;</span><br><span class="line">	New_Node-&gt;prev = p;</span><br><span class="line">	p-&gt;next = New_Node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_Head</span><span class="params">(List* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	New_Node-&gt;next = pList-&gt;next;</span><br><span class="line">	New_Node-&gt;prev = pList;</span><br><span class="line">	<span class="keyword">if</span> (!IsEmpty(pList))pList-&gt;next-&gt;prev = New_Node;</span><br><span class="line">	pList-&gt;next = New_Node;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.按位置插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_pos</span><span class="params">(List* pList, <span class="type">size_t</span> pos, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;GetSize(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* New_List = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_List)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = pList;</span><br><span class="line">	<span class="keyword">while</span> (--pos) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	New_List-&gt;next = p-&gt;next;</span><br><span class="line">	New_List-&gt;prev = p;</span><br><span class="line">	p-&gt;next-&gt;prev = New_List;</span><br><span class="line">	p-&gt;next = New_List;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9.再ptr后插一个元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert_ptr</span><span class="params">(List* pList, List* ptr, ElemType val)</span> &#123;</span><br><span class="line">	assert(ptr != <span class="literal">NULL</span>&amp;&amp;pList!=<span class="literal">NULL</span>);</span><br><span class="line">	List* New_List = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_List)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	New_List-&gt;next = ptr-&gt;next;</span><br><span class="line">	New_List-&gt;prev = ptr;</span><br><span class="line">	ptr-&gt;next-&gt;prev = New_List;</span><br><span class="line">	ptr-&gt;next = New_List;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10.按位置删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Del_pos</span><span class="params">(List* pList, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;GetSize(pList) - <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//由于有辅助节点因此任何节点的删除都不需要分情况讨论</span></span><br><span class="line">	List* p = pList;</span><br><span class="line">	<span class="keyword">while</span> (--p) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	List* temp = p-&gt;next;</span><br><span class="line">	p-&gt;next = temp-&gt;next;</span><br><span class="line">	temp-&gt;next-&gt;prev = p;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11.打印链表所有元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_List</span><span class="params">(List* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	List* p = pList;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;next-&gt;val);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12.头删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Del_head</span><span class="params">(List* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* temp = pList-&gt;next;</span><br><span class="line">	pList-&gt;next = temp-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(GetSize(pList)!=<span class="number">1</span>)temp-&gt;next-&gt;prev = pList;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//13.尾删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Del_Back</span><span class="params">(List* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = pList;</span><br><span class="line">	<span class="comment">//找前驱</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	List* temp = p-&gt;next;</span><br><span class="line">	p-&gt;next = temp-&gt;next;</span><br><span class="line">	temp-&gt;next-&gt;prev = p;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//14.按值查找，返回当前节点，没有的话返回空</span></span><br><span class="line">List* <span class="title function_">FindValue</span><span class="params">(<span class="type">const</span> List* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//遍历每个元素</span></span><br><span class="line">	List* p =pList-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) <span class="keyword">return</span> p;</span><br><span class="line">		<span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//15.按值查找，返回当前节点前驱，没有的话返回空</span></span><br><span class="line">List* <span class="title function_">PrevFindValue</span><span class="params">(<span class="type">const</span> List* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//遍历每个元素</span></span><br><span class="line">	List* p = pList-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) <span class="keyword">return</span> p-&gt;prev;</span><br><span class="line">		<span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16.按值删除一次</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Removeval</span><span class="params">(List* pList, ElemType val)</span>;</span><br><span class="line"><span class="comment">//17.按值删除多次</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MemoreRemoveval</span><span class="params">(List* pList, ElemType val)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(pList))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = pList-&gt;next;</span><br><span class="line">	List* q = pList;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">			List* temp = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			q-&gt;next = p;</span><br><span class="line">			p-&gt;prev = q;</span><br><span class="line">			<span class="built_in">free</span>(temp);</span><br><span class="line">			temp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//18.清除链表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(List* pList)</span>;</span><br><span class="line"><span class="comment">//19.销毁链表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(List* pList)</span> &#123;</span><br><span class="line">	assert(pList != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">while</span> (!IsEmpty(pList)) &#123;</span><br><span class="line">		List* p = pList-&gt;next;</span><br><span class="line">		pList-&gt;next = p-&gt;next;</span><br><span class="line">		pList-&gt;next-&gt;prev = pList;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-双向循环链表">3.双向循环链表</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;No_Head_Double_Circular_LinkList.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span><span class="comment">//每一个节点的结构体</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	List* next;</span><br><span class="line">	List* prev;</span><br><span class="line">&#125;List;</span><br><span class="line">List* <span class="title function_">Buy_Node</span><span class="params">(ElemType  val)</span> &#123;</span><br><span class="line">	List* New_Node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> New_Node;</span><br><span class="line">	New_Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	New_Node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	New_Node-&gt;val = val;</span><br><span class="line">	<span class="keyword">return</span> New_Node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitLinkList</span><span class="params">(List** first)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (*first != <span class="literal">NULL</span>) *first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.获取元素个数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">GetSize</span><span class="params">( List* first)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(first==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> cursize = <span class="number">0</span>;</span><br><span class="line">	List* p =first;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != first) &#123;</span><br><span class="line">		cursize++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cursize+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(<span class="type">const</span> List* first)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> !first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.找到pos位置的节点并返回地址</span></span><br><span class="line">List* <span class="title function_">FindPos</span><span class="params">(List* first, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;GetSize(first))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//绑定法</span></span><br><span class="line">	List* p = first;</span><br><span class="line">	<span class="comment">//因为无头因此i从开始</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; pos) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.找到pos位置的节点前驱并返回地址</span></span><br><span class="line">List* <span class="title function_">PrevFindPos</span><span class="params">(List* first, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;GetSize(first)+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos == GetSize(first) + <span class="number">1</span>)<span class="keyword">return</span> first-&gt;prev;</span><br><span class="line">	<span class="comment">//绑定法</span></span><br><span class="line">	List* p = first;</span><br><span class="line">	<span class="comment">//因为无头因此i从开始</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; pos) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.尾插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_Back</span><span class="params">(List** first, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//assert(first != NULL);</span></span><br><span class="line">	<span class="comment">//尾插分为多个元素的尾插,空表的尾插</span></span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first)) &#123;</span><br><span class="line">		New_Node-&gt;next = New_Node;</span><br><span class="line">		New_Node-&gt;prev = New_Node;</span><br><span class="line">		*first = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//找尾元素</span></span><br><span class="line">		List* p = *first;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;next != *first) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		New_Node-&gt;next = p-&gt;next;</span><br><span class="line">		New_Node-&gt;prev = p;</span><br><span class="line">		p-&gt;next = New_Node;</span><br><span class="line">		p = *first;</span><br><span class="line">		p-&gt;prev= New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.头插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_Head</span><span class="params">(List** first, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//头插分为空表的头插和多个元素的头插</span></span><br><span class="line">	<span class="comment">//买节点</span></span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first)) &#123;</span><br><span class="line">		New_Node-&gt;next = New_Node;</span><br><span class="line">		New_Node-&gt;prev = New_Node;</span><br><span class="line">		*first = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//因为是头插因此不用找尾巴元素</span></span><br><span class="line">		List* p = *first;<span class="comment">//保存头元素</span></span><br><span class="line">		New_Node-&gt;next = p;</span><br><span class="line">		New_Node-&gt;prev = p-&gt;prev;</span><br><span class="line">		p-&gt;prev-&gt;next = New_Node;</span><br><span class="line">		p-&gt;prev = New_Node;</span><br><span class="line">		*first = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.按位置插</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_pos</span><span class="params">(List** first, <span class="type">size_t</span> pos, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//assert(*first != NULL);</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;GetSize(*first) + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//买节点</span></span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//分情况讨论</span></span><br><span class="line">	<span class="comment">//空表的插入，头插，尾插，中间插</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first)&amp;&amp;pos==<span class="number">1</span>) &#123;</span><br><span class="line">		New_Node-&gt;next = New_Node;</span><br><span class="line">		New_Node-&gt;prev = New_Node;</span><br><span class="line">		*first = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">1</span> &amp;&amp; !IsEmpty(*first)) &#123;<span class="comment">//非空表且头插</span></span><br><span class="line">		<span class="comment">//因为是头插因此不用找尾巴元素</span></span><br><span class="line">		List* p = *first;<span class="comment">//保存头元素</span></span><br><span class="line">		New_Node-&gt;next = p;</span><br><span class="line">		New_Node-&gt;prev = p-&gt;prev;</span><br><span class="line">		p-&gt;prev-&gt;next = New_Node;</span><br><span class="line">		p-&gt;prev = New_Node;</span><br><span class="line">		*first = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pos == GetSize(*first) + <span class="number">1</span> &amp;&amp; !IsEmpty(*first)) &#123;<span class="comment">//非空且尾插</span></span><br><span class="line">		<span class="comment">//找尾元素</span></span><br><span class="line">		List* p = *first;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;next != *first) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		New_Node-&gt;next = p-&gt;next;</span><br><span class="line">		New_Node-&gt;prev = p;</span><br><span class="line">		p-&gt;next = New_Node;</span><br><span class="line">		p = *first;</span><br><span class="line">		p-&gt;prev = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//非空的中间插</span></span><br><span class="line">		<span class="comment">//找pos位置的前驱</span></span><br><span class="line">		List* p = PrevFindPos(*first, pos);</span><br><span class="line">		<span class="keyword">if</span> (!p)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		New_Node-&gt;next = p-&gt;next;</span><br><span class="line">		New_Node-&gt;prev = p;</span><br><span class="line">		p-&gt;next = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9.再ptr后插一个元素</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push_ptr</span><span class="params">(List** first, List* ptr, ElemType val)</span> &#123;</span><br><span class="line">	<span class="comment">//表不能为空且不可能为头插</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* New_Node = Buy_Node(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//不用分情况讨论</span></span><br><span class="line">	List* p = *first;</span><br><span class="line">	New_Node-&gt;next = ptr-&gt;next;</span><br><span class="line">	New_Node-&gt;prev = ptr;</span><br><span class="line">	ptr-&gt;next = New_Node;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10.按位置删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_pos</span><span class="params">(List** first, <span class="type">size_t</span> pos)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//判断pos范围</span></span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;GetSize(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//分情况</span></span><br><span class="line">	<span class="comment">//一个元素的删除，多个元素的头删，多个元素的中间删和尾删一样</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == GetSize(*first)&amp;&amp;pos==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(*first);</span><br><span class="line">		*first = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!IsEmpty(*first)&amp;&amp;pos==<span class="number">1</span>) &#123;</span><br><span class="line">		List* p = *first;</span><br><span class="line">		*first = p-&gt;next;</span><br><span class="line">		p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//找pos元素的前驱</span></span><br><span class="line">		List* prev_pos = PrevFindPos(*first, pos);</span><br><span class="line">		List* p = prev_pos-&gt;next;<span class="comment">//要删除的节点</span></span><br><span class="line">		prev_pos-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next-&gt;prev = prev_pos;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11.打印链表所有元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_List</span><span class="params">(List* first)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(first))<span class="keyword">return</span>;</span><br><span class="line">	List* p = first;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != first) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;val);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;val);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//12.头删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_head</span><span class="params">(List** first)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//一个元素的删除和多个元素的头删</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == GetSize(*first)) &#123;</span><br><span class="line">		<span class="built_in">free</span>(*first);</span><br><span class="line">		*first = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		List* p = *first;</span><br><span class="line">		*first = p-&gt;next;<span class="comment">//改变头元素</span></span><br><span class="line">		p-&gt;prev-&gt;next = p-&gt;next;<span class="comment">//改变尾元素next的指向</span></span><br><span class="line">		p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		p = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//13.尾删</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop_Back</span><span class="params">(List** first)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//尾删分为一个元素的删除的多个元素的尾删</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == GetSize(*first)) &#123;</span><br><span class="line">		<span class="built_in">free</span>(*first);</span><br><span class="line">		*first = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		List* p = *first;</span><br><span class="line">		List* temp = p-&gt;prev;<span class="comment">//要删除的元素</span></span><br><span class="line">		temp-&gt;prev-&gt;next = p;</span><br><span class="line">		p-&gt;prev = temp-&gt;prev;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//14.按值查找，返回当前节点，没有的话返回空</span></span><br><span class="line">List* <span class="title function_">FindValue</span><span class="params">(List* first, ElemType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(first))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = first;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != first) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val == val)<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//15.按值查找，返回当前节点前驱，没有的话返回空</span></span><br><span class="line">List* <span class="title function_">PrevFindValue</span><span class="params">(List* first, ElemType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(first))<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	List* p = first;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != first) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">			<span class="keyword">return</span> p-&gt;prev;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val == val)<span class="keyword">return</span> p-&gt;prev;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//16.按值删除一次</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Removeval</span><span class="params">(List** first, ElemType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = *first;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == GetSize(*first) &amp;&amp; p-&gt;val == val) &#123;<span class="comment">//有且仅有一个值并且这个值需要删除</span></span><br><span class="line">		<span class="built_in">free</span>(*first);</span><br><span class="line">		*first = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> COUNT = <span class="literal">true</span>;<span class="comment">//标记是否删除元素，</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != *first) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p == *first) &#123;<span class="comment">//多个元素头删</span></span><br><span class="line">				*first = p-&gt;next;<span class="comment">//改变头元素</span></span><br><span class="line">				p-&gt;prev-&gt;next = p-&gt;next;<span class="comment">//改变尾元素next的指向</span></span><br><span class="line">				p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">				<span class="built_in">free</span>(p);</span><br><span class="line">				p = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//多个元素中间删</span></span><br><span class="line">				List* temp = p;<span class="comment">//要删除的元素</span></span><br><span class="line">				p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">				p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">				<span class="built_in">free</span>(temp);</span><br><span class="line">				temp = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			COUNT = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (COUNT&amp;&amp; p-&gt;val == val) &#123;<span class="comment">//此时删除p,单独处理尾元素</span></span><br><span class="line">		List* temp = p;<span class="comment">//要删除的元素</span></span><br><span class="line">		p-&gt;prev-&gt;next = *first;</span><br><span class="line">		p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//17.按值删除多次</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MemoreRemoveval</span><span class="params">(List** first, ElemType val)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (IsEmpty(*first))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	List* p = *first;</span><br><span class="line">	<span class="comment">//按值删多次分为</span></span><br><span class="line">	<span class="comment">//有且仅有一个元素并要删除</span></span><br><span class="line">	<span class="comment">//多个元素的头删</span></span><br><span class="line">	<span class="comment">//多个元素中间删</span></span><br><span class="line">	<span class="comment">//单独处理最后一个元素//相当于尾巴删</span></span><br><span class="line">	<span class="comment">//由于要删除多次因此在每次删除前都要进行p指针位置的判断分类讨论</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == GetSize(*first) &amp;&amp; p-&gt;val == val) &#123;<span class="comment">//有且仅有一个值并且这个值需要删除</span></span><br><span class="line">		<span class="built_in">free</span>(*first);</span><br><span class="line">		*first = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> COUNT = <span class="literal">false</span>;<span class="comment">//标记是否删除元素</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != *first) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">			COUNT = <span class="literal">false</span>;</span><br><span class="line">			List* temp = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (*first == p) &#123;<span class="comment">//多个元素的头删</span></span><br><span class="line">				temp = *first;</span><br><span class="line">				*first = p-&gt;next;<span class="comment">//改变头元素</span></span><br><span class="line">				p-&gt;prev-&gt;next = p-&gt;next;<span class="comment">//改变尾元素next的指向</span></span><br><span class="line">				p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//多个元素的中间删</span></span><br><span class="line">				temp = p;<span class="comment">//要删除的元素</span></span><br><span class="line">				p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">				p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(temp);</span><br><span class="line">			temp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val == val) &#123;<span class="comment">//多个元素的尾删</span></span><br><span class="line">		COUNT = <span class="literal">false</span>;</span><br><span class="line">		List* temp = p;<span class="comment">//要删除的元素</span></span><br><span class="line">		p-&gt;prev-&gt;next = *first;</span><br><span class="line">		p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> !COUNT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//18.清除链表中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(List** first)</span> &#123;</span><br><span class="line">	List* p = *first;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != *first) &#123;</span><br><span class="line">		List* temp = p;<span class="comment">//temp保存要删除的元素</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-栈">4.栈</h3>
<p>栈只能一端进一端出，先进后出的线性表  LIFO  后进先出 FILO</p>
<p>插入和删除的一端一般称为栈顶，另一端为栈底。</p>
<p>插入功能一般称为入栈或压栈       <strong>链表的头插</strong></p>
<p>删除功能一般称为出栈或弹栈       <strong>链表的头删</strong></p>
<p>顺序表实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">Init_Seq_Stark</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	ElEMTYPE* p = (ElEMTYPE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElEMTYPE) * size);</span><br><span class="line">	<span class="keyword">if</span> (!p)<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	pss-&gt;arr = p;</span><br><span class="line">	pss-&gt;MaxSize = size;</span><br><span class="line">	pss-&gt;Top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(Seq_Stark* pss, ElEMTYPE val)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Full(pss)) &#123;</span><br><span class="line">		Increase(pss);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		*(pss-&gt;arr + pss-&gt;Top) = val;</span><br><span class="line">		pss-&gt;Top++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Empty(pss))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	pss-&gt;Top--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> !pss-&gt;Top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.判满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Full</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pss-&gt;Top == pss-&gt;MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.扩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Increase</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	ElEMTYPE* p = (ElEMTYPE*)<span class="built_in">realloc</span>(pss-&gt;arr, <span class="keyword">sizeof</span>(ElEMTYPE) * size * B);</span><br><span class="line">	<span class="keyword">if</span> (!p)<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	pss-&gt;arr = p;</span><br><span class="line">	pss-&gt;MaxSize = size * B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.清空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	pss-&gt;Top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">free</span>(pss-&gt;arr);</span><br><span class="line">	pss-&gt;arr = <span class="literal">NULL</span>;</span><br><span class="line">	pss-&gt;MaxSize = <span class="number">0</span>;</span><br><span class="line">	pss-&gt;Top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9.打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Printf</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pss-&gt;Top; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, *(pss-&gt;arr + i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.获取栈顶元素值</span></span><br><span class="line">ElEMTYPE <span class="title function_">Top</span><span class="params">(Seq_Stark* pss)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> *(pss-&gt;arr + (pss-&gt;Top<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">LStack_NODE* <span class="title function_">BUY_NODE</span><span class="params">(ELEMTYPE val)</span> &#123;</span><br><span class="line">	LStack_NODE* New_Node = (LStack_NODE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LStack_NODE));</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	New_Node-&gt;data = val;</span><br><span class="line">	New_Node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> New_Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">Init_Seq_Stark</span><span class="params">(LStack_NODE* pss)</span> &#123;</span><br><span class="line">	pss = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LStack_NODE* pass, ELEMTYPE val)</span> &#123;</span><br><span class="line">	LStack_NODE* New_Node = BUY_NODE(val);</span><br><span class="line">	<span class="keyword">if</span> (!New_Node)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!pass)pass = New_Node;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		New_Node-&gt;next = pass;</span><br><span class="line">		pass = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(LStack_NODE* pass)</span> &#123;</span><br><span class="line">	assert(pass != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Empty(pass))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LStack_NODE* temp = pass;</span><br><span class="line">	pass = pass-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(temp);</span><br><span class="line">	temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LStack_NODE* pass)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> !pass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.获取栈顶元素</span></span><br><span class="line">ELEMTYPE <span class="title function_">Top</span><span class="params">(LStack_NODE* pss)</span> &#123;</span><br><span class="line">	assert(pss != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> pss-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(LStack_NODE* pass)</span> &#123;</span><br><span class="line">	assert(pass != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Empty(pass))<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (pass != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LStack_NODE* Node = pass-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(pass);</span><br><span class="line">		pass = Node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Printf</span><span class="params">(LStack_NODE* pass)</span> &#123;</span><br><span class="line">	assert(pass != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Empty(pass))<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (pass != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pass-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-队列">5.队列</h3>
<h4 id="队列：先进先出">队列：先进先出</h4>
<p>队列插入操作：入队      <strong>链表的尾插</strong></p>
<p>队列删除操作：出队      <strong>链表的头删</strong></p>
<p>链表实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELEMTYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	NODE* next;</span><br><span class="line">&#125;NODE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link_QUEUE</span> &#123;</span><span class="comment">//记录对头和队尾</span></span><br><span class="line">	NODE* head;</span><br><span class="line">	NODE* Back;</span><br><span class="line">&#125;Link_QUEUE;</span><br><span class="line"></span><br><span class="line">NODE* <span class="title function_">BUYNODE</span><span class="params">(ELEMTYPE val)</span> &#123;<span class="comment">//买节点</span></span><br><span class="line">	NODE* NEW_NODE = (NODE*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">	<span class="keyword">if</span> (!NEW_NODE)<span class="keyword">return</span>;</span><br><span class="line">	NEW_NODE-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	NEW_NODE-&gt;val = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_QUEUE</span><span class="params">(Link_QUEUE*p)</span> &#123;</span><br><span class="line">	assert(p != <span class="literal">NULL</span>);</span><br><span class="line">	p-&gt;Back = p-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(Link_QUEUE* p, ELEMTYPE val)</span> &#123;<span class="comment">//队列的插入为单链表的尾插</span></span><br><span class="line">	assert(p != <span class="literal">NULL</span>);</span><br><span class="line">	NODE* NEW_NODE = BUYNODE(val);</span><br><span class="line">	<span class="keyword">if</span> (!NEW_NODE)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;Back || !p-&gt;head) &#123;</span><br><span class="line">		p-&gt;head = NEW_NODE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		NEW_NODE-&gt;next = p-&gt;Back-&gt;next;</span><br><span class="line">		p-&gt;Back-&gt;next = NEW_NODE;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;Back = NEW_NODE;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">POP</span><span class="params">(Link_QUEUE* p)</span> &#123;<span class="comment">//出队为链表的头删</span></span><br><span class="line">	assert(p != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;Back || p-&gt;head)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span>  &#123;</span><br><span class="line">		NODE* temp = p-&gt;head;</span><br><span class="line">		p-&gt;head = temp-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;head-&gt;next) &#123;</span><br><span class="line">		p-&gt;Back = p-&gt;head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PRINTF</span><span class="params">(Link_QUEUE* p)</span> &#123;</span><br><span class="line">	assert(p != <span class="literal">NULL</span>);</span><br><span class="line">	NODE* q = p-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, q-&gt;val);</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EMPTY</span><span class="params">(Link_QUEUE* p)</span> &#123;</span><br><span class="line">	assert(p != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> !(p-&gt;Back || p-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队顶元素值</span></span><br><span class="line">ELEMTYPE <span class="title function_">GETTOP</span><span class="params">(Link_QUEUE* p)</span> &#123;</span><br><span class="line">	assert(p != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> p-&gt;head-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个栈模拟实现队列"><strong>两个栈模拟实现队列</strong></h4>
<p><strong>插入规则:直接向ST1插入即可</strong></p>
<p><strong>删除规则:观察ST2是否为空，不空则直接出一个值即可，如果ST2为空，则将ST1里面的所有元素，依次倒腾到ST2中，这时ST2就不空了，直接出一个值即可如果ST2和ST1都为空，说明模拟出的队列是一个空队列，则不能出值</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(NODE* st1, NODE* st2, ELEMTYPE val)</span> &#123;</span><br><span class="line">	assert(st1 != <span class="literal">NULL</span>&amp;&amp;st2!=<span class="literal">NULL</span>);</span><br><span class="line">	NODE* New_Node = BUYNODE(val);</span><br><span class="line">	<span class="keyword">if</span> (!val)<span class="keyword">return</span>;			<span class="comment">//两个栈模拟队列的入队操作即像st1无线入栈</span></span><br><span class="line">	<span class="keyword">if</span> (!st1)st1 = New_Node;	<span class="comment">//而入栈操作即为单链表的头插</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		New_Node-&gt;next = st1-&gt;next;</span><br><span class="line">		st1 = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(NODE* st1, NODE* st2)</span> &#123;</span><br><span class="line">	assert(st1 != <span class="literal">NULL</span> &amp;&amp; st2 != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (st1 == <span class="literal">NULL</span> &amp;&amp; st2 == <span class="literal">NULL</span>)<span class="keyword">return</span>;<span class="comment">//如果两栈同时为空则证明队列中没有元素无法删除</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(st2)&#123;<span class="comment">//如果st2不空则出队操作即为从st2栈中出一个元素即为单链表的头删操作</span></span><br><span class="line">		NODE* temp = st2;</span><br><span class="line">		st2 = st2-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">		temp = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//此种情况为st1不空st2空需要将st1中所有元素按出栈的顺序转化为st2进栈的顺序元素挪到st2中</span></span><br><span class="line">		<span class="keyword">while</span> (st1!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">			NODE* temp = st1;<span class="comment">//头删</span></span><br><span class="line">			st1 = st1-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!st2)st2 = temp;<span class="comment">//头插操作</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				temp-&gt;next = st2-&gt;next;</span><br><span class="line">				st2 = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			st1 = st1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个队列模拟实现栈"><strong>两个队列模拟实现栈</strong></h4>
<p><strong>插入规则:直接向st1插</strong></p>
<p><strong>删除规则:首先确保st1和st2不能同时为空</strong></p>
<p><strong>观察st1   若st1不空，则将st1中全部数据留一个，剩余的全部按照队列的插入删除操作移到st2，然后将st1中剩余的元素出队</strong></p>
<p><strong>如果st1空，则st2一定不空，则将st2全部数据留一个，剩余的全部按照队列的插入删除操作移到st1，然后将st2中剩余出队</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Link_QUEUE* st1, Link_QUEUE* st2, ELEMTYPE val)</span> &#123;<span class="comment">//两个队列模拟栈的插入操作即为队列一无限进行插入操作（即单链表的尾插）</span></span><br><span class="line">	assert(st1 != <span class="literal">NULL</span> &amp;&amp; st2 != <span class="literal">NULL</span>);</span><br><span class="line">	NODE* New_Node = BUYNODE(val);</span><br><span class="line">	<span class="keyword">if</span> (!val)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!st1-&gt;Back || !st1-&gt;head) &#123;</span><br><span class="line">		st1-&gt;head = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		New_Node-&gt;next = st1-&gt;Back-&gt;next;</span><br><span class="line">		st1-&gt;Back-&gt;next = New_Node;</span><br><span class="line">	&#125;</span><br><span class="line">	st1-&gt;Back = New_Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(Link_QUEUE* st1, Link_QUEUE* st2)</span> &#123;<span class="comment">//两个队列模拟出栈操作    即如果st1不空将st1以出队的方式留最后一个</span></span><br><span class="line">											<span class="comment">//要出的元素剩下的导入st2中，然后出掉st1中的元素</span></span><br><span class="line">											<span class="comment">//如果st1空则st2一定不空，将将st2以出队的方式留最后一个</span></span><br><span class="line">											<span class="comment">//要出的元素剩下的导入st1中，然后出掉st2中的元素</span></span><br><span class="line">	assert(st1 != <span class="literal">NULL</span> &amp;&amp; st2 != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (st1-&gt;head == <span class="literal">NULL</span> &amp;&amp; st2-&gt;head == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (st1-&gt;head) &#123;<span class="comment">//st1不空并且只有一个元素直接出，如果多个元素需要将st1中元素除过最后一个剩下的全挪到st2中然后出st1</span></span><br><span class="line">		<span class="keyword">if</span> (!st1-&gt;head-&gt;next) &#123;</span><br><span class="line">			NODE* temp = st1-&gt;head;</span><br><span class="line">			st1-&gt;head = temp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!temp-&gt;next)st1-&gt;Back = st1-&gt;head;</span><br><span class="line">			<span class="built_in">free</span>(temp);</span><br><span class="line">			temp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//挪</span></span><br><span class="line">			<span class="keyword">while</span> (st1-&gt;head != st1-&gt;Back) &#123;</span><br><span class="line">				NODE* temp = st1-&gt;head;</span><br><span class="line">				st1-&gt;head = temp-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (!temp-&gt;next)st1-&gt;Back = st1-&gt;head;</span><br><span class="line">				<span class="keyword">if</span> (!st2-&gt;Back || !st2-&gt;head) &#123;</span><br><span class="line">					st2-&gt;head = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					temp-&gt;next = st2-&gt;Back-&gt;next;</span><br><span class="line">					st2-&gt;Back-&gt;next = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				st2-&gt;Back = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//这种情况为st1空，st2一定不空检测st2中元素个数如果只有一个直接出要是有多个需要将st2中元素除过最后一个剩下的全挪到st1中然后出st2</span></span><br><span class="line">		<span class="keyword">if</span> (!st2-&gt;head-&gt;next) &#123;</span><br><span class="line">			NODE* temp = st2-&gt;head;</span><br><span class="line">			st2-&gt;head = temp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!temp-&gt;next)st2-&gt;Back = st2-&gt;head;</span><br><span class="line">			<span class="built_in">free</span>(temp);</span><br><span class="line">			temp = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (st2-&gt;head != st2-&gt;Back) &#123;</span><br><span class="line">				NODE* temp = st2-&gt;head;</span><br><span class="line">				st2-&gt;head = temp-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (!temp-&gt;next)st2-&gt;Back = st2-&gt;head;</span><br><span class="line">				<span class="keyword">if</span> (!st1-&gt;Back || !st1-&gt;head) &#123;</span><br><span class="line">					st1-&gt;head = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					temp-&gt;next = st1-&gt;Back-&gt;next;</span><br><span class="line">					st1-&gt;Back-&gt;next = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				st1-&gt;Back = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环队列-头删尾进">**循环队列     **            头删尾进</h4>
<p>顺序表实现         使用场景：数据量知道一次申请足够空间**</p>
<p><strong>①如何让出队入队时间复杂度O(1)？</strong></p>
<p>让插入和删除时数据不动，只移动对头队尾指针</p>
<p>队头指针：指向第一个有效元素</p>
<p>队尾指针：指向最后一个有效元素的下一个位置（待插入位置）</p>
<p><strong>②在大量插入删除操作中，对头有很多空闲空间无法利用，怎么再次利用上？</strong></p>
<p>让尾巴和头相连形成循环</p>
<p>优点：前面空闲空间可以再次利用</p>
<p>坏处：无法扩容</p>
<p><strong>③由于头尾相连导致判空判满冲突，怎么解决？</strong></p>
<p>判空条件：头尾相遇</p>
<p>判满条件：头尾相遇</p>
<p>解决：第一种：添加标签，统计有效元素个数</p>
<p>​           第二种：在队尾浪费一个格子不用，当作标记（也就是说，当队尾指针向后走一步就会遇到对头，此时判满）</p>
<p><strong>④如何求有效元素个数——通用公式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length =((real-fornt)+MAXSIZE)%MAXSIZE</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCircleQueue</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	assert(pp != <span class="literal">NULL</span>);</span><br><span class="line">	pp-&gt;arr = (ElemType*)<span class="built_in">malloc</span>(SXQ_INIT_SIZE*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!pp-&gt;arr)<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	pp-&gt;CurSize = SXQ_INIT_SIZE;</span><br><span class="line">	pp-&gt;front = pp-&gt;real = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(CircleQueue* pp, ElemType val)</span> &#123;</span><br><span class="line">	assert(pp != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Full(pp))<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	pp-&gt;arr[pp-&gt;real] = val;</span><br><span class="line">	pp-&gt;real = (pp-&gt;real + <span class="number">1</span>) % pp-&gt;CurSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	assert(pp != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Empty(pp))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	pp-&gt;front = (pp-&gt;front + <span class="number">1</span>) % pp-&gt;CurSize;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.获取队头元素值</span></span><br><span class="line">ElemType <span class="title function_">Front</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (Empty(pp))<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> pp-&gt;arr[pp-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5.判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pp-&gt;real == pp-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.判满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Full</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (pp-&gt;real + <span class="number">1</span>+pp-&gt;CurSize)%pp-&gt;CurSize == pp-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7.销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destory</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	assert(pp != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">free</span>(pp-&gt;arr);</span><br><span class="line">	pp-&gt;arr = <span class="literal">NULL</span>;</span><br><span class="line">	pp-&gt;CurSize = pp-&gt;front = pp-&gt;real = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8.打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	assert(pp != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (Empty(pp))<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = pp-&gt;front; i != pp-&gt;real; i=(i+<span class="number">1</span>)%pp-&gt;CurSize) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, pp-&gt;arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;/n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9.获取元素个数</span></span><br><span class="line">ElemType <span class="title function_">getsize</span><span class="params">(CircleQueue* pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (pp-&gt;real - pp-&gt;front + pp-&gt;CurSize) % pp-&gt;CurSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二-排序算法">二.排序算法</h3>
<h4 id="1-冒泡排序"><strong>1.冒泡排序</strong></h4>
<p><strong>（小的元素上浮）———本质每次将最大的元素后移到最后</strong>O(N^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> swapped=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;				<span class="comment">//检测是否有交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n-i<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				temp = arr[i];</span><br><span class="line">				arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">				arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">if</span> (!swapped) &#123;			<span class="comment">//如果未交换，则只遍历一次，时间复杂度为O(n)。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用双层for循环嵌套的方式，时间复杂度：最坏和平均情况为O(n²)，最好情况为O(n)。</p>
<p><strong>进阶版</strong></p>
<p>鸡尾酒排序（双向冒泡排序）———从低到高然后从高到低来回排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cocktailSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;               <span class="comment">// 左边界（左侧已排序区域的右边界）</span></span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;          <span class="comment">// 右边界（右侧已排序区域的左边界）</span></span><br><span class="line">    <span class="type">int</span> swapped = <span class="number">1</span>;            <span class="comment">// 交换标志，1表示发生过交换，0表示未发生</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当左右边界未相遇且发生过交换时继续排序</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; swapped) &#123;</span><br><span class="line">        swapped = <span class="number">0</span>;            <span class="comment">// 重置交换标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一阶段：从左到右遍历，将最大元素移至右侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="number">1</span>;    <span class="comment">// 标记发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;                <span class="comment">// 右边界左移，缩小未排序区域</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左→右未发生交换，说明数组已有序，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swapped = <span class="number">0</span>;            <span class="comment">// 重置交换标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二阶段：从右到左遍历，将最小元素移至左侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt; left; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">                arr[i - <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="number">1</span>;    <span class="comment">// 标记发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;                 <span class="comment">// 左边界右移，缩小未排序区域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-选择排序"><strong>2.选择排序</strong></h4>
<p>**（找到(最大/最小)元素交换位置)**O(N^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_idx, temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 找出未排序部分的最小值索引</span></span><br><span class="line">        min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将找到的最小值与未排序数组的第一个元素交换</span></span><br><span class="line">        <span class="keyword">if</span> (min_idx != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min_idx];</span><br><span class="line">            arr[min_idx] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：和平均情况为 O(n²)</p>
<p>进阶</p>
<p>双向选择排序（同时选出最大最小值分别与数组两端交换）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bidirectionalSelectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;          <span class="comment">// 未排序区间的左边界</span></span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;     <span class="comment">// 未排序区间的右边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当左右边界未相遇时继续排序</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> minIdx = left;  <span class="comment">// 最小值的索引</span></span><br><span class="line">        <span class="type">int</span> maxIdx = left;  <span class="comment">// 最大值的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在未排序区间中找到最小值和最大值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = i;  <span class="comment">// 更新最小值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[maxIdx]) &#123;</span><br><span class="line">                maxIdx = i;  <span class="comment">// 更新最大值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将最小值交换到左边界</span></span><br><span class="line">        swap(&amp;arr[left], &amp;arr[minIdx]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况处理：如果最大值在左边界（被刚才的交换影响）</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx == left) &#123;</span><br><span class="line">            maxIdx = minIdx;  <span class="comment">// 修正最大值索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将最大值交换到右边界</span></span><br><span class="line">        swap(&amp;arr[right], &amp;arr[maxIdx]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缩小未排序区间</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-插入排序">3.插入排序</h4>
<p>​    数据状况影响时间复杂度     取最差O(N^2)</p>
<ol>
<li><strong>划分 “已排序” 和 “未排序” 区域</strong>初始时，将数组的第一个元素视为长度为 1 的 “已排序序列”，剩余元素为 “未排序序列”。</li>
<li><strong>逐个处理未排序元素</strong>从第二个元素开始，依次取出未排序序列的元素（称为 “待插入元素”），与已排序序列中的元素逐一比较。</li>
<li><strong>找到插入位置并移动元素</strong>若已排序序列中的元素大于待插入元素（假设升序），则将其向右移动一位，腾出位置；直到找到第一个小于或等于待插入元素的位置，将待插入元素插入该位置。</li>
<li><strong>重复直至所有元素有序</strong>每插入一个元素，已排序序列的长度增加 1，最终整个数组成为有序序列。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> temp;  <span class="comment">// 用于暂存待插入元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第2个元素开始（下标1），第一个元素默认已排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        temp = arr[i];  <span class="comment">// 取出当前待插入的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从已排序序列的末尾（i-1）向前比较</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当j &gt;= 0且已排序元素大于待插入元素时，将该元素后移</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 元素后移，腾出插入位置</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到插入位置（j+1），将待插入元素放入</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-二分查找">三.二分查找</h3>
<p>O（log n）</p>
<p>有序数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找函数：在有序数组arr中查找target，返回下标；未找到返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;          <span class="comment">// 查找范围左边界</span></span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;     <span class="comment">// 查找范围右边界</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当左边界 &lt;= 右边界时，继续查找</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 计算中间下标（避免溢出）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到目标，返回下标</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 目标在右半部分，缩小左边界</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 目标在左半部分，缩小右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到目标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找&gt;=3最左侧的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>];</span><br><span class="line"><span class="comment">//找&gt;=3最左侧的位置</span></span><br><span class="line">用二分实现</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>局部最小</p>
<p>arr无序，任何相邻数不相等   必存在局部最小</p>
<p>对于0位置 arr[0]&lt;arr[1]   对于i  arr[i-1]&gt;arr[i]&lt;arr[i+1]  对于N  arr[N-1]&gt;arr[N]</p>
<p>求任意一个局部最小位置</p>
<p>先判断0~1 和N~N-1</p>
<p>然后一直二分判断是否局部最小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>对数器</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/">http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">WF的知识空间</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C语言</div></div><div class="info-2"><div class="info-item-1">1.什么是指针 描述:由来+描述 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024Byte 1Byte=8bit  每一个Bit物理原件可以保存0或1 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 为什么？ 在计算机内部存在32根地址线供计算机给每个字节（内存中的最小单元）都分配了地址和编号 每一根电线	正电荷1	负电荷0(不固定)					  十六进制（0X）    8bit的空间 第一块字节编号	00000000 00000000 00000000 00000000	0X 00 00 00 00	00000000 第二块字节编号	00000000 00000000 00000000 00000001	0X 00 00 00 01	00000001 第三块字节编号	00000000 00000000 00000000 00000010	0X 00 00 00 02	00000010 第四块字节编号	...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WF</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WF-git-code"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="//github.com/WF-git-code" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18628492787@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E4%BB%A5%E4%B8%80%E7%A7%8D%E6%89%8B%E6%AE%B5%E6%88%96%E8%80%85%E4%B8%80%E7%A7%8D%E8%A7%84%E5%88%99%E7%BB%84%E6%88%90%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%9B%86%E5%90%88%E6%96%B9%E4%BE%BF%E7%AE%A1%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8-%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">一.线性表（顺序表+链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">1.单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">逆置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="toc-number">3.2.</span> <span class="toc-text">链表是否相交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BB%BB%E6%84%8F%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%8D%E6%98%AF%E5%B0%BE%E8%8A%82%E7%82%B9%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">删除任意节点（不是尾节点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">回文链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">环形链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">2.双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">3.双向循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%88"><span class="toc-number">6.</span> <span class="toc-text">4.栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">5.队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%9A%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-number">7.1.</span> <span class="toc-text">队列：先进先出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">7.2.</span> <span class="toc-text">两个栈模拟实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">7.3.</span> <span class="toc-text">两个队列模拟实现栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-%E5%A4%B4%E5%88%A0%E5%B0%BE%E8%BF%9B"><span class="toc-number">7.4.</span> <span class="toc-text">**循环队列     **            头删尾进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">二.排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">1.冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">2.选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">3.插入排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">9.</span> <span class="toc-text">三.二分查找</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统">linux 系统</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言">C语言</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By WF</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>