<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法 | WF的知识空间</title><meta name="author" content="WF"><meta name="copyright" content="WF"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用 集合结构：将一堆元素集合起来	数组 顺序结构：①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接后继节点 树形结构： 图形结构： 1.线性表（顺序表+链表） 线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都有前驱（后继）。 ①唯一的头	②唯一的尾	③除了首节">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="WF的知识空间">
<meta property="og:description" content="数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用 集合结构：将一堆元素集合起来	数组 顺序结构：①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接后继节点 树形结构： 图形结构： 1.线性表（顺序表+链表） 线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都有前驱（后继）。 ①唯一的头	②唯一的尾	③除了首节">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/WF.png">
<meta property="article:published_time" content="2025-08-16T00:03:03.000Z">
<meta property="article:modified_time" content="2025-10-11T12:15:30.080Z">
<meta property="article:author" content="WF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/WF.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法",
  "url": "http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/",
  "image": "http://example.com/img/WF.png",
  "datePublished": "2025-08-16T00:03:03.000Z",
  "dateModified": "2025-10-11T12:15:30.080Z",
  "author": [
    {
      "@type": "Person",
      "name": "WF",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/index-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">WF的知识空间</span></a><a class="nav-page-title" href="/"><span class="site-name">数据结构与算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-11T12:15:30.080Z" title="更新于 2025-10-11 20:15:30">2025-10-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="数据结构：让数据可以以一种手段或者一种规则组成起来的集合方便管理和应用"><strong>数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用</strong></h3>
<p>集合结构：将一堆元素集合起来	数组</p>
<p>顺序结构：①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接后继节点</p>
<p>树形结构：</p>
<p>图形结构：</p>
<h3 id="1-线性表（顺序表-链表）">1.线性表（顺序表+链表）</h3>
<p><strong>线性表概念：有且仅有一个开始节点和结束节点，并且除了开始（结束）节点之外，剩余所有节点都有前驱（后继）。</strong></p>
<p>①唯一的头	②唯一的尾	③除了首节点，都有直接前驱节点	④除了尾节点，都有直接尾驱节点</p>
<p><strong>顺序表：物理地址连续的线性结构</strong>（<strong>数组 != 顺序表</strong>）	<strong>（物理连续）</strong></p>
<p><strong>线性表： 物理地址不连续，但通过保存下一个节点的地址，可以访问，形成了一个逻辑上面的连续，又符合线性结构的特征</strong> <strong>（逻辑连续）</strong></p>
<p>一个最基础的顺序表由</p>
<p>① arr顺序表保存数据的空间主体<br>
② size记录顺序表中的元素的个数，为了更好的管理元素<br>
③ capacity记录顺序表中最大容量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];<span class="comment">//保存数据的空间</span></span><br><span class="line"><span class="type">int</span> size;<span class="comment">//统计顺序表中的个数</span></span><br><span class="line"><span class="type">int</span> Capacity;<span class="comment">//统计顺序表中的容量</span></span><br></pre></td></tr></table></figure>
<p>1.可扩容顺序表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建顺序表	结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seqlist</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>* arr;<span class="comment">//保存数据的空间   动态申请，动态扩容</span></span><br><span class="line">	<span class="type">int</span> seqlist;<span class="comment">//统计顺序表中的个数</span></span><br><span class="line">	<span class="type">int</span> capacity;<span class="comment">//统计顺序表中的容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="链表">链表</h4>
<h3 id="一-单向链表">一.单向链表</h3>
<p><strong>每一个节点（成员）需要保存下一个节点或成员的地址才可以形成一个逻辑上连续的线性结构。链表最后一个元素的下一个为NULL。对于链表而言也有一个管理者，可以管理链表头部和长度</strong></p>
<p>链表有一个管理员：8Byte</p>
<p>①管理链表头部的成员–指针</p>
<p>②统计链表的个数size</p>
<p>链表插入元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span><span class="comment">//每一个节点的结构体</span></span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	List* next;</span><br><span class="line">&#125;List;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line">	List* head;<span class="comment">//保存链表的头部</span></span><br><span class="line">	<span class="type">size_t</span> cursize;<span class="comment">//链表节点的个数</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"><span class="comment">//使用堆区资源进行管理链表</span></span><br><span class="line">List* <span class="title function_">BuyNode</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">	List* p1 = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	<span class="keyword">if</span> (p1 == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	p1-&gt;val = data;</span><br><span class="line">	p1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有前驱</span></span><br><span class="line">p6-&gt;next= p2;  p2-&gt;next=p6;<span class="comment">//中间插</span></span><br><span class="line">p6-&gt;next=p5;  p5-&gt;next=p6;<span class="comment">//尾删</span></span><br><span class="line"><span class="comment">//无前驱</span></span><br><span class="line">p6-&gt;next=head;     k-&gt;head=p6;<span class="comment">//头插</span></span><br><span class="line"><span class="comment">//删除  无前驱</span></span><br><span class="line">p2-&gt;next=p2-&gt;next-&gt;next;<span class="comment">//中间删</span></span><br><span class="line">p4-&gt;next=p4-&gt;next-&gt;next;</span><br><span class="line"><span class="comment">//有前驱</span></span><br><span class="line">k-&gt;head=k-&gt;head-&gt;next;<span class="comment">//头删</span></span><br></pre></td></tr></table></figure>
<p>链表分为四种</p>
<p>1.<strong>没有头节点的链表（插入和删除都需要考虑特殊情况这个位置有没有前驱）</strong></p>
<p>2.<strong>带头节点的链表给首节点前面创造了一个前驱，则链表所有节点都有前驱所以所有节点操作方法一模一样，不需要特殊考虑</strong></p>
<p>注意：首节点是链表第一个元素的节点</p>
<p>头节点是人造的第一个元素节点的前驱（首节点的前驱）    核心目的：让每一个节点都有前驱</p>
<h3 id="二-双向链表">二.双向链表</h3>
<h3 id="三-双向循环链表">三.双向循环链表</h3>
<h3 id="8-排序算法">8.排序算法</h3>
<p><strong>1.冒泡排序（小的元素上浮）———本质每次将最大的元素后移到最后</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> swapped=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;				<span class="comment">//检测是否有交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n-i<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				temp = arr[i];</span><br><span class="line">				arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">				arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">if</span> (!swapped) &#123;			<span class="comment">//如果未交换，则只遍历一次，时间复杂度为O(n)。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用双层for循环嵌套的方式，时间复杂度：最坏和平均情况为O(n²)，最好情况为O(n)。</p>
<p><strong>进阶版</strong></p>
<p>鸡尾酒排序（双向冒泡排序）———从低到高然后从高到低来回排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cocktailSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;               <span class="comment">// 左边界（左侧已排序区域的右边界）</span></span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;          <span class="comment">// 右边界（右侧已排序区域的左边界）</span></span><br><span class="line">    <span class="type">int</span> swapped = <span class="number">1</span>;            <span class="comment">// 交换标志，1表示发生过交换，0表示未发生</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当左右边界未相遇且发生过交换时继续排序</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; swapped) &#123;</span><br><span class="line">        swapped = <span class="number">0</span>;            <span class="comment">// 重置交换标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一阶段：从左到右遍历，将最大元素移至右侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="number">1</span>;    <span class="comment">// 标记发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;                <span class="comment">// 右边界左移，缩小未排序区域</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左→右未发生交换，说明数组已有序，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        swapped = <span class="number">0</span>;            <span class="comment">// 重置交换标志</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二阶段：从右到左遍历，将最小元素移至左侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = right; i &gt; left; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">                arr[i - <span class="number">1</span>] = temp;</span><br><span class="line">                swapped = <span class="number">1</span>;    <span class="comment">// 标记发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;                 <span class="comment">// 左边界右移，缩小未排序区域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.选择排序（找到(最大/最小)元素交换位置)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_idx, temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 找出未排序部分的最小值索引</span></span><br><span class="line">        min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min_idx]) &#123;</span><br><span class="line">                min_idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将找到的最小值与未排序数组的第一个元素交换</span></span><br><span class="line">        <span class="keyword">if</span> (min_idx != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min_idx];</span><br><span class="line">            arr[min_idx] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：和平均情况为 O(n²)</p>
<p>进阶</p>
<p>双向选择排序（同时选出最大最小值分别与数组两端交换）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bidirectionalSelectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;          <span class="comment">// 未排序区间的左边界</span></span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;     <span class="comment">// 未排序区间的右边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当左右边界未相遇时继续排序</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> minIdx = left;  <span class="comment">// 最小值的索引</span></span><br><span class="line">        <span class="type">int</span> maxIdx = left;  <span class="comment">// 最大值的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在未排序区间中找到最小值和最大值的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = i;  <span class="comment">// 更新最小值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[maxIdx]) &#123;</span><br><span class="line">                maxIdx = i;  <span class="comment">// 更新最大值索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将最小值交换到左边界</span></span><br><span class="line">        swap(&amp;arr[left], &amp;arr[minIdx]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况处理：如果最大值在左边界（被刚才的交换影响）</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx == left) &#123;</span><br><span class="line">            maxIdx = minIdx;  <span class="comment">// 修正最大值索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将最大值交换到右边界</span></span><br><span class="line">        swap(&amp;arr[right], &amp;arr[maxIdx]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缩小未排序区间</span></span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/">http://example.com/2025/08/16/%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">WF的知识空间</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/WF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C语言</div></div><div class="info-2"><div class="info-item-1">1.什么是指针 描述:由来+描述 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024Byte 1Byte=8bit  每一个Bit物理原件可以保存0或1 指针也就是内存地址，指针变量是用来存放地址的**变量,**必须在使用之前对其声明。 指针大小只与平台有关32位（x86系统）只有4B，64位（x64系统）8B,指针大小与指针类型，指针级数无关 为什么？ 在计算机内部存在32根地址线供计算机给每个字节（内存中的最小单元）都分配了地址和编号 每一根电线	正电荷1	负电荷0(不固定)					  十六进制（0X）    8bit的空间 第一块字节编号	00000000 00000000 00000000 00000000	0X 00 00 00 00	00000000 第二块字节编号	00000000 00000000 00000000 00000001	0X 00 00 00 01	00000001 第三块字节编号	00000000 00000000 00000000 00000010	0X 00 00 00 02	00000010 第四块字节编号	...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WF.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WF</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/WF-git-code"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="//github.com/WF-git-code" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/18628492787@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E4%BB%A5%E4%B8%80%E7%A7%8D%E6%89%8B%E6%AE%B5%E6%88%96%E8%80%85%E4%B8%80%E7%A7%8D%E8%A7%84%E5%88%99%E7%BB%84%E6%88%90%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%9B%86%E5%90%88%E6%96%B9%E4%BE%BF%E7%AE%A1%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">数据结构：让数据可以以一种手段或者一种规则组成起来的集合	方便管理和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8-%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">1.线性表（顺序表+链表）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">一.单向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">二.双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">三.双向循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">8.排序算法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2025-08-16T00:03:03.000Z" title="发表于 2025-08-16 08:03:03">2025-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/linux-%E7%B3%BB%E7%BB%9F/" title="linux 系统">linux 系统</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/27/%E2%80%98c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E2%80%99/" title="C语言">C语言</a><time datetime="2025-07-27T00:52:57.000Z" title="发表于 2025-07-27 08:52:57">2025-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By WF</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>